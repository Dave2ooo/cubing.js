"use strict";function e(e){const t=Array(e);for(let s=0;s<e;s++)t[s]=s;return t}function t(e,t){return e/function(e,t){if(e>t){const s=e;e=t,t=s}for(;e>0;){const s=t%e;t=e,e=s}return t}(e,t)*t}class Perm{constructor(e){this.n=e.length,this.p=e}toString(){return"Perm["+this.p.join(" ")+"]"}mul(e){const t=Array(this.n);for(let s=0;s<this.n;s++)t[s]=e.p[this.p[s]];return new Perm(t)}rmul(e){const t=Array(this.n);for(let s=0;s<this.n;s++)t[s]=this.p[e.p[s]];return new Perm(t)}inv(){const e=Array(this.n);for(let t=0;t<this.n;t++)e[this.p[t]]=t;return new Perm(e)}compareTo(e){for(let t=0;t<this.n;t++)if(this.p[t]!==e.p[t])return this.p[t]-e.p[t];return 0}toGap(){const e=new Array,t=new Array(this.n);for(let s=0;s<this.p.length;s++){if(t[s]||this.p[s]===s)continue;const o=new Array;for(let e=s;!t[e];e=this.p[e])o.push(1+e),t[e]=!0;e.push("("+o.join(",")+")")}return e.join("")}order(){let e=1;const s=new Array(this.n);for(let o=0;o<this.p.length;o++){if(s[o]||this.p[o]===o)continue;let i=0;for(let e=o;!s[e];e=this.p[e])i++,s[e]=!0;e=t(e,i)}return e}}class OrbitDef{constructor(e,t){this.size=e,this.mod=t}reassemblySize(){return function(e){let t=1;for(;e>1;)t*=e,e--;return t}(this.size)*Math.pow(this.mod,this.size)}}class OrbitsDef{constructor(e,t,s,o,i){this.orbitnames=e,this.orbitdefs=t,this.solved=s,this.movenames=o,this.moveops=i}toKsolve(e,t){const s=[];s.push("Name "+e),s.push("");for(let e=0;e<this.orbitnames.length;e++)s.push("Set "+this.orbitnames[e]+" "+this.orbitdefs[e].size+" "+this.orbitdefs[e].mod);s.push(""),s.push("Solved");for(let e=0;e<this.orbitnames.length;e++){s.push(this.orbitnames[e]);const t=this.solved.orbits[e].toKsolveVS();s.push(t[0]),s.push(t[1])}s.push("End"),s.push("");for(let e=0;e<this.movenames.length;e++){s.push("Move "+this.movenames[e]);for(let o=0;o<this.orbitnames.length;o++){if(!t&&this.moveops[e].orbits[o].isIdentity())continue;s.push(this.orbitnames[o]);const i=this.moveops[e].orbits[o].toKsolve();s.push(i[0]),s.push(i[1])}s.push("End"),s.push("")}return s}toKpuzzle(){const e={},t={};for(let s=0;s<this.orbitnames.length;s++)e[this.orbitnames[s]]={numPieces:this.orbitdefs[s].size,orientations:this.orbitdefs[s].mod},t[this.orbitnames[s]]=this.solved.orbits[s].toKpuzzle();const s={};for(let e=0;e<this.movenames.length;e++){const t={};for(let s=0;s<this.orbitnames.length;s++)t[this.orbitnames[s]]=this.moveops[e].orbits[s].toKpuzzle();s[this.movenames[e]]=t}return{orbits:e,startPieces:t,moves:s}}optimize(){const e=[],t=[],s=[],o=[];for(let e=0;e<this.moveops.length;e++)o.push([]);for(let i=0;i<this.orbitdefs.length;i++){const n=this.orbitdefs[i].mod,r=this.orbitdefs[i].size,h=new DisjointUnion(r),l=new Array(this.orbitdefs[i].size);for(let e=0;e<r;e++)l[e]=!1;for(let e=0;e<this.moveops.length;e++)for(let t=0;t<r;t++)this.moveops[e].orbits[i].perm[t]===t&&0===this.moveops[e].orbits[i].ori[t]||(l[t]=!0,h.union(t,this.moveops[e].orbits[i].perm[t]));let a=!0;if(n>1){a=!1;const e=new DisjointUnion(this.orbitdefs[i].size*n);for(let t=0;t<this.moveops.length;t++)for(let s=0;s<r;s++)if(this.moveops[t].orbits[i].perm[s]!==s||0!==this.moveops[t].orbits[i].ori[s])for(let o=0;o<n;o++)e.union(s*n+o,this.moveops[t].orbits[i].perm[s]*n+(o+this.moveops[t].orbits[i].ori[s])%n);for(let t=0;!a&&t<r;t++)for(let s=1;s<n;s++)e.find(t*n)===e.find(t*n+s)&&(a=!0);for(let e=0;!a&&e<r;e++)for(let t=0;t<e;t++)this.solved.orbits[i].perm[e]===this.solved.orbits[i].perm[t]&&(a=!0)}let c=-1,f=!1;for(let e=0;e<this.orbitdefs[i].size;e++)if(l[e]){const t=h.find(e);c<0?c=t:c!==t&&(f=!0)}for(let n=0;n<this.orbitdefs[i].size;n++){if(!l[n])continue;if(h.find(n)!==n)continue;const r=[],c=[];let u=0;for(let e=0;e<this.orbitdefs[i].size;e++)h.find(e)===n&&(r[u]=e,c[e]=u,u++);if(f?e.push(this.orbitnames[i]+"_p"+n):e.push(this.orbitnames[i]),a){t.push(new OrbitDef(u,this.orbitdefs[i].mod)),s.push(this.solved.orbits[i].remapVS(r,u));for(let e=0;e<this.moveops.length;e++)o[e].push(this.moveops[e].orbits[i].remap(r,c,u))}else{t.push(new OrbitDef(u,1)),s.push(this.solved.orbits[i].remapVS(r,u).killOri());for(let e=0;e<this.moveops.length;e++)o[e].push(this.moveops[e].orbits[i].remap(r,c,u).killOri())}}}return new OrbitsDef(e,t,new VisibleState(s),this.movenames,o.map(e=>new Transformation(e)))}scramble(e){const t=[];for(let e=0;e<this.moveops.length;e++)t[e]=this.moveops[e];for(let e=0;e<t.length;e++){const s=Math.floor(Math.random()*t.length),o=t[e];t[e]=t[s],t[s]=o}e<t.length&&(e=t.length);for(let s=0;s<e;s++){const e=Math.floor(Math.random()*t.length),s=Math.floor(Math.random()*t.length),o=Math.floor(Math.random()*this.moveops.length);t[e]=t[e].mul(t[s]).mul(this.moveops[o]),Math.random()<.1&&(t[e]=t[e].mul(this.moveops[o]))}let s=t[0];for(let e=1;e<t.length;e++)s=s.mul(t[e]);this.solved=this.solved.mul(s)}reassemblySize(){let e=1;for(let t=0;t<this.orbitdefs.length;t++)e*=this.orbitdefs[t].reassemblySize();return e}}class Orbit{constructor(e,t,s){this.perm=e,this.ori=t,this.orimod=s}static e(t,s){return new Orbit(e(t),function(e){const t=Array(e);for(let s=0;s<e;s++)t[s]=0;return t}(t),s)}mul(e){const t=this.perm.length,s=new Array(t),o=new Array(t);for(let i=0;i<t;i++)s[i]=this.perm[e.perm[i]],o[i]=(this.ori[e.perm[i]]+e.ori[i])%this.orimod;return new Orbit(s,o,this.orimod)}inv(){const e=this.perm.length,t=new Array(e),s=new Array(e);for(let o=0;o<e;o++)t[this.perm[o]]=o,s[this.perm[o]]=(this.orimod-this.ori[o])%this.orimod;return new Orbit(t,s,this.orimod)}equal(e){const t=this.perm.length;for(let s=0;s<t;s++)if(this.perm[s]!==e.perm[s]||this.ori[s]!==e.ori[s])return!1;return!0}killOri(){const e=this.perm.length;for(let t=0;t<e;t++)this.ori[t]=0;return this.orimod=1,this}toPerm(){const e=this.orimod;if(1===e)return new Perm(this.perm);const t=this.perm.length,s=new Array(t*e);for(let o=0;o<t;o++)for(let t=0;t<e;t++)s[o*e+t]=e*this.perm[o]+(this.ori[o]+t)%e;return new Perm(s)}identicalPieces(){const e=[],t=this.perm.length,s=[];for(let o=0;o<t;o++){const i=this.perm[o];if(void 0===e[i]){const n=[o];e[i]=!0;for(let e=o+1;e<t;e++)this.perm[e]===i&&n.push(e);s.push(n)}}return s}order(){return this.toPerm().order()}isIdentity(){const e=this.perm.length;for(let t=0;t<e;t++)if(this.perm[t]!==t||0!==this.ori[t])return!1;return!0}remap(e,t,s){const o=new Array(s),i=new Array(s);for(let n=0;n<s;n++)o[n]=t[this.perm[e[n]]],i[n]=this.ori[e[n]];return new Orbit(o,i,this.orimod)}remapVS(e,t){const s=new Array(t),o=new Array(t);let i=0;const n=[];for(let r=0;r<t;r++){const t=this.perm[e[r]];void 0===n[t]&&(n[t]=i++),s[r]=n[t],o[r]=this.ori[e[r]]}return new Orbit(s,o,this.orimod)}toKsolveVS(){return[this.perm.map(e=>e+1).join(" "),this.ori.join(" ")]}toKsolve(){const e=new Array(this.ori.length);for(let t=0;t<e.length;t++)e[this.perm[t]]=this.ori[t];return[this.perm.map(e=>e+1).join(" "),e.join(" ")]}toKpuzzle(){return{permutation:this.perm,orientation:this.ori}}}class TransformationBase{constructor(e){this.orbits=e}internalMul(e){const t=[];for(let s=0;s<this.orbits.length;s++)t.push(this.orbits[s].mul(e.orbits[s]));return t}internalInv(){const e=[];for(let t=0;t<this.orbits.length;t++)e.push(this.orbits[t].inv());return e}equal(e){for(let t=0;t<this.orbits.length;t++)if(!this.orbits[t].equal(e.orbits[t]))return!1;return!0}killOri(){for(let e=0;e<this.orbits.length;e++)this.orbits[e].killOri();return this}toPerm(){const e=new Array;let t=0;for(let s=0;s<this.orbits.length;s++){const o=this.orbits[s].toPerm();e.push(o),t+=o.n}const s=new Array(t);t=0;for(let o=0;o<this.orbits.length;o++){const i=e[o];for(let e=0;e<i.n;e++)s[t+e]=t+i.p[e];t+=i.n}return new Perm(s)}identicalPieces(){const e=[];let t=0;for(let s=0;s<this.orbits.length;s++){const o=this.orbits[s].orimod,i=this.orbits[s].identicalPieces();for(let s=0;s<i.length;s++)e.push(i[s].map(e=>e*o+t));t+=o*this.orbits[s].perm.length}return e}order(){let e=1;for(let s=0;s<this.orbits.length;s++)e=t(e,this.orbits[s].order());return e}}class Transformation extends TransformationBase{constructor(e){super(e)}mul(e){return new Transformation(this.internalMul(e))}mulScalar(e){if(0===e)return this.e();let t=this;for(e<0&&(t=t.inv(),e=-e);0==(1&e);)t=t.mul(t),e>>=1;if(1===e)return t;let s=t,o=this.e();for(;e>0;)1&e&&(o=o.mul(s)),e>1&&(s=s.mul(s)),e>>=1;return o}inv(){return new Transformation(this.internalInv())}e(){return new Transformation(this.orbits.map(e=>Orbit.e(e.perm.length,e.orimod)))}}class VisibleState extends TransformationBase{constructor(e){super(e)}mul(e){return new VisibleState(this.internalMul(e))}}class DisjointUnion{constructor(e){this.n=e,this.heads=new Array(e);for(let t=0;t<e;t++)this.heads[t]=t}find(e){let t=this.heads[e];return this.heads[t]===t||(t=this.find(this.heads[t]),this.heads[e]=t),t}union(e,t){const s=this.find(e),o=this.find(t);s<o?this.heads[o]=s:s>o&&(this.heads[s]=o)}}function s(e){let t=new Quat(0,0,0,0);for(let s=0;s<e.length;s++)t=t.sum(e[s]);return t.smul(1/e.length)}function o(e,t,s,o){const i=o[e].intersect3(o[t],o[s]);if(!i)return i;for(let n=0;n<o.length;n++)if(n!==e&&n!==t&&n!==s){const e=o[n].b*i.b+o[n].c*i.c+o[n].d*i.d;if(o[n].a>0&&e>o[n].a||o[n].a<0&&e<o[n].a)return!1}return i}class Quat{constructor(e,t,s,o){this.a=e,this.b=t,this.c=s,this.d=o}mul(e){return new Quat(this.a*e.a-this.b*e.b-this.c*e.c-this.d*e.d,this.a*e.b+this.b*e.a+this.c*e.d-this.d*e.c,this.a*e.c-this.b*e.d+this.c*e.a+this.d*e.b,this.a*e.d+this.b*e.c-this.c*e.b+this.d*e.a)}toString(){return"Q["+this.a+","+this.b+","+this.c+","+this.d+"]"}dist(e){return Math.hypot(this.a-e.a,this.b-e.b,this.c-e.c,this.d-e.d)}len(){return Math.hypot(this.a,this.b,this.c,this.d)}cross(e){return new Quat(0,this.c*e.d-this.d*e.c,this.d*e.b-this.b*e.d,this.b*e.c-this.c*e.b)}dot(e){return this.b*e.b+this.c*e.c+this.d*e.d}normalize(){const e=Math.sqrt(this.dot(this));return new Quat(this.a/e,this.b/e,this.c/e,this.d/e)}makenormal(){return new Quat(0,this.b,this.c,this.d).normalize()}normalizeplane(){const e=Math.hypot(this.b,this.c,this.d);return new Quat(this.a/e,this.b/e,this.c/e,this.d/e)}smul(e){return new Quat(this.a*e,this.b*e,this.c*e,this.d*e)}sum(e){return new Quat(this.a+e.a,this.b+e.b,this.c+e.c,this.d+e.d)}sub(e){return new Quat(this.a-e.a,this.b-e.b,this.c-e.c,this.d-e.d)}angle(){return 2*Math.acos(this.a)}invrot(){return new Quat(this.a,-this.b,-this.c,-this.d)}det3x3(e,t,s,o,i,n,r,h,l){return e*(i*l-n*h)+t*(n*r-o*l)+s*(o*h-i*r)}rotateplane(e){const t=e.mul(new Quat(0,this.b,this.c,this.d)).mul(e.invrot());return t.a=this.a,t}rotatepoint(e){return e.mul(this).mul(e.invrot())}rotateface(e){const t=this;return e.map(e=>e.rotatepoint(t))}rotatecubie(e){const t=this;return e.map(e=>t.rotateface(e))}intersect3(e,t){const s=this.det3x3(this.b,this.c,this.d,e.b,e.c,e.d,t.b,t.c,t.d);return!(Math.abs(s)<1e-9)&&new Quat(0,this.det3x3(this.a,this.c,this.d,e.a,e.c,e.d,t.a,t.c,t.d)/s,this.det3x3(this.b,this.a,this.d,e.b,e.a,e.d,t.b,t.a,t.d)/s,this.det3x3(this.b,this.c,this.a,e.b,e.c,e.a,t.b,t.c,t.a)/s)}side(e){return e>1e-9?1:e<-1e-9?-1:0}cutfaces(e){const t=this,s=this.a,o=[];for(let i=0;i<e.length;i++){const n=e[i],r=n.map(e=>t.side(e.dot(t)-s));let h=0;for(let e=0;e<r.length;e++)h|=1<<r[e]+1;if(5==(5&h))for(let e=-1;e<=1;e+=2){const t=[];for(let o=0;o<n.length;o++){r[o]!==e&&0!==r[o]||t.push(n[o]);const i=(o+1)%n.length;if(r[o]+r[i]===0&&0!==r[o]){const e=n[o].dot(this)-s,r=e/(e-(n[i].dot(this)-s)),h=n[o].smul(1-r).sum(n[i].smul(r));t.push(h)}}o.push(t)}else o.push(n)}return o}faceside(e){const t=this.a;for(let s=0;s<e.length;s++){const o=this.side(e[s].dot(this)-t);if(0!==o)return o}throw new Error("Could not determine side of plane in faceside")}sameplane(e){const t=this.normalize(),s=e.normalize();return t.dist(s)<1e-9||t.dist(s.smul(-1))<1e-9}makecut(e){return new Quat(e,this.b,this.c,this.d)}}function i(e,t){const s=[],o=[];for(let i=0;i<t.length;i++){const n=e.rotateplane(t[i]);let r=!1;for(let e=0;e<s.length;e++)if(n.dist(s[e])<1e-9){r=!0;break}r||(s.push(n),o.push(t[i]))}return o}function n(e){const t=[];for(let s=1;s<e.length;s++)for(let i=s+1;i<e.length;i++){const n=o(0,s,i,e);if(n){let e=!1;for(let s=0;s<t.length;s++)if(n.dist(t[s])<1e-9){e=!0;break}e||t.push(n)}}for(;;){let s=!1;for(let o=0;o<t.length;o++){const i=(o+1)%t.length;if(e[0].dot(t[o].cross(t[i]))<0){const e=t[o];t[o]=t[i],t[i]=e,s=!0}}if(!s)break}return t}const r={"2x2x2":"c f 0","3x3x3":"c f 0.333333333333333","4x4x4":"c f 0.5 f 0","5x5x5":"c f 0.6 f 0.2","6x6x6":"c f 0.666666666666667 f 0.333333333333333 f 0","7x7x7":"c f 0.714285714285714 f 0.428571428571429 f 0.142857142857143","8x8x8":"c f 0.75 f 0.5 f 0.25 f 0","9x9x9":"c f 0.777777777777778 f 0.555555555555556 f 0.333333333333333 f 0.111111111111111","10x10x10":"c f 0.8 f 0.6 f 0.4 f 0.2 f 0","11x11x11":"c f 0.818181818181818 f 0.636363636363636 f 0.454545454545455 f 0.272727272727273 f 0.0909090909090909","12x12x12":"c f 0.833333333333333 f 0.666666666666667 f 0.5 f 0.333333333333333 f 0.166666666666667 f 0","13x13x13":"c f 0.846153846153846 f 0.692307692307692 f 0.538461538461538 f 0.384615384615385 f 0.230769230769231 f 0.0769230769230769","20x20x20":"c f 0 f .1 f .2 f .3 f .4 f .5 f .6 f .7 f .8 f .9","30x30x30":"c f 0 f .066667 f .133333 f .2 f .266667 f .333333 f .4 f .466667 f .533333 f .6 f .666667 f .733333 f .8 f .866667 f .933333",skewb:"c v 0","master skewb":"c v 0.275","professor skewb":"c v 0 v 0.38","compy cube":"c v 0.915641442663986",helicopter:"c e 0.707106781186547",dino:"c v 0.577350269189626","little chop":"c e 0",pyramorphix:"t e 0",mastermorphix:"t e 0.346184634065199",pyraminx:"t v 0.333333333333333 v 1.66666666666667","Jing pyraminx":"t f 0","master paramorphix":"t e 0.866025403784437",megaminx:"d f 0.7",gigaminx:"d f 0.64 f 0.82",pentultimate:"d f 0",starminx:"d v 0.93796236956","starminx 2":"d f 0.23606797749979","pyraminx crystal":"d f 0.447213595499989",chopasaurus:"d v 0","big chop":"d e 0","skewb diamond":"o f 0",FTO:"o f 0.333333333333333","Christopher's jewel":"o v 0.577350269189626",octastar:"o e 0","Trajber's octahedron":"o v 0.433012701892219","radio chop":"i f 0",icosamate:"i v 0","icosahedron 2":"i v 0.18759247376021","icosahedron 3":"i v 0.18759247376021 e 0","icosahedron static faces":"i v 0.84","icosahedron moving faces":"i v 0.73","Eitan's star":"i f 0.61803398874989","2x2x2 + dino":"c f 0 v 0.577350269189626","2x2x2 + little chop":"c f 0 e 0","dino + little chop":"c v 0.577350269189626 e 0","2x2x2 + dino + little chop":"c f 0 v 0.577350269189626 e 0","megaminx + chopasaurus":"d f 0.61803398875 v 0","starminx combo":"d f 0.23606797749979 v 0.93796236956"},h={4:[["F","D","L","R"]],6:[["F","D","L","U","R"],["R","F","","B",""]],8:[["F","D","L","R"],["D","F","N",""],["N","D","","B"],["B","N","U","M"]],12:[["U","F","","","",""],["F","U","R","C","A","L"],["R","F","","","E",""],["E","R","","BF","",""],["BF","E","BR","BL","I","D"]],20:[["R","C","F","E"],["F","R","L","U"],["L","F","A",""],["E","R","G","I"],["I","E","S","H"],["S","I","J","B"],["B","S","K","D"],["K","B","M","O"],["O","K","P","N"],["P","O","Q",""]]},l={4:{F:"#00ff00",D:"#ffff00",L:"#ff0000",R:"#0000ff"},6:{U:"#ffffff",F:"#00ff00",R:"#ff0000",D:"#ffff00",B:"#0000ff",L:"#ff8000"},8:{U:"#e085b9",F:"#080d99",R:"#c1e35c",D:"#22955e",B:"#9121ab",L:"#b27814",M:"#0d35ad",N:"#eb126b"},12:{U:"#ffffff",F:"#006633",R:"#ff0000",C:"#ffffd0",A:"#3399ff",L:"#660099",E:"#ff66cc",BF:"#99ff00",BR:"#0000ff",BL:"#ffff00",I:"#ff6633",D:"#999999"},20:{R:"#db69f0",C:"#178fde",F:"#23238b",E:"#9cc726",L:"#2c212d",U:"#177fa7",A:"#e0de7f",G:"#2b57c0",I:"#41126b",S:"#4b8c28",H:"#7c098d",J:"#7fe7b4",B:"#85fb74",K:"#3f4bc3",D:"#0ff555",M:"#f1c2c8",O:"#58d340",P:"#c514f2",N:"#14494e",Q:"#8b1be1"}},a={4:["F","D","L","R"],6:["U","D","F","B","L","R"],8:["F","B","D","U","N","L","R","M"],12:["L","E","F","BF","R","I","U","D","BR","A","BL","C"],20:["L","S","E","O","F","B","I","P","R","K","U","D","J","A","Q","H","G","N","M","C"]};function c(e,t){for(let s=0;s<e.length;s++)if(e[s][0].dist(t)<1e-9)return s;throw new Error("Element not found")}function f(e,t,s){let o=0,i=!1;for(let e=0;e<=s;e++)t>>e&1&&(o|=1<<s-e);o<t&&(e=[e[2],e[3],e[0],e[1]],t=o,i=!0);let n=e[0],r="",h=0;for(;t>>1+h;)h++;return t===(2<<s)-1?n+="v":t===1<<h?h>0&&(r=String(h+1)):t===(2<<h)-1?(n=n.toLowerCase(),h>1&&(r=String(h+1))):r="_"+t+"_",[r+n,i]}function u(e,t){const s=[];let o=0;for(;o<e.length;){let i=!1;for(let n=0;n<t.length;n++)if(e.substr(o).startsWith(t[n][1])){s.push(t[n][1]),o+=t[n][1].length,i=!0;break}if(!i)throw new Error("Could not split "+e+" into face names.")}return s}function m(e,t){return[-e.b/t,-e.c/t,-e.d/t]}function p(e,t){const s=[],o=e.length;for(let i=0;i<o;i++)s[o-i-1]=m(e[i],t);return s}function g(e,t){const s=[];for(let o=1;o<10;o++){for(let o=0;o<e.length;o++){const i=(o+e.length-1)%e.length,n=(o+1)%e.length,r=e[i].sub(e[o]).normalize(),h=e[n].sub(e[o]).normalize(),l=r.dot(h),a=t/Math.sqrt(1-l*l);s[o]=e[o].sum(r.sum(h).smul(a))}let o=!0;for(let t=0;o&&t<s.length;t++){const i=(t+e.length-1)%e.length,n=(t+1)%e.length;s[i].sub(s[t]).cross(s[n].sub(s[t])).dot(s[t])>=0&&(o=!1)}if(o)return s;t/=2}return e}class PuzzleGeometry{constructor(e,t,s){if(this.args="",this.cmovesbyslice=[],this.verbose=0,this.allmoves=!1,this.cornersets=!0,this.centersets=!0,this.edgesets=!0,this.graycorners=!1,this.graycenters=!1,this.grayedges=!1,this.killorientation=!1,this.optimize=!1,this.scramble=0,this.fixPiece="",this.orientCenters=!1,this.duplicatedFaces=[],this.duplicatedCubies=[],this.fixedCubie=-1,this.net=[],this.colors=[],this.faceorder=[],this.faceprecedence=[],void 0!==s){if(s.length%2!=0)throw new Error("Odd length in option list?");for(let e=0;e<s.length;e+=2)if("verbose"===s[e])this.verbose++;else if("quiet"===s[e])this.verbose=0;else if("allmoves"===s[e])this.allmoves=s[e+1];else if("outerblockmoves"===s[e])this.outerblockmoves=s[e+1];else if("vertexmoves"===s[e])this.vertexmoves=s[e+1];else if("rotations"===s[e])this.addrotations=s[e+1];else if("cornersets"===s[e])this.cornersets=s[e+1];else if("centersets"===s[e])this.centersets=s[e+1];else if("edgesets"===s[e])this.edgesets=s[e+1];else if("graycorners"===s[e])this.graycorners=s[e+1];else if("graycenters"===s[e])this.graycenters=s[e+1];else if("grayedges"===s[e])this.grayedges=s[e+1];else if("movelist"===s[e])this.movelist=s[e+1];else if("killorientation"===s[e])this.killorientation=s[e+1];else if("optimize"===s[e])this.optimize=s[e+1];else if("scramble"===s[e])this.scramble=s[e+1];else if("fix"===s[e])this.fixPiece=s[e+1];else{if("orientcenters"!==s[e])throw new Error("Bad option while processing option list "+s[e]);this.orientCenters=s[e+1]}}this.args=e+" "+t.map(e=>e.join(" ")).join(" "),s&&(this.args+=" "+s.join(" ")),this.verbose>0&&console.log(this.header("# ")),this.create(e,t)}create(e,t){this.moveplanes=[],this.faces=[],this.cubies=[];let s=null;switch(e){case"c":s=function(){const e=Math.sqrt(.5);return[new Quat(e,e,0,0),new Quat(e,0,e,0)]}();break;case"o":s=function(){const e=Math.sqrt(.5);return[new Quat(.5,.5,.5,.5),new Quat(e,0,0,e)]}();break;case"i":s=function(){let e=1/6+Math.sqrt(5)/6,t=2/3+Math.sqrt(5)/3;const s=Math.sqrt(e*e+t*t);e/=s,t/=s;const o=2*Math.PI/6;return[new Quat(Math.cos(o),e*Math.sin(o),t*Math.sin(o),0),new Quat(Math.cos(o),-e*Math.sin(o),t*Math.sin(o),0)]}();break;case"t":s=[new Quat(.5,.5,.5,.5),new Quat(.5,.5,.5,-.5)];break;case"d":s=function(){const e=2*Math.PI/10;let t=.5+.3*Math.sqrt(5),s=.5+.1*Math.sqrt(5);const o=Math.sqrt(t*t+s*s);return t/=o,s/=o,[new Quat(Math.cos(e),t*Math.sin(e),s*Math.sin(e),0),new Quat(.5,.5,.5,.5)]}();break;default:throw new Error("Bad shape argument: "+e)}this.rotations=function(e){const t=[new Quat(1,0,0,0)];for(let s=0;s<t.length;s++)for(let o=0;o<e.length;o++){const i=e[o].mul(t[s]),n=i.smul(-1);let r=!1;for(let e=0;e<t.length;e++)if(i.dist(t[e])<1e-9||n.dist(t[e])<1e-9){r=!0;break}r||t.push(i)}return t}(s),this.verbose&&console.log("# Rotations: "+this.rotations.length);const o=s[0];this.baseplanerot=i(o,this.rotations);const r=this.baseplanerot.map(e=>o.rotateplane(e));this.baseplanes=r,this.basefacecount=r.length;const f=h[r.length];this.net=f,this.colors=l[r.length],this.faceorder=a[r.length],this.verbose&&console.log("# Base planes: "+r.length);const u=n(r);this.verbose&&console.log("# Face vertices: "+u.length);const m=r[0].makenormal(),p=u[0].sum(u[1]).makenormal(),g=u[0].makenormal(),d=[];for(let e=0;e<t.length;e++){let s=null;switch(t[e][0]){case"f":s=m;break;case"v":s=g;break;case"e":s=p;break;default:throw new Error("Bad cut argument: "+t[e][0])}d.push(s.makecut(t[e][1]))}const b=new Quat(1,m.b,m.c,m.d);this.verbose&&console.log("# Boundary is "+b);let v=[n(i(b,this.rotations).map(e=>b.rotateplane(e)))];this.basefaces=[];for(let e=0;e<this.baseplanerot.length;e++){const t=this.baseplanerot[e].rotateface(v[0]);this.basefaces.push(t)}const w=[],x=[],k=[],y=[],z=v[0].length;function M(e,t,s){for(let o=0;o<e.length;o++)if(e[o][0].dist(t)<1e-9)return void e[o].push(s);e.push([t,s])}for(let e=0;e<this.baseplanerot.length;e++){const t=this.baseplanerot[e].rotateface(v[0]);for(let s=0;s<t.length;s++){const o=(s+1)%t.length;M(y,t[s].sum(t[o]).smul(.5),e)}}const E=[];for(let e=0;e<this.baseplanerot.length;e++){const t=this.baseplanerot[e].rotateface(v[0]),s=[];for(let o=0;o<t.length;o++){const i=(o+1)%t.length,n=y[c(y,t[o].sum(t[i]).smul(.5))];if(e===n[1])s.push(n[2]);else{if(e!==n[2])throw new Error("Could not find edge");s.push(n[1])}}E.push(s)}const B={},F=[];F.push(f[0][0]),B[f[0][0]]=0,F[E[0][0]]=f[0][1],B[f[0][1]]=E[0][0];for(let e=0;e<f.length;e++){const t=B[f[e][0]];if(void 0===t)throw new Error("Bad edge description; first edge not connected");let s=-1;for(let o=0;o<E[t].length;o++){const i=F[E[t][o]];if(void 0!==i&&i===f[e][1]){s=o;break}}if(s<0)throw new Error("First element of a net not known");for(let o=2;o<f[e].length;o++){if(""===f[e][o])continue;const i=E[t][(o+s-1)%z],n=F[i];if(void 0!==n&&n!==f[e][o])throw new Error("Face mismatch in net");F[i]=f[e][o],B[f[e][o]]=i}}for(let e=0;e<F.length;e++){let t=!1;for(let s=0;s<this.faceorder.length;s++)if(F[e]===this.faceorder[s]){this.faceprecedence[e]=s,t=!0;break}if(!t)throw new Error("Could not find face "+F[e]+" in face order list "+this.faceorder)}for(let e=0;e<this.baseplanerot.length;e++){const t=this.baseplanerot[e].rotateface(v[0]),s=b.rotateplane(this.baseplanerot[e]),o=F[e];w.push([t,o]),x.push([s,o])}for(let e=0;e<this.baseplanerot.length;e++){const t=this.baseplanerot[e].rotateface(v[0]),s=F[e];for(let e=0;e<t.length;e++){const o=(e+1)%t.length,i=t[e].sum(t[o]).smul(.5),n=(e+2)%t.length,r=t[o].sum(t[n]).smul(.5),h=c(y,i),l=c(y,r);M(k,t[o],[s,l,h])}}for(let e=0;e<y.length;e++){if(3!==y[e].length)throw new Error("Bad length in edge names "+y[e]);let t=F[y[e][1]];const s=F[y[e][2]];this.faceprecedence[y[e][1]]<this.faceprecedence[y[e][2]]?t+=s:t=s+t,y[e]=[y[e][0],t]}this.cornerfaces=k[0].length-1;for(let e=0;e<k.length;e++){if(k[e].length<4)throw new Error("Bad length in vertex names");let t=1;for(let s=2;s<k[e].length;s++)this.faceprecedence[B[k[e][s][0]]]<this.faceprecedence[B[k[e][t][0]]]&&(t=s);let s="";for(let o=1;o<k[e].length;o++){s+=k[e][t][0];for(let s=1;s<k[e].length;s++)if(k[e][t][2]===k[e][s][1]){t=s;break}}k[e]=[k[e][0],s]}this.verbose>1&&(console.log("Face precedence list: "+this.faceorder.join(" ")),console.log("Face names: "+w.map(e=>e[1]).join(" ")),console.log("Edge names: "+y.map(e=>e[1]).join(" ")),console.log("Vertex names: "+k.map(e=>e[1]).join(" ")));const P=[];for(let e=0;e<x.length;e++)P.push([x[e][0].makenormal(),x[e][1],"f"]);for(let e=0;e<y.length;e++)P.push([y[e][0].makenormal(),y[e][1],"e"]);for(let e=0;e<k.length;e++)P.push([k[e][0].makenormal(),k[e][1],"v"]);this.facenames=w,this.faceplanes=x,this.edgenames=y,this.vertexnames=k,this.geonormals=P;const D=new Quat(0,0,0,0);this.edgedistance=v[0][0].sum(v[0][1]).smul(.5).dist(D),this.vertexdistance=v[0][0].dist(D),this.verbose&&console.log("# Distances: face 1 edge "+this.edgedistance+" vertex "+this.vertexdistance);for(let e=0;e<d.length;e++)for(let t=0;t<this.rotations.length;t++){const s=d[e].rotateplane(this.rotations[t]);let o=!1;for(let e=0;e<this.moveplanes.length;e++)if(s.sameplane(this.moveplanes[e])){o=!0;break}o||(this.moveplanes.push(s),v=s.cutfaces(v))}this.faces=v,this.verbose&&console.log("# Faces is now "+v.length),this.stickersperface=v.length;let O=1e99;for(let e=0;e<v.length;e++)for(let t=0;t<v[e].length;t++){const s=(t+1)%v[e].length,o=v[e][t].dist(v[e][s]);o<O&&(O=o)}this.shortedge=O,this.verbose&&console.log("# Short edge is "+O)}keyface(e){let t="";for(let s=0;s<this.moveplanesets.length;s++){let o=0;for(let t=0;t<this.moveplanesets[s].length;t++)this.moveplanesets[s][t].faceside(e)>0&&o++;t=t+" "+o}return t}findcubie(e){return this.facetocubies[this.findface(e)][0]}findface(e){const t=s(e),o=this.keyface(e);for(let e=0;e<this.facelisthash[o].length;e++){const i=this.facelisthash[o][e];if(Math.abs(t.dist(s(this.faces[i])))<1e-9)return i}throw new Error("Could not find face.")}project2d(e,t,s){const o=this.facenames[e][0],i=(t+1)%o.length,n=this.baseplanes[e];let r=o[i].sub(o[t]);const h=r.len();r=r.normalize();const l=r.cross(n).normalize();let a=s[1].sub(s[0]);const c=a.len()/h;a=a.normalize();const f=a.b,u=a.c,m=r.smul(f).sub(l.smul(u)).smul(c),p=l.smul(f).sum(r.smul(u)).smul(c),g=new Quat(0,s[0].b-m.dot(o[t]),s[0].c-p.dot(o[t]),0);return[m,p,g]}allstickers(){this.faces=function(e,t){const s=[];for(let o=0;o<e.length;o++)for(let i=0;i<t.length;i++){const n=t[i],r=[];for(let t=0;t<n.length;t++)r.push(n[t].rotateplane(e[o]));s.push(r)}return s}(this.baseplanerot,this.faces),this.verbose&&console.log("# Total stickers is now "+this.faces.length);const e=[];for(let t=0;t<this.moveplanes.length;t++){let s=!1;const o=this.moveplanes[t],i=o.makenormal();for(let t=0;t<e.length;t++)if(i.sameplane(e[t][0].makenormal())){e[t].push(o),s=!0;break}s||e.push([o])}for(let t=0;t<e.length;t++){const s=e[t].map(e=>e.normalizeplane()),o=s[0].makenormal();for(let e=0;e<s.length;e++)s[e].makenormal().dist(o)>1e-9&&(s[e]=s[e].smul(-1));s.sort((e,t)=>e.a-t.a),e[t]=s}this.moveplanesets=e;const t=e.map(e=>e.length);this.verbose&&console.log("# Move plane sets: "+t);const o=[];for(let t=0;t<e.length;t++)o.push([]);for(let t=0;t<this.rotations.length;t++){const s=this.rotations[t];if(Math.abs(Math.abs(s.a)-1)<1e-9)continue;const i=s.makenormal();for(let t=0;t<e.length;t++)if(i.sameplane(e[t][0].makenormal())){o[t].push(s);break}}this.moverotations=o;for(let t=0;t<o.length;t++){const s=o[t],i=s[0].makenormal();for(let e=0;e<s.length;e++)i.dist(s[e].makenormal())>1e-9&&(s[e]=s[e].smul(-1));s.sort((e,t)=>e.angle()-t.angle()),o[t][0].dot(e[t][0])<0&&s.reverse()}const i=o.map(e=>1+e.length);this.movesetorders=i;const n=[];for(let t=0;t<e.length;t++){const s=e[t][0].makenormal();let o=null,i=null;for(let e=0;e<this.geonormals.length;e++){const t=s.dot(this.geonormals[e][0]);Math.abs(t-1)<1e-9?i=[this.geonormals[e][1],this.geonormals[e][2]]:Math.abs(t+1)<1e-9&&(o=[this.geonormals[e][1],this.geonormals[e][2]])}if(null===i||null===o)throw new Error("Saw positive or negative sides as null");n.push([i[0],i[1],o[0],o[1],1+e[t].length])}this.movesetgeos=n;const r={},h={},l={},a=[],c=[],f=this.faces;for(let e=0;e<f.length;e++){const t=f[e],s=this.keyface(t);if(r[s]||(l[s]=c.length,a.push(s),r[s]=[],h[s]=[],c.push(r[s])),h[s].push(e),r[s].push(t),h[s].length===this.basefacecount){this.verbose&&console.log("# Splitting core.");for(let e=0;e<this.basefacecount;e++){const t=s+" "+e;h[t]=[h[s][e]],r[t]=[r[s][e]],a.push(t),l[t]=c.length,c.push(r[t])}r[s]=[],c[l[s]]=[]}}this.cubiekey=l,this.facelisthash=h,this.cubiekeys=a,this.verbose&&console.log("# Cubies: "+Object.keys(r).length);const u=this;function m(e){const t=u.stickersperface;return Math.floor(e/t)}this.cubies=c;for(let e=0;e<c.length;e++){const t=c[e];if(t.length<2)continue;if(t.length===this.basefacecount)continue;if(t.length>5)throw new Error("Bad math; too many faces on this cubie "+t.length);const o=h[this.keyface(t[0])],i=t.map(e=>s(e)),n=s(i);for(let e=0;t.length>2;e++){let s=!1;for(let e=0;e<t.length;e++){const r=(e+1)%t.length;if(n.dot(i[e].cross(i[r]))<0){const n=t[e];t[e]=t[r],t[r]=n;const h=i[e];i[e]=i[r],i[r]=h;const l=o[e];o[e]=o[r],o[r]=l,s=!0}}if(!s)break;if(e>1e3)throw new Error("Bad epsilon math; too close to border")}let r=0,l=this.findface(t[r]);for(let e=1;e<t.length;e++){const s=this.findface(t[e]);this.faceprecedence[m(s)]<this.faceprecedence[m(l)]&&(r=e,l=s)}if(0!==r){const e=t.slice(),s=o.slice();for(let i=0;i<t.length;i++)t[i]=e[(r+i)%t.length],o[i]=s[(r+i)%t.length]}}const p=[];for(let e=0;e<c.length;e++){const t=h[a[e]];for(let s=0;s<t.length;s++)p[t[s]]=[e,s]}this.facetocubies=p;const g=["?","CENTER","EDGE","CORNER","C4RNER","C5RNER"],d=[],b=[0,0,0,0,0,0],v=[],w=[];let x=0;const k=[],y=[],z=[],M=[];const E=[];for(let e=0;e<c.length;e++){if(w[e])continue;const t=c[e];if(0===t.length)continue;const s={};let i=0;z.push(0),E.push([]);const n=t.length,r=b[n]++;let h=g[n];void 0!==h&&n!==this.basefacecount||(h="CORE"),h+=0===r?"":r+1,d[x]=h,v[x]=n;const l=[e];let a=0;for(w[e]=!0;a<l.length;){const e=l[a++],n=c[e].map(e=>m(u.findface(e))).join(" ");(t.length>1||void 0===s[n])&&(s[n]=i++),M[e]=s[n],k[e]=x,E[x].push(e),y[e]=z[x]++;for(let t=0;t<o.length;t++){const s=this.findcubie(o[t][0].rotateface(c[e][0]));w[s]||(l.push(s),w[s]=!0)}}x++}if(this.orbits=z.length,this.cubiesetnums=k,this.cubieordnums=y,this.cubiesetnames=d,this.cubieords=z,this.orbitoris=v,this.cubievaluemap=M,this.cubiesetcubies=E,""!==this.fixPiece){for(let e=0;e<c.length;e++)if("v"===this.fixPiece&&c[e].length>2||"e"===this.fixPiece&&2===c[e].length||"f"===this.fixPiece&&1===c[e].length){this.fixedCubie=e;break}if(this.fixedCubie<0)throw new Error("Could not find a cubie of type "+this.fixPiece+" to fix.")}this.verbose&&console.log("# Cubie orbit sizes "+z)}spinmatch(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;try{const s=u(e,this.facenames),o=u(t,this.facenames);if(s.length!==o.length)return!1;for(let e=0;e<s.length;e++)if(s[e]===o[0]){for(let t=0;t<o.length;t++)if(s[(e+t)%s.length]!==o[t])return!1;return!0}return!1}catch(e){return!1}}parsemove(e){const t=RegExp("^(([0-9]+)-)?([0-9]+)?([A-Za-z]+)([-'0-9]+)?$"),s=e.match(t);if(null===s)throw new Error("Bad move passed "+e);let o,i=s[4],n=!1;if(i.endsWith("v")&&i[0]<="Z"){if(void 0!==s[2]||void 0!==s[3])throw new Error("Cannot use a prefix with full cube rotations");i=i.slice(0,-1),n=!0}let r=-1;const h=i.toUpperCase();let l=!1;for(let e=0;e<this.movesetgeos.length;e++){const t=this.movesetgeos[e];this.spinmatch(t[0],h)&&(l=!0,o=t,r=e),this.spinmatch(t[2],h)&&(l=!1,o=t,r=e)}let a=1,c=1;if(h!==i&&(c=2),void 0===o)throw new Error("Bad grip in move "+e);if(void 0!==s[2]){if(void 0===s[3])throw new Error("Missing second number in range");a=parseInt(s[2],10)}if(void 0!==s[3]&&(void 0===s[2]?(c=parseInt(s[3],10),a=h===i?c:1):c=parseInt(s[3],10)),a--,c--,n&&(a=0,c=this.moveplanesets[r].length),a<0||a>this.moveplanesets[r].length||c<0||c>this.moveplanesets[r].length)throw new Error("Bad slice spec "+a+" "+c);let f="1",u=1;return void 0!==s[5]&&(f=s[5],"'"===f[0]&&(f="-"+f.substring(1)),"+"===f[0]?f=f.substring(1):"-"===f[0]&&"-"===f&&(f="-1"),u=parseInt(f,10)),[e,r,a,c,l,u]}genperms(){if(this.cmovesbyslice.length>0)return;const e=[],t=[];for(let s=0;s<this.moveplanesets.length;s++){const o=this.moveplanesets[s],i=[],n=[];for(let e=0;e<this.faces.length;e++){const t=this.faces[e];let s=0;for(let e=0;e<o.length;e++)o[e].faceside(t)<0&&s++;for(i.push(s);n.length<=s;)n.push(0);n[s]++}const r=[],h=[];for(let e=0;e<n.length;e++){const t=[],o=[],n=[];for(let r=0;r<this.faces.length;r++){if(i[r]!==e)continue;const h=[r],l=this.facetocubies[r].slice();let a=this.faces[r],c=r;for(;;){i[c]=-1;const t=this.moverotations[s][0].rotateface(a);if(c=this.findface(t),i[c]<0)break;if(i[c]!==e)throw new Error("Bad movement?");h.push(c);const o=this.facetocubies[c];l.push(o[0],o[1]),a=t}if(1===h.length&&this.orientCenters){for(let e=1;e<this.movesetorders[s];e++)h.push(h[0]),l.push(l[0],e),this.cubies[l[0]].push(this.cubies[l[0]][0]);this.duplicatedFaces[h[0]]=this.movesetorders[s],this.duplicatedCubies[l[0]]=this.movesetorders[s],this.orbitoris[this.cubiesetnums[l[0]]]=this.movesetorders[s]}h.length>1&&t.push(h),l.length>2&&!n[l[0]]&&o.push(l);for(let e=0;e<l.length;e+=2)n[l[e]]=!0}r.push(t),h.push(o)}e.push(r),t.push(h)}if(this.movesbyslice=e,this.cmovesbyslice=t,void 0!==this.movelist){const e=[];for(let t=0;t<this.movelist.length;t++)e.push(this.parsemove(this.movelist[t]));this.parsedmovelist=e}}getfaces(){return this.faces.map(e=>e.map(e=>[e.b,e.c,e.d]))}getboundarygeometry(){return{baseplanes:this.baseplanes,facenames:this.facenames,faceplanes:this.faceplanes,vertexnames:this.vertexnames,edgenames:this.edgenames,geonormals:this.geonormals}}getmovesets(e){const t=this.moveplanesets[e].length;if(t>30)throw new Error("Too many slices for getmovesets bitmasks");let s=[];if(void 0!==this.parsedmovelist)for(let o=0;o<this.parsedmovelist.length;o++){const i=this.parsedmovelist[o];i[1]===e&&(i[4]?s.push((2<<i[3])-(1<<i[2])):s.push((2<<t-i[2])-(1<<t-i[3])),s.push(i[5]))}else if(this.vertexmoves&&!this.allmoves){const o=this.movesetgeos[e];if(o[1]!==o[3])for(let e=0;e<t;e++)"v"!==o[1]?(this.outerblockmoves?s.push((2<<t)-(2<<e)):s.push(2<<e),s.push(1)):(this.outerblockmoves?s.push((2<<e)-1):s.push(1<<e),s.push(1))}else for(let e=0;e<=t;e++)(this.allmoves||e+e!==t)&&(this.outerblockmoves?e+e>t?s.push((2<<t)-(1<<e)):s.push((2<<e)-1):s.push(1<<e),s.push(1));if(this.fixedCubie>=0){const o=1<<+this.cubiekeys[this.fixedCubie].trim().split(" ")[e],i=[];for(let e=0;e<s.length;e+=2){let n=s[e];n&o&&(n=(2<<t)-1-n);let r=!1;for(let t=0;t<i.length;t+=2)if(i[t]===n&&i[t+1]===s[e+1]){r=!0;break}r||(i.push(n),i.push(s[e+1]))}s=i}return this.addrotations&&(s.push((2<<t)-1),s.push(1)),s}graybyori(e){let t=this.cubies[e].length;return this.duplicatedCubies[e]&&(t=1),1===t&&(this.graycenters||!this.centersets)||2===t&&(this.grayedges||!this.edgesets)||t>2&&(this.graycorners||!this.cornersets)}skipbyori(e){let t=this.cubies[e].length;return this.duplicatedCubies[e]&&(t=1),1===t&&!this.centersets||2===t&&!this.edgesets||t>2&&!this.cornersets}skipcubie(e){if(0===e.length)return!0;const t=e[0];return this.skipbyori(t)}skipset(e){if(0===e.length)return!0;const t=e[0];return this.skipbyori(this.facetocubies[t][0])}header(e){return e+"PuzzleGeometry 0.1 Copyright 2018 Tomas Rokicki.\n"+e+this.args+"\n"}writegap(){const e=this.getOrbitsDef(!1),t=[],s=[];for(let o=0;o<e.moveops.length;o++){const i="M_"+e.movenames[o];s.push(i),t.push(i+":="+e.moveops[o].toPerm().toGap()+";")}t.push("Gen:=["),t.push(s.join(",")),t.push("];");const o=e.solved.identicalPieces();return t.push("ip:=["+o.map(e=>"["+e.map(e=>e+1).join(",")+"]").join(",")+"];"),t.push(""),this.header("# ")+t.join("\n")}writeksolve(e="PuzzleGeometryPuzzle",t=!1){const s=this.getOrbitsDef(t);return t?s.toKsolve(e,t).join("\n"):this.header("# ")+s.toKsolve(e,t).join("\n")}writekpuzzle(){return this.getOrbitsDef(!0).toKpuzzle()}getOrbitsDef(e){const t=[],s=[],o=[];for(let e=0;e<this.moveplanesets.length;e++){const s=this.getmovesets(e);for(let e=0;e<s.length;e+=2)for(let t=0;t<e;t+=2)if(s[e]===s[t]&&s[e+1]===s[t+1])throw new Error("Redundant moves in moveset.");let o=0;for(let e=0;e<s.length;e+=2)o|=s[e];const i=this.cmovesbyslice[e];for(let e=0;e<i.length;e++){if(0==(o>>e&1))continue;const s=i[e];for(let e=0;e<s.length;e++){if(this.skipcubie(s[e]))continue;t[this.cubiesetnums[s[e][0]]]=1}}}for(let e=0;e<this.cubiesetnames.length;e++)t[e]&&(s.push(this.cubiesetnames[e]),o.push(new OrbitDef(this.cubieords[e],this.killorientation?1:this.orbitoris[e])));const i=[];for(let s=0;s<this.cubiesetnames.length;s++){if(!t[s])continue;const o=[],n=[];for(let t=0;t<this.cubieords[s];t++){if(e)o.push(t);else{const e=this.cubiesetcubies[s][t];o.push(this.cubievaluemap[e])}n.push(0)}i.push(new Orbit(o,n,this.killorientation?1:this.orbitoris[s]))}const n=[],r=[];for(let e=0;e<this.moveplanesets.length;e++){const s=this.moveplanesets[e].length,o=this.getmovesets(e),i=this.movesetgeos[e];for(let h=0;h<o.length;h+=2){const l=o[h],a=f(i,l,s),c=a[0],u=a[1];n.push(c);const m=[],p=[],g=[];for(let e=0;e<this.cubiesetnames.length;e++){const t=[];for(let s=0;s<this.cubieords[e];s++)t.push(s);p.push(t);const s=[];for(let t=0;t<this.cubieords[e];t++)s.push(0);g.push(s)}const d=this.cmovesbyslice[e];for(let e=0;e<d.length;e++){if(0==(l>>e&1))continue;const t=d[e];for(let e=0;e<t.length;e++){const s=t[e].slice(),o=this.cubiesetnums[s[0]];for(let e=0;e<s.length;e+=2)s[e]=this.cubieordnums[s[e]];let i=2,n=3;u&&(i=s.length-2,n=s.length-1);for(let e=0;e<s.length;e+=2)p[o][s[(e+i)%s.length]]=s[e],this.killorientation?g[o][s[e]]=0:g[o][s[e]]=(s[(e+n)%s.length]-s[(e+1)%s.length]+this.orbitoris[o])%this.orbitoris[o]}}for(let e=0;e<this.cubiesetnames.length;e++){if(!t[e])continue;const s=new Array(g[e].length);for(let t=0;t<p[e].length;t++)s[t]=g[e][p[e][t]];m.push(new Orbit(p[e],s,this.killorientation?1:this.orbitoris[e]))}let b=new Transformation(m);1!==o[h+1]&&(b=b.mulScalar(o[h+1])),r.push(b)}}this.ksolvemovenames=n;let h=new OrbitsDef(s,o,new VisibleState(i),n,r);return this.optimize&&(h=h.optimize()),0!==this.scramble&&h.scramble(this.scramble),h}getMovesAsPerms(){return this.getOrbitsDef(!1).moveops.map(e=>e.toPerm())}showcanon(e){!function(e,t){const s=e.moveops.length;if(s>30)throw new Error("Canon info too big for bitmask");const o=[],i=[];for(let t=0;t<s;t++){const n=e.moveops[t];o.push(n.order());let r=0;for(let o=0;o<s;o++){if(o===t)continue;const s=e.moveops[o];n.mul(s).equal(s.mul(n))&&(r|=1<<o)}i.push(r)}let n={0:1};for(let e=0;e<100;e++){let s=0;const r={};let h=0;for(const e in n){const t=+e,l=n[t];s+=l,h++;for(let e=0;e<o.length;e++)if(0==(t>>e&1)&&0==(t&i[e]&(1<<e)-1)){const s=t&i[e]|1<<e;void 0===r[s]&&(r[s]=0),r[s]+=(o[e]-1)*l}}t(e+": canonseq "+s+" states "+h),n=r}}(this.getOrbitsDef(!1),e)}getsolved(){const e=[];for(let t=0;t<this.basefacecount;t++)for(let s=0;s<this.stickersperface;s++)e.push(t);return new Perm(e)}getInitial3DRotation(){const e=this.basefacecount;if(4===e)return new Quat(.7043069543230507,.0617237605829268,.4546068756768417,.5417328493446099);if(6===e)return new Quat(.3419476009844782,.17612448544695208,-.42284908551877964,.8205185279339757);if(8===e)return new Quat(-.6523285484575103,.2707374015470506,.6537994145576647,.27150515611112014);if(12===e)return new Quat(-.5856747836703331,.02634133605619232,.7075560342412421,.39453217891103587);if(20===e)return new Quat(.7052782621769977,.6377976252204238,.30390357803973855,.05864620549043545);throw new Error("Wrong base face count")}generatesvg(e=800,t=500,s=10,o=!1){function i(e,t){let s=e[1][0]-e[0][0],o=e[1][1]-e[0][1];const i=2*Math.PI/t,n=Math.cos(i),r=Math.sin(i);for(let i=2;i<t;i++){const t=s*n+o*r;o=o*n-s*r,s=t,e.push([e[i-1][0]+s,e[i-1][1]+o])}}function n(e){return e+0*(Math.random()-.5)}function r(e,t,s){return'<polygon id="'+e+'" class="sticker" style="fill: '+s+'" points="'+t.map(e=>n(e[0])+" "+n(e[1])).join(" ")+'"/>\n'}e-=2*s,t-=2*s;let h=this.addrotations,l=this.addrotations,a=this.addrotations;for(let e=0;e<this.movesetgeos.length;e++){const t=this.movesetgeos[e];for(let e=1;e<=3;e+=2)"v"===t[e]&&(h=!0),"f"===t[e]&&(a=!0),"e"===t[e]&&(l=!0)}this.genperms();const f=this.getboundarygeometry().facenames[0][0].length,m=this.net;if(null===m)throw new Error("No net?");const p={};let g=0,d=0,b=1,v=0;p[m[0][0]]=[[1,0],[0,0]],i(p[m[0][0]],f);for(let e=0;e<m.length;e++){const t=m[e][0];if(!p[t])throw new Error("Bad edge description; first edge not connected.");for(let s=1;s<m[e].length;s++){const o=m[e][s];""===o||p[o]||(p[o]=[p[t][s%f],p[t][(s+f-1)%f]],i(p[o],f))}}for(const e in p){const t=p[e];for(let e=0;e<t.length;e++)g=Math.min(g,t[e][0]),b=Math.max(b,t[e][0]),d=Math.min(d,t[e][1]),v=Math.max(v,t[e][1])}const w=Math.min(e/(b-g),t/(v-d)),x=.5*(e-w*(b+g)),k=.5*(t-w*(v+d)),y={},z=this.getboundarygeometry(),M={},E=[[w+x,k],[x,k]];M[m[0][0]]=E,i(M[m[0][0]],f),y[this.facenames[0][1]]=this.project2d(0,0,[new Quat(0,E[0][0],E[0][1],0),new Quat(0,E[1][0],E[1][1],0)]);const B=[];B[0]=0;for(let e=0;e<m.length;e++){const t=m[e][0];if(!M[t])throw new Error("Bad edge description; first edge not connected.");let s=-1;for(let e=0;e<z.facenames.length;e++)if(t===z.facenames[e][1]){s=e;break}if(s<0)throw new Error("Could not find first face name "+t);const o=z.facenames[s][0];for(let n=1;n<m[e].length;n++){const r=m[e][n];if(""===r||M[r])continue;M[r]=[M[t][n%f],M[t][(n+f-1)%f]],i(M[r],f);const h=B[s],l=o[(h+n)%f].sum(o[(h+n+f-1)%f]).smul(.5),a=c(z.edgenames,l),p=u(z.edgenames[a][1],this.facenames),g=p[t===p[0]?1:0];let d=-1;for(let e=0;e<z.facenames.length;e++)if(g===z.facenames[e][1]){d=e;break}if(d<0)throw new Error("Could not find second face name");const b=z.facenames[d][0];for(let e=0;e<b.length;e++){if(b[e].sum(b[(e+1)%f]).smul(.5).dist(l)<=1e-9){const s=M[t][(n+f-1)%f],o=M[t][n%f];B[d]=e,y[g]=this.project2d(d,e,[new Quat(0,o[0],o[1],0),new Quat(0,s[0],s[1],0)]);break}}}}const F=this.getsolved(),P=[],D=[];for(let e=0;e<this.basefacecount;e++)P[e]=this.colors[this.facenames[e][1]];let O=0,C=0;const Q=this.getInitial3DRotation();for(let e=0;e<this.faces.length;e++){let t=this.faces[e];t=Q.rotateface(t);for(let e=0;e<t.length;e++)O=Math.max(O,Math.abs(t[e].b)),C=Math.max(C,Math.abs(t[e].c))}const R=Math.min(t/C/2,(e-s)/O/4),j=this;function S(i,n){if(o){const o=.5*s+.25*e,r=j.baseplanes[i].rotateplane(Q).d<0?1:-1;return[s+.5*e+r*(o-n.b*R),s+.5*t+n.c*R]}{const e=y[j.facenames[i][1]];return[s+n.dot(e[0])+e[2].b,s+t-n.dot(e[1])-e[2].c]}}for(let e=0;e<this.faces.length;e++){let t=j.faces[e];const s=Math.floor(e/j.stickersperface);o&&(t=Q.rotateface(t)),D.push(t.map(e=>S(s,e)))}const A=[];for(let e=0;e<this.basefacecount;e++){A.push("<g>"),A.push("<title>"+this.facenames[e][1]+"</title>\n");for(let t=0;t<this.stickersperface;t++){const s=e*this.stickersperface+t,o=this.facetocubies[s][0],i=this.facetocubies[s][1],n=this.cubiesetnums[o],h=this.cubieordnums[o],l=this.graybyori(o)?"#808080":P[F.p[s]];let a=this.cubiesetnames[n]+"-l"+h+"-o"+i;if(A.push(r(a,D[s],l)),this.duplicatedFaces[s])for(let e=1;e<this.duplicatedFaces[s];e++)a=this.cubiesetnames[n]+"-l"+h+"-o"+e,A.push(r(a,D[s],l))}A.push("</g>")}const T=[];function I(e,t,s,o){const i=S(e,s);for(let e=0;e<T.length;e++)if(Math.hypot(i[0]-T[e][0],i[1]-T[e][1])<1e-9)return;T.push([i[0],i[1],t,o])}for(let e=0;e<this.faceplanes.length;e++){const t=this.facenames[e][0];let s=t;if(o&&(s=Q.rotateface(s)),a){let t=this.faceplanes[e][0];o&&(t=t.rotatepoint(Q)),I(e,this.faceplanes[e][1],t,f)}for(let o=0;o<t.length;o++){if(l){const i=t[o].sum(t[(o+1)%t.length]).smul(.5),n=c(this.edgenames,i),r=s[o].sum(s[(o+1)%t.length]).smul(.5);I(e,this.edgenames[n][1],r,2)}if(h){const i=c(this.vertexnames,t[o]);I(e,this.vertexnames[i][1],s[o],this.cornerfaces)}}}const U='<svg id="svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 800 500">\n<style type="text/css"><![CDATA[.sticker { stroke: #000000; stroke-width: 1px; }]]></style>\n'+A.join("")+"</svg>";return this.svggrips=T,U}get3d(e){const t=[],s=this.getInitial3DRotation(),o=[],i=.52*this.basefaces[0][0].len();for(let e=0;e<this.basefaces.length;e++){const t=s.rotateface(this.basefaces[e]),n=this.facenames[e][1];o.push({coords:p(t,i),name:n})}for(let o=0;o<this.faces.length;o++){const n=Math.floor(o/this.stickersperface),r=this.facetocubies[o][0],h=this.facetocubies[o][1],l=this.cubiesetnums[r],a=this.cubieordnums[r],c=this.graybyori(r)?"#808080":this.colors[this.facenames[n][1]];let f=s.rotateface(this.faces[o]);if(e&&e>0&&(f=g(f,e)),t.push({coords:p(f,i),color:c,orbit:this.cubiesetnames[l],ord:a,ori:h}),this.duplicatedFaces[o])for(let e=1;e<this.duplicatedFaces[o];e++)t.push({coords:p(f,i),color:c,orbit:this.cubiesetnames[l],ord:a,ori:e})}const n=[];for(let e=0;e<this.movesetgeos.length;e++){const t=this.movesetgeos[e],o=this.movesetorders[e];for(let e=0;e<this.geonormals.length;e++){const i=this.geonormals[e];t[0]===i[1]&&t[1]===i[2]&&(n.push([m(i[0].rotatepoint(s),1),t[0],o]),n.push([m(i[0].rotatepoint(s).smul(-1),1),t[2],o]))}}return{stickers:t,faces:o,axis:n}}}class FactoredNumber{constructor(){this.mult=[]}multiply(e){for(let t=2;t*t<=e;t++)for(;e%t==0;)void 0!==this.mult[t]?this.mult[t]++:this.mult[t]=1,e/=t;e>1&&(void 0!==this.mult[e]?this.mult[e]++:this.mult[e]=1)}toString(){let e="";for(let t=0;t<this.mult.length;t++)void 0!==this.mult[t]&&(""!==e&&(e+="*"),e+=t,this.mult[t]>1&&(e+="^"+this.mult[t]));return e}}let d=!1,b=!1,v=!1,w=!1,x=!1,k=!1;if("undefined"!=typeof process&&process.argv&&process.argv.length<=2&&console.log("Usage:  puzzle-geometry [options] [puzzle]\n\nOptions:\n--ksolve: write ksolve (tws) file\n--svg: write SVG (default is flat; --3d makes it 3D)\n--gap: write gap\n--ss: execute Schrier-Sims calculation\n--3d: use 3D format for SVG file\n--canon: write canonical string analysis\n--rotations: include full-puzzle rotations as moves\n--allmoves: includes all moves (i.e., slice moves for 3x3x3)\n--outerblockmoves: use outer block moves rather than slice moves\n--vertexmoves: for tetrahedral puzzles, prefer vertex moves to face moves\n--nocorners: ignore all corners\n--noedges: ignore all edges\n--nocenters: ignore all centers\n--noorientation: ignore orientations\n--orientcenters: give centers an orientation\n--moves movenames: restrict moves to this list (e.g, U2,F,r)\n--optimize: optimize tws/ksolve/gap output\n--scramble: scramble solved position\n--fixcorner: choose moves to keep one corner fixed\n--fixedge: choose moves to keep one edge fixed\n--fixcenter: choose moves to keep one center fixed\n--verbose (-v): make verbose\n\nThe puzzle can be given as a geometric description or by name.\nThe geometric description starts with c (cube), t (tetrahedron),\nd (dodecahedron), i (icosahedron), or o (octahedron), then a\nspace, then a series of cuts.  Each cut begins with f (for a\ncut parallel to faces), v (for a cut perpendicular to a ray\nfrom the center through a corner), or e (for a cut perpendicular\nto a ray from the center through an edge) followed by a decimal\nnumber giving a distance, where 1 is the distance between the\ncenter of the puzzle and the center of a face.\n\nThe puzzle names recognized are 2x2x2 through 13x13x13, 20x20x20,\nmaster skewb, professor skewb, compy cube, helicopter, dino,\nlittle chop, pyramorphix, mastermorphix, pyraminx, Jing pyraminx,\nmaster paramorphix, megaminx, gigaminx, pentultimate, starminx,\nstarminx 2, pyraminx crystal, chopasaurus, big chop, skewb diamond,\nFTO, Christopher's jewel, octastar, Trajber's octahedron, radio chop,\nicosamate, icosahedron 2, icosahedron 3, icosahedron static faces,\nicosahedron moving faces, and Eitan's star.\n\nExamples:\n   puzzlegeometry --ss 2x2x2\n   puzzlegeometry --ss --fixcorner 2x2x2\n   puzzlegeometry --ss --moves U,F2,r 4x4x4\n   puzzlegeometry --ksolve --optimize --moves U,F,R megaminx\n   puzzlegeometry --gap kilominx\n"),"undefined"!=typeof process&&process.argv&&process.argv.length>=3){let t;const s=r;let o=2;const i=[];let n=!0;for(;o<process.argv.length&&"-"===process.argv[o][0];){const e=process.argv[o++];if("--verbose"===e||"-v"===e)i.push("verbose",!0);else if("--quiet"===e||"-q"===e)i.push("quiet",!0),n=!1;else if("--ksolve"===e)v=!0;else if("--svg"===e)n=!1,i.push("quiet",!0),d=!0;else if("--gap"===e)w=!0;else if("--ss"===e)b=!0;else if("--3d"===e)k=!0;else if("--canon"===e)x=!0;else if("--rotations"===e)i.push("rotations",!0);else if("--allmoves"===e)i.push("allmoves",!0);else if("--outerblockmoves"===e)i.push("outerblockmoves",!0);else if("--vertexmoves"===e)i.push("vertexmoves",!0);else if("--nocorners"===e)i.push("cornersets",!1);else if("--noedges"===e)i.push("edgesets",!1);else if("--noorientation"===e)i.push("killorientation",!0);else if("--nocenters"===e)i.push("centersets",!1);else if("--moves"===e)i.push("movelist",process.argv[o].split(",")),o++;else if("--optimize"===e)i.push("optimize",!0);else if("--scramble"===e)i.push("scramble",100);else if("--fixcorner"===e)i.push("fix","v");else if("--fixedge"===e)i.push("fix","e");else if("--fixcenter"===e)i.push("fix","f");else{if("--orientcenters"!==e)throw new Error("Bad option: "+e);i.push("orientcenters",!0)}}for(const[e,i]of Object.entries(s))if(e===process.argv[o]){t=i;break}let h=[];if(n&&console.log("# "+process.argv.join(" ")),void 0!==t)h=function(e){const t=e.split(/ /).filter(Boolean);if(t.length%2==0)return!1;if("o"!==t[0]&&"c"!==t[0]&&"i"!==t[0]&&"d"!==t[0]&&"t"!==t[0])return!1;const s=[];for(let e=1;e<t.length;e+=2){if("f"!==t[e]&&"v"!==t[e]&&"e"!==t[e])return!1;s.push([t[e],t[e+1]])}return[t[0],s]}(t),o++;else{const e=[],t=o++;for(;o+1<process.argv.length&&1===process.argv[o].length;)e.push([process.argv[o],process.argv[o+1]]),o+=2;h=[process.argv[t],e]}const l=new PuzzleGeometry(h[0],h[1],i);if(l.allstickers(),l.genperms(),o<process.argv.length)throw new Error("Unprocessed content at end of command line");if(w)console.log(l.writegap());else if(v)console.log(l.writeksolve());else if(d)console.log(l.generatesvg());else if(k)console.log(JSON.stringify(l.get3d()));else if(b){const t=l.getOrbitsDef(!1),s=t.reassemblySize();console.log("Reassembly size is "+s);const o=s/function(t,s){const o=t[0].p.length,i=function(t){return new Perm(e(t))}(o);let n=[],r=[],h=[],l=[],a=[];function c(e,t,s){l[e].push(t),a[e].push(s);for(let o=0;o<n[e].length;o++)n[e][o]&&f(e,n[e][o].mul(t),s+h[e][o])}function f(e,t,s){const o=t.p[e];if(!n[e][o]){n[e][o]=t,r[e][o]=t.inv(),h[e][o]=s;for(let o=0;o<l[e].length;o++)f(e,t.mul(l[e][o]),s+a[e][o]);return}const i=t.mul(r[e][o]);(function(e){for(let t=e.p.length-1;t>=0;t--){const s=e.p[t];if(s!==t){if(!n[t][s])return!1;e=e.mul(r[t][s])}}return!0})(i)||c(e-1,i,s+h[e][o])}return function(){n=[],r=[],l=[],h=[],a=[];for(let e=0;e<o;e++)n.push([]),r.push([]),h.push([]),l.push([]),a.push([]),n[e][e]=i,r[e][e]=i,h[e][e]=0;let e=0,f=1;for(let i=0;i<t.length;i++){c(o-1,t[i],1),f=1;let r=0,a=0;const u=new FactoredNumber;for(let t=0;t<o;t++){let s=0,i=0;for(let r=0;r<o;r++)n[t][r]&&(s++,i+=h[t][r],t!==r&&e++);r+=l[t].length,f*=s,s>1&&u.multiply(s),a+=i/s}s(i+": sz "+f+" T "+r+" sol "+a+" none "+e+" mults "+u)}return f}()}(t.moveops.map(e=>e.toPerm()),e=>console.log(e));console.log("Ratio is "+o)}else x&&l.showcanon(e=>console.log(e))}
//# sourceMappingURL=puzzle-geometry-bin.js.map
