{"version":3,"file":"puzzle-geometry-bin.js","sources":["../../src/puzzle-geometry/Perm.ts","../../src/puzzle-geometry/PermOriSet.ts","../../src/puzzle-geometry/Quat.ts","../../src/puzzle-geometry/PlatonicGenerator.ts","../../src/puzzle-geometry/Puzzles.ts","../../src/puzzle-geometry/PuzzleGeometry.ts","../../src/puzzle-geometry/SchreierSims.ts","../../src/puzzle-geometry/bin/puzzle-geometry-bin.ts"],"sourcesContent":["export function zeros(n: number): number[] {\n  const c = Array(n);\n  for (let i = 0; i < n; i++) {\n    c[i] = 0;\n  }\n  return c;\n}\n\nexport function iota(n: number): number[] {\n  const c = Array(n);\n  for (let i = 0; i < n; i++) {\n    c[i] = i;\n  }\n  return c;\n}\n\nexport function identity(n: number): Perm {\n  return new Perm(iota(n));\n}\n\nexport function random(n: number): Perm { // random\n  const c = Array(n);\n  for (let i = 0; i < n; i++) {\n    c[i] = i;\n  }\n  for (let i = 0; i < n; i++) {\n    const j = i + Math.floor((n - i) * Math.random());\n    const t = c[i];\n    c[i] = c[j];\n    c[j] = t;\n  }\n  return new Perm(c);\n}\n\nexport function factorial(a: number): number {\n  let r = 1;\n  while (a > 1) {\n    r *= a;\n    a--;\n  }\n  return r;\n}\n\nfunction gcd(a: number, b: number): number {\n  if (a > b) {\n    const t = a;\n    a = b;\n    b = t;\n  }\n  while (a > 0) {\n    const m = b % a;\n    b = a;\n    a = m;\n  }\n  return b;\n}\n\nexport function lcm(a: number, b: number): number {\n  return a / gcd(a, b) * b;\n}\n\nexport class Perm {\n  public n: number;        // length\n  public p: number[]; // The permutation itself\n  constructor(a: number[]) {\n    this.n = a.length;\n    this.p = a;\n  }\n  public toString(): string { // stringify\n    return \"Perm[\" + this.p.join(\" \") + \"]\";\n  }\n  public mul(p2: Perm): Perm { // multiply\n    const c: number[] = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[i] = p2.p[this.p[i]];\n    }\n    return new Perm(c);\n  }\n  public rmul(p2: Perm): Perm { // multiply the other way\n    const c = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[i] = this.p[p2.p[i]];\n    }\n    return new Perm(c);\n  }\n  public inv(): Perm {\n    const c = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[this.p[i]] = i;\n    }\n    return new Perm(c);\n  }\n  public compareTo(p2: Perm): number { // comparison\n    for (let i = 0; i < this.n; i++) {\n      if (this.p[i] !== p2.p[i]) {\n        return this.p[i] - p2.p[i];\n      }\n    }\n    return 0;\n  }\n  public toGap(): string {\n    const cyc = new Array<string>();\n    const seen = new Array<boolean>(this.n);\n    for (let i = 0; i < this.p.length; i++) {\n      if (seen[i] || this.p[i] === i) {\n        continue;\n      }\n      const incyc = new Array<number>();\n      for (let j = i; !seen[j]; j = this.p[j]) {\n        incyc.push(1 + j);\n        seen[j] = true;\n      }\n      cyc.push(\"(\" + incyc.join(\",\") + \")\");\n    }\n    return cyc.join(\"\");\n  }\n  public order(): number {\n    let r = 1;\n    const seen = new Array<boolean>(this.n);\n    for (let i = 0; i < this.p.length; i++) {\n      if (seen[i] || this.p[i] === i) {\n        continue;\n      }\n      let cs = 0;\n      for (let j = i; !seen[j]; j = this.p[j]) {\n        cs++;\n        seen[j] = true;\n      }\n      r = lcm(r, cs);\n    }\n    return r;\n  }\n}\n","/* tslint:disable no-bitwise */\n/* tslint:disable prefer-for-of */ // TODO\n\nimport { factorial, iota, lcm, Perm, zeros } from \"./Perm\";\nexport class OrbitDef {\n  constructor(public size: number, public mod: number) { }\n  public reassemblySize(): number {\n    return factorial(this.size) * Math.pow(this.mod, this.size);\n  }\n}\nexport class OrbitsDef {\n  constructor(\n    public orbitnames: string[],\n    public orbitdefs: OrbitDef[],\n    public solved: VisibleState,\n    public movenames: string[],\n    public moveops: Transformation[]) { }\n  public toKsolve(name: string, forTwisty: boolean): string[] {\n    const result = [];\n    result.push(\"Name \" + name);\n    result.push(\"\");\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      result.push(\"Set \" + this.orbitnames[i] + \" \" +\n        this.orbitdefs[i].size + \" \" + this.orbitdefs[i].mod);\n    }\n    result.push(\"\");\n    result.push(\"Solved\");\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      result.push(this.orbitnames[i]);\n      const o = this.solved.orbits[i].toKsolveVS();\n      result.push(o[0]);\n      result.push(o[1]);\n    }\n    result.push(\"End\");\n    result.push(\"\");\n    for (let i = 0; i < this.movenames.length; i++) {\n      result.push(\"Move \" + this.movenames[i]);\n      for (let j = 0; j < this.orbitnames.length; j++) {\n        if (!forTwisty && this.moveops[i].orbits[j].isIdentity()) {\n          continue;\n        }\n        result.push(this.orbitnames[j]);\n        const o = this.moveops[i].orbits[j].toKsolve();\n        result.push(o[0]);\n        result.push(o[1]);\n      }\n      result.push(\"End\");\n      result.push(\"\");\n    }\n    // extra blank line on end lets us use join(\"\\n\") to terminate all\n    return result;\n  }\n  public toKpuzzle(): object {\n    const orbits: { [orbitName: string]: any } = {} ;\n    const start: { [orbitName: string]: any } = {} ;\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      orbits[this.orbitnames[i]] = { numPieces: this.orbitdefs[i].size,\n                        orientations: this.orbitdefs[i].mod } ;\n      start[this.orbitnames[i]] = this.solved.orbits[i].toKpuzzle() ;\n    }\n    const moves: { [moveName: string]: any } = {} ;\n    for (let i = 0; i < this.movenames.length; i++) {\n      const mp: { [orbitName: string]: any } = {} ;\n      for (let j = 0; j < this.orbitnames.length; j++) {\n        mp[this.orbitnames[j]] = this.moveops[i].orbits[j].toKpuzzle() ;\n      }\n      moves[this.movenames[i]] = mp ;\n    }\n    return { orbits, startPieces: start, moves } ;\n  }\n  public optimize(): OrbitsDef {\n    const neworbitnames: string[] = [];\n    const neworbitdefs: OrbitDef[] = [];\n    const newsolved: Orbit[] = [];\n    const newmoveops: Orbit[][] = [];\n    for (let j = 0; j < this.moveops.length; j++) {\n      newmoveops.push([]);\n    }\n    for (let i = 0; i < this.orbitdefs.length; i++) {\n      const om = this.orbitdefs[i].mod;\n      const n = this.orbitdefs[i].size;\n      const du = new DisjointUnion(n);\n      const changed = new Array<boolean>(this.orbitdefs[i].size);\n      for (let k = 0; k < n; k++) {\n        changed[k] = false;\n      }\n      for (let j = 0; j < this.moveops.length; j++) {\n        for (let k = 0; k < n; k++) {\n          if (this.moveops[j].orbits[i].perm[k] !== k ||\n            this.moveops[j].orbits[i].ori[k] !== 0) {\n            changed[k] = true;\n            du.union(k, this.moveops[j].orbits[i].perm[k]);\n          }\n        }\n      }\n      let keepori = true;\n      // right now we kill ori only if solved is unique and\n      // if we can kill it completely.  This is not all the optimization\n      // we can perform.\n      if (om > 1) {\n        keepori = false;\n        const duo = new DisjointUnion(this.orbitdefs[i].size * om);\n        for (let j = 0; j < this.moveops.length; j++) {\n          for (let k = 0; k < n; k++) {\n            if (this.moveops[j].orbits[i].perm[k] !== k ||\n              this.moveops[j].orbits[i].ori[k] !== 0) {\n              for (let o = 0; o < om; o++) {\n                duo.union(k * om + o, this.moveops[j].orbits[i].perm[k] * om +\n                  (o + this.moveops[j].orbits[i].ori[k]) % om);\n              }\n            }\n          }\n        }\n        for (let j = 0; !keepori && j < n; j++) {\n          for (let o = 1; o < om; o++) {\n            if (duo.find(j * om) === duo.find(j * om + o)) {\n              keepori = true;\n            }\n          }\n        }\n        for (let j = 0; !keepori && j < n; j++) {\n          for (let k = 0; k < j; k++) {\n            if (this.solved.orbits[i].perm[j] ===\n              this.solved.orbits[i].perm[k]) {\n              keepori = true;\n            }\n          }\n        }\n      }\n      // is there just one result set, or more than one?\n      let nontriv = -1;\n      let multiple = false;\n      for (let j = 0; j < this.orbitdefs[i].size; j++) {\n        if (changed[j]) {\n          const h = du.find(j);\n          if (nontriv < 0) {\n            nontriv = h;\n          } else if (nontriv !== h) {\n            multiple = true;\n          }\n        }\n      }\n      for (let j = 0; j < this.orbitdefs[i].size; j++) {\n        if (!changed[j]) {\n          continue;\n        }\n        const h = du.find(j);\n        if (h !== j) {\n          continue;\n        }\n        const no: number[] = [];\n        const on: number[] = [];\n        let nv = 0;\n        for (let k = 0; k < this.orbitdefs[i].size; k++) {\n          if (du.find(k) === j) {\n            no[nv] = k;\n            on[k] = nv;\n            nv++;\n          }\n        }\n        if (multiple) {\n          neworbitnames.push(this.orbitnames[i] + \"_p\" + j);\n        } else {\n          neworbitnames.push(this.orbitnames[i]);\n        }\n        if (keepori) {\n          neworbitdefs.push(new OrbitDef(nv, this.orbitdefs[i].mod));\n          newsolved.push(this.solved.orbits[i].remapVS(no, nv));\n          for (let k = 0; k < this.moveops.length; k++) {\n            newmoveops[k].push(this.moveops[k].orbits[i].remap(no, on, nv));\n          }\n        } else {\n          neworbitdefs.push(new OrbitDef(nv, 1));\n          newsolved.push(this.solved.orbits[i].remapVS(no, nv).killOri());\n          for (let k = 0; k < this.moveops.length; k++) {\n            newmoveops[k].push(this.moveops[k].orbits[i].\n              remap(no, on, nv).killOri());\n          }\n        }\n      }\n    }\n    return new OrbitsDef(neworbitnames, neworbitdefs,\n      new VisibleState(newsolved), this.movenames,\n      newmoveops.map((_) => new Transformation(_)));\n  }\n  // generate a new \"solved\" position based on scrambling\n  // we use an algorithm that should be faster for large puzzles than\n  // just picking random moves.\n  public scramble(n: number): void {\n    const pool: Transformation[] = [];\n    for (let i = 0; i < this.moveops.length; i++) {\n      pool[i] = this.moveops[i];\n    }\n    for (let i = 0; i < pool.length; i++) {\n      const j = Math.floor(Math.random() * pool.length);\n      const t = pool[i];\n      pool[i] = pool[j];\n      pool[j] = t;\n    }\n    if (n < pool.length) {\n      n = pool.length;\n    }\n    for (let i = 0; i < n; i++) {\n      const ri = Math.floor(Math.random() * pool.length);\n      const rj = Math.floor(Math.random() * pool.length);\n      const rm = Math.floor(Math.random() * this.moveops.length);\n      pool[ri] = pool[ri].mul(pool[rj]).mul(this.moveops[rm]);\n      if (Math.random() < 0.1) { // break up parity\n        pool[ri] = pool[ri].mul(this.moveops[rm]);\n      }\n    }\n    let s = pool[0];\n    for (let i = 1; i < pool.length; i++) {\n      s = s.mul(pool[i]);\n    }\n    this.solved = this.solved.mul(s);\n  }\n  public reassemblySize(): number {\n    let n = 1;\n    for (let i = 0; i < this.orbitdefs.length; i++) {\n      n *= this.orbitdefs[i].reassemblySize();\n    }\n    return n;\n  }\n}\nexport class Orbit {\n  public static e(n: number, mod: number): Orbit {\n    return new Orbit(iota(n), zeros(n), mod);\n  }\n  constructor(\n    public perm: number[],\n    public ori: number[],\n    public orimod: number) { }\n  public mul(b: Orbit): Orbit {\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n);\n    const newOri = new Array<number>(n);\n    for (let i = 0; i < n; i++) {\n      newPerm[i] = this.perm[b.perm[i]];\n      newOri[i] = (this.ori[b.perm[i]] + b.ori[i]) % this.orimod;\n    }\n    return new Orbit(newPerm, newOri, this.orimod);\n  }\n  public inv(): Orbit {\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n);\n    const newOri = new Array<number>(n);\n    for (let i = 0; i < n; i++) {\n      newPerm[this.perm[i]] = i;\n      newOri[this.perm[i]] = (this.orimod - this.ori[i]) % this.orimod;\n    }\n    return new Orbit(newPerm, newOri, this.orimod);\n  }\n  public equal(b: Orbit): boolean {\n    const n = this.perm.length;\n    for (let i = 0; i < n; i++) {\n      if (this.perm[i] !== b.perm[i] || this.ori[i] !== b.ori[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  // in-place mutator\n  public killOri(): this {\n    const n = this.perm.length;\n    for (let i = 0; i < n; i++) {\n      this.ori[i] = 0;\n    }\n    this.orimod = 1;\n    return this;\n  }\n  public toPerm(): Perm {\n    const o = this.orimod;\n    if (o === 1) {\n      return new Perm(this.perm);\n    }\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n * o);\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < o; j++) {\n        newPerm[i * o + j] = o * this.perm[i] + (this.ori[i] + j) % o;\n      }\n    }\n    return new Perm(newPerm);\n  }\n  // returns tuple of sets of identical pieces in this orbit\n  public identicalPieces(): number[][] {\n    const done: boolean[] = [];\n    const n = this.perm.length;\n    const r: number[][] = [];\n    for (let i = 0; i < n; i++) {\n      const v = this.perm[i];\n      if (done[v] === undefined) {\n        const s: number[] = [i];\n        done[v] = true;\n        for (let j = i + 1; j < n; j++) {\n          if (this.perm[j] === v) {\n            s.push(j);\n          }\n        }\n        r.push(s);\n      }\n    }\n    return r;\n  }\n  public order(): number { // can be made more efficient\n    return this.toPerm().order();\n  }\n  public isIdentity(): boolean {\n    const n = this.perm.length;\n    for (let i = 0; i < n; i++) {\n      if (this.perm[i] !== i || this.ori[i] !== 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n  public remap(no: number[], on: number[], nv: number): Orbit {\n    const newPerm = new Array<number>(nv);\n    const newOri = new Array<number>(nv);\n    for (let i = 0; i < nv; i++) {\n      newPerm[i] = on[this.perm[no[i]]];\n      newOri[i] = this.ori[no[i]];\n    }\n    return new Orbit(newPerm, newOri, this.orimod);\n  }\n  public remapVS(no: number[], nv: number): Orbit {\n    const newPerm = new Array<number>(nv);\n    const newOri = new Array<number>(nv);\n    let nextNew = 0;\n    const reassign = [];\n    for (let i = 0; i < nv; i++) {\n      const ov = this.perm[no[i]];\n      if (reassign[ov] === undefined) {\n        reassign[ov] = nextNew++;\n      }\n      newPerm[i] = reassign[ov];\n      newOri[i] = this.ori[no[i]];\n    }\n    return new Orbit(newPerm, newOri, this.orimod);\n  }\n  public toKsolveVS(): string[] {\n    return [this.perm.map((_: number) => _ + 1).join(\" \"), this.ori.join(\" \")];\n  }\n  public toKsolve(): string[] {\n    const newori = new Array<number>(this.ori.length);\n    for (let i = 0; i < newori.length; i++) {\n      newori[this.perm[i]] = this.ori[i];\n    }\n    return [this.perm.map((_: number) => _ + 1).join(\" \"), newori.join(\" \")];\n  }\n  public toKpuzzle(): object {\n    return { permutation: this.perm, orientation: this.ori } ;\n  }\n}\nexport class TransformationBase {\n  constructor(public orbits: Orbit[]) { }\n  public internalMul(b: TransformationBase): Orbit[] {\n    const newOrbits: Orbit[] = [];\n    for (let i = 0; i < this.orbits.length; i++) {\n      newOrbits.push(this.orbits[i].mul(b.orbits[i]));\n    }\n    return newOrbits;\n  }\n  public internalInv(): Orbit[] {\n    const newOrbits: Orbit[] = [];\n    for (let i = 0; i < this.orbits.length; i++) {\n      newOrbits.push(this.orbits[i].inv());\n    }\n    return newOrbits;\n  }\n  public equal(b: TransformationBase): boolean {\n    for (let i = 0; i < this.orbits.length; i++) {\n      if (!this.orbits[i].equal(b.orbits[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  public killOri(): this {\n    for (let i = 0; i < this.orbits.length; i++) {\n      this.orbits[i].killOri();\n    }\n    return this;\n  }\n  public toPerm(): Perm {\n    const perms = new Array<Perm>();\n    let n = 0;\n    for (let i = 0; i < this.orbits.length; i++) {\n      const p = this.orbits[i].toPerm();\n      perms.push(p);\n      n += p.n;\n    }\n    const newPerm = new Array<number>(n);\n    n = 0;\n    for (let i = 0; i < this.orbits.length; i++) {\n      const p = perms[i];\n      for (let j = 0; j < p.n; j++) {\n        newPerm[n + j] = n + p.p[j];\n      }\n      n += p.n;\n    }\n    return new Perm(newPerm);\n  }\n  public identicalPieces(): number[][] {\n    const r: number[][] = [];\n    let n = 0;\n    for (let i = 0; i < this.orbits.length; i++) {\n      const o = this.orbits[i].orimod;\n      const s = this.orbits[i].identicalPieces();\n      for (let j = 0; j < s.length; j++) {\n        r.push(s[j].map((_) => _ * o + n));\n      }\n      n += o * this.orbits[i].perm.length;\n    }\n    return r;\n  }\n  public order(): number {\n    let r = 1;\n    for (let i = 0; i < this.orbits.length; i++) {\n      r = lcm(r, this.orbits[i].order());\n    }\n    return r;\n  }\n}\nexport class Transformation extends TransformationBase {\n  constructor(orbits: Orbit[]) {\n    super(orbits);\n  }\n  public mul(b: Transformation): Transformation {\n    return new Transformation(this.internalMul(b));\n  }\n  public mulScalar(n: number): Transformation {\n    if (n === 0) {\n      return this.e();\n    }\n    let t: Transformation = this;\n    if (n < 0) {\n      t = t.inv();\n      n = - n;\n    }\n    while ((n & 1) === 0) {\n      t = t.mul(t);\n      n >>= 1;\n    }\n    if (n === 1) {\n      return t;\n    }\n    let s = t;\n    let r = this.e();\n    while (n > 0) {\n      if (n & 1) {\n        r = r.mul(s);\n      }\n      if (n > 1) {\n        s = s.mul(s);\n      }\n      n >>= 1;\n    }\n    return r;\n  }\n  public inv(): Transformation {\n    return new Transformation(this.internalInv());\n  }\n  public e(): Transformation {\n    return new Transformation(this.orbits.map(\n      (_: Orbit) => Orbit.e(_.perm.length, _.orimod)));\n  }\n}\nexport class VisibleState extends TransformationBase {\n  constructor(orbits: Orbit[]) {\n    super(orbits);\n  }\n  public mul(b: Transformation): VisibleState {\n    return new VisibleState(this.internalMul(b));\n  }\n}\n//  Disjoint set union implementation.\nclass DisjointUnion {\n  public heads: number[];\n  constructor(public n: number) {\n    this.heads = new Array<number>(n);\n    for (let i = 0; i < n; i++) {\n      this.heads[i] = i;\n    }\n  }\n  public find(v: number): number {\n    let h = this.heads[v];\n    if (this.heads[h] === h) {\n      return h;\n    }\n    h = this.find(this.heads[h]);\n    this.heads[v] = h;\n    return h;\n  }\n  public union(a: number, b: number): void {\n    const ah = this.find(a);\n    const bh = this.find(b);\n    if (ah < bh) {\n      this.heads[bh] = ah;\n    } else if (ah > bh) {\n      this.heads[ah] = bh;\n    }\n  }\n}\nexport function showcanon(g: OrbitsDef, disp: (s: string) => void): void {\n  // show information for canonical move derivation\n  const n = g.moveops.length;\n  if (n > 30) {\n    throw new Error(\"Canon info too big for bitmask\");\n  }\n  const orders = [];\n  const commutes = [];\n  for (let i = 0; i < n; i++) {\n    const permA = g.moveops[i];\n    orders.push(permA.order());\n    let bits = 0;\n    for (let j = 0; j < n; j++) {\n      if (j === i) {\n        continue;\n      }\n      const permB = g.moveops[j];\n      if (permA.mul(permB).equal(permB.mul(permA))) {\n        bits |= 1 << j;\n      }\n    }\n    commutes.push(bits);\n  }\n  let curlev: any = {};\n  curlev[0] = 1;\n  for (let d = 0; d < 100; d++) {\n    let sum = 0;\n    const nextlev: any = {};\n    let uniq = 0;\n    for (const sti in curlev) {\n      const st = +sti; // string to number\n      const cnt = curlev[st];\n      sum += cnt;\n      uniq++;\n      for (let mv = 0; mv < orders.length; mv++) {\n        if (((st >> mv) & 1) === 0 &&\n          (st & commutes[mv] & ((1 << mv) - 1)) === 0) {\n          const nst = (st & commutes[mv]) | (1 << mv);\n          if (nextlev[nst] === undefined) {\n            nextlev[nst] = 0;\n          }\n          nextlev[nst] += (orders[mv] - 1) * cnt;\n        }\n      }\n    }\n    disp(\"\" + d + \": canonseq \" + sum + \" states \" + uniq);\n    curlev = nextlev;\n  }\n}\n// This is a less effective canonicalization (that happens to work fine\n// for the 3x3x3).  We include this only for comparison.\nexport function showcanon0(g: OrbitsDef, disp: (s: string) => void): void {\n  // show information for canonical move derivation\n  const n = g.moveops.length;\n  if (n > 30) {\n    throw new Error(\"Canon info too big for bitmask\");\n  }\n  const orders = [];\n  const commutes = [];\n  for (let i = 0; i < n; i++) {\n    const permA = g.moveops[i];\n    orders.push(permA.order());\n    let bits = 0;\n    for (let j = 0; j < n; j++) {\n      if (j === i) {\n        continue;\n      }\n      const permB = g.moveops[j];\n      if (permA.mul(permB).equal(permB.mul(permA))) {\n        bits |= 1 << j;\n      }\n    }\n    commutes.push(bits);\n  }\n  let curlev: any = {};\n  disp(\"\" + 0 + \": canonseq \" + 1);\n  for (let x = 0; x < orders.length; x++) {\n    curlev[x] = orders[x] - 1;\n  }\n  for (let d = 1; d < 100; d++) {\n    let sum = 0;\n    const nextlev: any = {};\n    let uniq = 0;\n    for (const sti in curlev) {\n      const st = +sti; // string to number\n      const cnt = curlev[st];\n      sum += cnt;\n      uniq++;\n      for (let mv = 0; mv < orders.length; mv++) {\n        if (mv === st || ((commutes[mv] & (1 << st)) && mv < st)) {\n          continue;\n        }\n        if (nextlev[mv] === undefined) {\n          nextlev[mv] = 0;\n        }\n        nextlev[mv] += (orders[mv] - 1) * cnt;\n      }\n    }\n    disp(\"\" + d + \": canonseq \" + sum + \" states \" + uniq);\n    curlev = nextlev;\n  }\n}\n","/* tslint:disable no-bitwise */\n/* tslint:disable prefer-for-of */ // TODO\n\n// We need a quaternion class.  We use this to represent rotations,\n// planes, and points.\n\nconst eps = 1e-9; // TODO: Deduplicate with `PuzzleGeometry`?\n\nexport function expandfaces(rots: Quat[], faces: Quat[][]): Quat[][] {\n  // given a set of faces, expand by rotation set\n  const nfaces = [];\n  for (let i = 0; i < rots.length; i++) {\n    for (let k = 0; k < faces.length; k++) {\n      const face = faces[k];\n      const nface = [];\n      for (let j = 0; j < face.length; j++) {\n        nface.push(face[j].rotateplane(rots[i]));\n      }\n      nfaces.push(nface);\n    }\n  }\n  return nfaces;\n}\n\nexport function centermassface(face: Quat[]): Quat {\n  // calculate a center of a face by averaging points\n  let s = new Quat(0, 0, 0, 0);\n  for (let i = 0; i < face.length; i++) {\n    s = s.sum(face[i]);\n  }\n  return s.smul(1.0 / face.length);\n}\n\nexport function random(): Quat { // generate a random quat\n  const q = new Quat(Math.random() * 2 - 1, Math.random() * 2 - 1,\n    Math.random() * 2 - 1, Math.random() * 2 - 1);\n  return q.smul(1 / q.len());\n}\n\nexport function solvethreeplanes(p1: number, p2: number, p3: number, planes: Quat[]): any {\n  // find intersection of three planes but only if interior\n  // Takes three indices into a plane array, and returns the point at the\n  // intersection of all three, but only if it is internal to all planes.\n  const p = planes[p1].intersect3(planes[p2], planes[p3]);\n  if (!p) {\n    return p;\n  }\n  for (let i = 0; i < planes.length; i++) {\n    if (i !== p1 && i !== p2 && i !== p3) {\n      const dt = planes[i].b * p.b + planes[i].c * p.c + planes[i].d * p.d;\n      if ((planes[i].a > 0 && dt > planes[i].a) ||\n        (planes[i].a < 0 && dt < planes[i].a)) {\n        return false;\n      }\n    }\n  }\n  return p;\n}\n\nexport class Quat {\n  constructor(public a: number, public b: number, public c: number, public d: number) {\n  }\n  public mul(q: Quat): Quat { // Quaternion multiplication\n    return new Quat(\n      this.a * q.a - this.b * q.b - this.c * q.c - this.d * q.d,\n      this.a * q.b + this.b * q.a + this.c * q.d - this.d * q.c,\n      this.a * q.c - this.b * q.d + this.c * q.a + this.d * q.b,\n      this.a * q.d + this.b * q.c - this.c * q.b + this.d * q.a);\n  }\n  public toString(): string {\n    return \"Q[\" + this.a + \",\" + this.b + \",\" + this.c + \",\" + this.d + \"]\";\n  }\n  public dist(q: Quat): number { // Euclidean distance\n    return Math.hypot(this.a - q.a, this.b - q.b, this.c - q.c, this.d - q.d);\n  }\n  public len(): number { // Euclidean length\n    return Math.hypot(this.a, this.b, this.c, this.d);\n  }\n  public cross(q: Quat): Quat { // cross product\n    return new Quat(0, this.c * q.d - this.d * q.c,\n      this.d * q.b - this.b * q.d, this.b * q.c - this.c * q.b);\n  }\n  public dot(q: Quat): number { // dot product of two quaternions\n    return this.b * q.b + this.c * q.c + this.d * q.d;\n  }\n  public normalize(): Quat { // make the magnitude be 1\n    const d = Math.sqrt(this.dot(this));\n    return new Quat(this.a / d, this.b / d, this.c / d, this.d / d);\n  }\n  public makenormal(): Quat { // make a normal vector from a plane or quat or point\n    return new Quat(0, this.b, this.c, this.d).normalize();\n  }\n  public normalizeplane(): Quat { // normalize a plane\n    const d = Math.hypot(this.b, this.c, this.d);\n    return new Quat(this.a / d, this.b / d, this.c / d, this.d / d);\n  }\n  public smul(m: number): Quat { // scalar multiplication\n    return new Quat(this.a * m, this.b * m, this.c * m, this.d * m);\n  }\n  public sum(q: Quat): Quat { // quaternion sum\n    return new Quat(this.a + q.a, this.b + q.b, this.c + q.c, this.d + q.d);\n  }\n  public sub(q: Quat): Quat { // difference\n    return new Quat(this.a - q.a, this.b - q.b, this.c - q.c, this.d - q.d);\n  }\n  public angle(): number { // quaternion angle\n    return 2 * Math.acos(this.a);\n  }\n  public invrot(): Quat { // quaternion inverse rotation\n    return new Quat(this.a, -this.b, -this.c, -this.d);\n  }\n  public det3x3(\n    a00: number, a01: number, a02: number,\n    a10: number, a11: number, a12: number,\n    a20: number, a21: number, a22: number): number {\n    // 3x3 determinant\n    return a00 * (a11 * a22 - a12 * a21) +\n      a01 * (a12 * a20 - a10 * a22) +\n      a02 * (a10 * a21 - a11 * a20);\n  }\n  public rotateplane(q: Quat): Quat { // rotate a plane using a quaternion\n    const t = q.mul(new Quat(0, this.b, this.c, this.d)).mul(q.invrot());\n    t.a = this.a;\n    return t;\n  }\n  public rotatepoint(q: Quat): Quat { // rotate a point\n    return q.mul(this).mul(q.invrot());\n  }\n  public rotateface(face: Quat[]): Quat[] { // rotate a face by this Q.\n    const that = this;\n    return face.map((_: Quat) => _.rotatepoint(that));\n  }\n  public rotatecubie(cubie: Quat[][]): Quat[][] { // rotate a cubie by this Q.\n    const that = this;\n    return cubie.map((_: Quat[]) => that.rotateface(_));\n  }\n  public intersect3(p2: Quat, p3: Quat): Quat | false { // intersect three planes if there is one\n    const det = this.det3x3(this.b, this.c, this.d,\n      p2.b, p2.c, p2.d,\n      p3.b, p3.c, p3.d);\n    if (Math.abs(det) < eps) {\n      return false; // TODO: Change to `null` or `undefined`?\n    }\n    return new Quat(0,\n      this.det3x3(this.a, this.c, this.d,\n        p2.a, p2.c, p2.d, p3.a, p3.c, p3.d) / det,\n      this.det3x3(this.b, this.a, this.d,\n        p2.b, p2.a, p2.d, p3.b, p3.a, p3.d) / det,\n      this.det3x3(this.b, this.c, this.a,\n        p2.b, p2.c, p2.a, p3.b, p3.c, p3.a) / det);\n  }\n  public side(x: number): number {\n    // is this point close to the origin, or on one or the other side?\n    if (x > eps) {\n      return 1;\n    }\n    if (x < -eps) {\n      return -1;\n    }\n    return 0;\n  }\n  public cutfaces(faces: Quat[][]): Quat[][] {\n    // Cut a set of faces by a plane and return new set\n    const that = this; // welcome to Javascript\n    const d = this.a;\n    const nfaces = [];\n    for (let j = 0; j < faces.length; j++) {\n      const face = faces[j];\n      const inout = face.map((_: Quat) => that.side(_.dot(that) - d));\n      let seen = 0;\n      for (let i = 0; i < inout.length; i++) {\n        seen |= 1 << (inout[i] + 1);\n      }\n      if ((seen & 5) === 5) { // saw both sides\n        for (let s = -1; s <= 1; s += 2) {\n          const nface = [];\n          for (let k = 0; k < face.length; k++) {\n            if (inout[k] === s || inout[k] === 0) {\n              nface.push(face[k]);\n            }\n            const kk = (k + 1) % face.length;\n            if (inout[k] + inout[kk] === 0 && inout[k] !== 0) {\n              const vk = face[k].dot(this) - d;\n              const vkk = face[kk].dot(this) - d;\n              const r = vk / (vk - vkk);\n              const pt = face[k].smul(1 - r).sum(face[kk].smul(r));\n              nface.push(pt);\n            }\n          }\n          nfaces.push(nface);\n        }\n      } else { // no split\n        nfaces.push(face);\n      }\n    }\n    return nfaces;\n  }\n  public faceside(face: Quat[]): number { // which side of a plane is a face on?\n    const d = this.a;\n    for (let i = 0; i < face.length; i++) {\n      const s = this.side(face[i].dot(this) - d);\n      if (s !== 0) {\n        return s;\n      }\n    }\n    throw new Error(\"Could not determine side of plane in faceside\");\n  }\n  public sameplane(p: Quat): boolean { // are two planes the same?\n    const a = this.normalize();\n    const b = p.normalize();\n    return a.dist(b) < eps || a.dist(b.smul(-1)) < eps;\n  }\n  public makecut(r: number): Quat { // make a cut from a normal vector\n    return new Quat(r, this.b, this.c, this.d);\n  }\n}\n","/* tslint:disable prefer-for-of */ // TODO\n\nimport { Quat, solvethreeplanes } from \"./Quat\";\n\n// Next we define a class that yields quaternion generators for each of\n// the five platonic solids.  The quaternion generators chosen are\n// chosen specifically so that the first quaternion doubles as a plane\n// description that yields the given Platonic solid (so for instance, the\n// cubical group and octahedral group are identical in math, but we\n// give distinct representations choosing the first quaternion so that\n// we get the desired figure.)  Our convention is one vertex of the\n// shape points precisely down.\n\n// This class is static.\n\nconst eps = 1e-9; // TODO: Deduplicate with `PuzzleGeometry`?\n\nexport function cube(): Quat[] {\n  const s5 = Math.sqrt(0.5);\n  return [new Quat(s5, s5, 0, 0), new Quat(s5, 0, s5, 0)];\n}\n\nexport function tetrahedron(): Quat[] {\n  return [new Quat(0.5, 0.5, 0.5, 0.5), new Quat(0.5, 0.5, 0.5, -0.5)];\n}\n\nexport function dodecahedron(): Quat[] {\n  const d36 = 2 * Math.PI / 10;\n  let dx = 0.5 + 0.3 * Math.sqrt(5);\n  let dy = 0.5 + 0.1 * Math.sqrt(5);\n  const dd = Math.sqrt(dx * dx + dy * dy);\n  dx /= dd;\n  dy /= dd;\n  return [new Quat(Math.cos(d36), dx * Math.sin(d36), dy * Math.sin(d36), 0),\n  new Quat(0.5, 0.5, 0.5, 0.5)];\n}\n\nexport function icosahedron(): Quat[] {\n  let dx = 1 / 6 + Math.sqrt(5) / 6;\n  let dy = 2 / 3 + Math.sqrt(5) / 3;\n  const dd = Math.sqrt(dx * dx + dy * dy);\n  dx /= dd;\n  dy /= dd;\n  const ang = 2 * Math.PI / 6;\n  return [new Quat(Math.cos(ang), dx * Math.sin(ang), dy * Math.sin(ang), 0),\n  new Quat(Math.cos(ang), -dx * Math.sin(ang), dy * Math.sin(ang), 0)];\n}\n\nexport function octahedron(): Quat[] {\n  const s5 = Math.sqrt(0.5);\n  return [new Quat(0.5, 0.5, 0.5, 0.5), new Quat(s5, 0, 0, s5)];\n}\n\nexport function closure(g: Quat[]): Quat[] {\n  // compute the closure of a set of generators\n  // This is quadratic in the result size.  Also, it has no protection\n  // against you providing a bogus set of generators that would generate\n  // an infinite group.\n  const q = [new Quat(1, 0, 0, 0)];\n  for (let i = 0; i < q.length; i++) {\n    for (let j = 0; j < g.length; j++) {\n      const ns = g[j].mul(q[i]);\n      const negns = ns.smul(-1);\n      let wasseen = false;\n      for (let k = 0; k < q.length; k++) {\n        if (ns.dist(q[k]) < eps ||\n          negns.dist(q[k]) < eps) {\n          wasseen = true;\n          break;\n        }\n      }\n      if (!wasseen) {\n        q.push(ns);\n      }\n    }\n  }\n  return q;\n}\n\nexport function uniqueplanes(p: Quat, g: Quat[]): Quat[] {\n  // compute unique plane rotations\n  // given a rotation group and a plane, find the rotations that\n  // generate unique planes.  This is quadratic in the return size.\n  const planes = [];\n  const planerot = [];\n  for (let i = 0; i < g.length; i++) {\n    const p2 = p.rotateplane(g[i]);\n    let wasseen = false;\n    for (let j = 0; j < planes.length; j++) {\n      if (p2.dist(planes[j]) < eps) {\n        wasseen = true;\n        break;\n      }\n    }\n    if (!wasseen) {\n      planes.push(p2);\n      planerot.push(g[i]);\n    }\n  }\n  return planerot;\n}\n\nexport function getface(planes: Quat[]): Quat[] {\n  // compute a face given a set of planes\n  // The face returned will be a set of points that lie in the first plane\n  // in the given array, that are on the surface of the polytope defined\n  // by all the planes, and will be returned in clockwise order.\n  // This is O(planes^2 * return size + return_size^2).\n  const face = [];\n  for (let i = 1; i < planes.length; i++) {\n    for (let j = i + 1; j < planes.length; j++) {\n      const p = solvethreeplanes(0, i, j, planes);\n      if (p) {\n        let wasseen = false;\n        for (let k = 0; k < face.length; k++) {\n          if (p.dist(face[k]) < eps) {\n            wasseen = true;\n            break;\n          }\n        }\n        if (!wasseen) {\n          face.push(p);\n        }\n      }\n    }\n  }\n  while (true) {\n    let changed = false;\n    for (let i = 0; i < face.length; i++) {\n      const j: number = (i + 1) % face.length;\n      if (planes[0].dot(face[i].cross(face[j])) < 0) {\n        const t: Quat = face[i];\n        face[i] = face[j];\n        face[j] = t;\n        changed = true;\n      }\n    }\n    if (!changed) {\n      break;\n    }\n  }\n  return face;\n}\n","export type PuzzleDescriptionString = string;\n\nexport const Puzzles: { [name: string]: PuzzleDescriptionString } = {\n  \"2x2x2\": \"c f 0\",\n  \"3x3x3\": \"c f 0.333333333333333\",\n  \"4x4x4\": \"c f 0.5 f 0\",\n  \"5x5x5\": \"c f 0.6 f 0.2\",\n  \"6x6x6\": \"c f 0.666666666666667 f 0.333333333333333 f 0\",\n  \"7x7x7\": \"c f 0.714285714285714 f 0.428571428571429 f 0.142857142857143\",\n  \"8x8x8\": \"c f 0.75 f 0.5 f 0.25 f 0\",\n  \"9x9x9\": \"c f 0.777777777777778 f 0.555555555555556 f 0.333333333333333 f 0.111111111111111\",\n  \"10x10x10\": \"c f 0.8 f 0.6 f 0.4 f 0.2 f 0\",\n  \"11x11x11\": \"c f 0.818181818181818 f 0.636363636363636 f 0.454545454545455 f 0.272727272727273 f 0.0909090909090909\",\n  \"12x12x12\": \"c f 0.833333333333333 f 0.666666666666667 f 0.5 f 0.333333333333333 f 0.166666666666667 f 0\",\n  \"13x13x13\": \"c f 0.846153846153846 f 0.692307692307692 f 0.538461538461538 f 0.384615384615385 f 0.230769230769231 f 0.0769230769230769\",\n  \"20x20x20\": \"c f 0 f .1 f .2 f .3 f .4 f .5 f .6 f .7 f .8 f .9\",\n  \"30x30x30\": \"c f 0 f .066667 f .133333 f .2 f .266667 f .333333 f .4 f .466667 f .533333 f .6 f .666667 f .733333 f .8 f .866667 f .933333\",\n  \"skewb\": \"c v 0\",\n  \"master skewb\": \"c v 0.275\",\n  \"professor skewb\": \"c v 0 v 0.38\",\n  \"compy cube\": \"c v 0.915641442663986\",\n  \"helicopter\": \"c e 0.707106781186547\",\n  \"dino\": \"c v 0.577350269189626\",\n  \"little chop\": \"c e 0\",\n  \"pyramorphix\": \"t e 0\",\n  \"mastermorphix\": \"t e 0.346184634065199\",\n  \"pyraminx\": \"t v 0.333333333333333 v 1.66666666666667\",\n  \"Jing pyraminx\": \"t f 0\",\n  \"master paramorphix\": \"t e 0.866025403784437\",\n  \"megaminx\": \"d f 0.7\",\n  \"gigaminx\": \"d f 0.64 f 0.82\",\n  \"pentultimate\": \"d f 0\",\n  \"starminx\": \"d v 0.93796236956\",\n  \"starminx 2\": \"d f 0.23606797749979\",\n  \"pyraminx crystal\": \"d f 0.447213595499989\",\n  \"chopasaurus\": \"d v 0\",\n  \"big chop\": \"d e 0\",\n  \"skewb diamond\": \"o f 0\",\n  \"FTO\": \"o f 0.333333333333333\",\n  \"Christopher's jewel\": \"o v 0.577350269189626\",\n  \"octastar\": \"o e 0\",\n  \"Trajber's octahedron\": \"o v 0.433012701892219\",\n  \"radio chop\": \"i f 0\",\n  \"icosamate\": \"i v 0\",\n  \"icosahedron 2\": \"i v 0.18759247376021\",\n  \"icosahedron 3\": \"i v 0.18759247376021 e 0\",\n  \"icosahedron static faces\": \"i v 0.84\",\n  \"icosahedron moving faces\": \"i v 0.73\",\n  \"Eitan's star\": \"i f 0.61803398874989\",\n  \"2x2x2 + dino\": \"c f 0 v 0.577350269189626\",\n  \"2x2x2 + little chop\": \"c f 0 e 0\",\n  \"dino + little chop\": \"c v 0.577350269189626 e 0\",\n  \"2x2x2 + dino + little chop\": \"c f 0 v 0.577350269189626 e 0\",\n  \"megaminx + chopasaurus\": \"d f 0.61803398875 v 0\",\n  \"starminx combo\": \"d f 0.23606797749979 v 0.93796236956\",\n};\n\nexport type PuzzleName = keyof typeof Puzzles;\n","/* tslint:disable no-bitwise */\n/* tslint:disable prefer-for-of */ // TODO\n/* tslint:disable only-arrow-functions */ // TODO\n/* tslint:disable typedef */ // TODO\n\nimport { Perm } from \"./Perm\";\nimport { Orbit, OrbitDef, OrbitsDef, showcanon, Transformation, VisibleState } from \"./PermOriSet\";\nimport { closure, cube, dodecahedron, getface, icosahedron, octahedron, tetrahedron, uniqueplanes } from \"./PlatonicGenerator\";\nimport { PuzzleDescriptionString, Puzzles } from \"./Puzzles\";\nimport { centermassface, expandfaces, Quat } from \"./Quat\";\n\nexport interface StickerDatSticker {\n  coords: number[][];\n  color: string;\n  orbit: string;\n  ord: number;\n  ori: number;\n}\n\nexport interface StickerDatFace {\n  coords: number[][];\n  name: string;\n}\n\nexport type StickerDatAxis = [number[], string, number];\n\nexport interface StickerDat {\n  stickers: StickerDatSticker[];\n  faces: StickerDatFace[];\n  axis: StickerDatAxis[];\n}\n\n//  Now we have a geometry class that does the 3D goemetry to calculate\n//  individual sticker information from a Platonic solid and a set of\n//  cuts.  The cuts must have the same symmetry as the Platonic solid;\n//  we even restrict them further to be either vertex-normal,\n//  edge-normal, or face-parallel cuts.  Right now our constructor takes\n//  a character solid indicator (one of c(ube), o(ctahedron), i(cosahedron),\n//  t(etradron), or d(odecahedron), followed by an array of cuts.\n//  Each cut is a character normal indicator that is either f(ace),\n//  e(dge), or v(ertex), followed by a floating point value that gives\n//  the depth of the cut where 0 is the center and 1 is the outside\n//  border of the shape in that direction.\n\n//  This is a heavyweight class with lots of members and construction\n//  is slow.  Be gentle.\n\n//  Everything except a very few methods should be considered private.\n\nconst eps: number = 1e-9;\nconst copyright = \"PuzzleGeometry 0.1 Copyright 2018 Tomas Rokicki.\";\n\n// This is a description of the nets and the external names we give each\n// face.  The names should be a set of prefix-free upper-case alphabetics\n// so\n// we can easily also name and distinguish vertices and edges, but we\n// may change this in the future.  The nets consist of a list of lists.\n// Each list gives the name of a face, and then the names of the\n// faces connected to that face (in the net) in clockwise order.\n// The length of each list should be one more than the number of\n// edges in the regular polygon for that face.  All polygons must\n// have the same number of edges.\n// The first two faces in the first list must describe a horizontal edge\n// that is at the bottom of a regular polygon.  The first two faces in\n// every subsequent list for a given polytope must describe a edge that\n// is directly connected in the net and has already been described (this\n// sets the location and orientation of the polygon for that face.\n// Any edge that is not directly connected in the net should be given\n// the empty string as the other face.  All faces do not need to have\n// a list starting with that face; just enough to describe the full\n// connectivity of the net.\n//\nconst defaultnets: any = {\n  4: // four faces: tetrahedron\n    [\n      [\"F\", \"D\", \"L\", \"R\"],\n    ],\n  6: // six faces: cube\n    [\n      [\"F\", \"D\", \"L\", \"U\", \"R\"],\n      [\"R\", \"F\", \"\", \"B\", \"\"],\n    ],\n  8: // eight faces: octahedron\n    [\n      [\"F\", \"D\", \"L\", \"R\"],\n      [\"D\", \"F\", \"N\", \"\"],\n      [\"N\", \"D\", \"\", \"B\"],\n      [\"B\", \"N\", \"U\", \"M\"],\n    ],\n  12: // twelve faces:  dodecahedron; U/F/R/F/BL/BR from megaminx\n    [\n      [\"U\", \"F\", \"\", \"\", \"\", \"\"],\n      [\"F\", \"U\", \"R\", \"C\", \"A\", \"L\"],\n      [\"R\", \"F\", \"\", \"\", \"E\", \"\"],\n      [\"E\", \"R\", \"\", \"BF\", \"\", \"\"],\n      [\"BF\", \"E\", \"BR\", \"BL\", \"I\", \"D\"],\n    ],\n  20: // twenty faces: icosahedron\n    [\n      [\"R\", \"C\", \"F\", \"E\"],\n      [\"F\", \"R\", \"L\", \"U\"],\n      [\"L\", \"F\", \"A\", \"\"],\n      [\"E\", \"R\", \"G\", \"I\"],\n      [\"I\", \"E\", \"S\", \"H\"],\n      [\"S\", \"I\", \"J\", \"B\"],\n      [\"B\", \"S\", \"K\", \"D\"],\n      [\"K\", \"B\", \"M\", \"O\"],\n      [\"O\", \"K\", \"P\", \"N\"],\n      [\"P\", \"O\", \"Q\", \"\"],\n    ],\n};\n\nconst defaultcolors: any = {\n  // the colors should use the same naming convention as the nets, above.\n  4: { F: \"#00ff00\", D: \"#ffff00\", L: \"#ff0000\", R: \"#0000ff\" },\n  6: {\n    U: \"#ffffff\", F: \"#00ff00\", R: \"#ff0000\",\n    D: \"#ffff00\", B: \"#0000ff\", L: \"#ff8000\",\n  },\n  8: {\n    U: \"#e085b9\", F: \"#080d99\", R: \"#c1e35c\", D: \"#22955e\",\n    B: \"#9121ab\", L: \"#b27814\", M: \"#0d35ad\", N: \"#eb126b\",\n  },\n  12: {\n    U: \"#ffffff\", F: \"#006633\", R: \"#ff0000\", C: \"#ffffd0\",\n    A: \"#3399ff\", L: \"#660099\", E: \"#ff66cc\", BF: \"#99ff00\",\n    BR: \"#0000ff\", BL: \"#ffff00\", I: \"#ff6633\", D: \"#999999\",\n  },\n  20: {\n    R: \"#db69f0\", C: \"#178fde\", F: \"#23238b\", E: \"#9cc726\",\n    L: \"#2c212d\", U: \"#177fa7\", A: \"#e0de7f\", G: \"#2b57c0\",\n    I: \"#41126b\", S: \"#4b8c28\", H: \"#7c098d\", J: \"#7fe7b4\",\n    B: \"#85fb74\", K: \"#3f4bc3\", D: \"#0ff555\", M: \"#f1c2c8\",\n    O: \"#58d340\", P: \"#c514f2\", N: \"#14494e\", Q: \"#8b1be1\",\n  },\n};\n\n// the default precedence of the faces is given here.  This permits\n// the orientations to be reasonably predictable.  There are tradeoffs;\n// some face precedence orders do better things to the edge orientations\n// than the corner orientations and some are the opposite.\nconst defaultfaceorders: any = {\n  4: [\"F\", \"D\", \"L\", \"R\"],\n  6: [\"U\", \"D\", \"F\", \"B\", \"L\", \"R\"],\n  8: [\"F\", \"B\", \"D\", \"U\", \"N\", \"L\", \"R\", \"M\"],\n  12: [\"L\", \"E\", \"F\", \"BF\", \"R\", \"I\",\n    \"U\", \"D\", \"BR\", \"A\", \"BL\", \"C\"],\n  20: [\"L\", \"S\", \"E\", \"O\", \"F\", \"B\", \"I\", \"P\", \"R\", \"K\",\n    \"U\", \"D\", \"J\", \"A\", \"Q\", \"H\", \"G\", \"N\", \"M\", \"C\"],\n};\n\nfunction findelement(a: any[], p: Quat): number {\n  // find something in facenames, vertexnames, edgenames\n  for (let i = 0; i < a.length; i++) {\n    if (a[i][0].dist(p) < eps) {\n      return i;\n    }\n  }\n  throw new Error(\"Element not found\");\n}\n\nexport function getpuzzles(): { [s: string]: PuzzleDescriptionString } {\n  // get some simple definitions of basic puzzles\n  return Puzzles;\n}\n\nexport function getpuzzle(puzzleName: PuzzleName): PuzzleDescriptionString {\n  // get some simple definitions of basic puzzles\n  return Puzzles[puzzleName];\n}\n\nexport function parsedesc(s: string): any { // parse a text description\n  const a = s.split(/ /).filter(Boolean);\n  if (a.length % 2 === 0) {\n    return false;\n  }\n  if (a[0] !== \"o\" && a[0] !== \"c\" && a[0] !== \"i\" && a[0] !== \"d\" && a[0] !== \"t\") {\n    return false;\n  }\n  const r = [];\n  for (let i = 1; i < a.length; i += 2) {\n    if (a[i] !== \"f\" && a[i] !== \"v\" && a[i] !== \"e\") {\n      return false;\n    }\n    r.push([a[i], a[i + 1]]);\n  }\n  return [a[0], r];\n}\n\n// TODO: Automatically associate this with the source list.\ntype PuzzleName = \"2x2x2\" | \"3x3x3\" | \"4x4x4\" | \"5x5x5\" | \"6x6x6\" | \"7x7x7\" | \"8x8x8\" | \"9x9x9\" | \"10x10x10\" | \"11x11x11\" | \"12x12x12\" | \"13x13x13\" | \"20x20x20\" | \"skewb\" | \"master skewb\" | \"professor skewb\" | \"compy cube\" | \"helicopter\" | \"dino\" | \"little chop\" | \"pyramorphix\" | \"mastermorphix\" | \"pyraminx\" | \"Jing pyraminx\" | \"master paramorphix\" | \"megaminx\" | \"gigaminx\" | \"pentultimate\" | \"starminx\" | \"starminx 2\" | \"pyraminx crystal\" | \"chopasaurus\" | \"big chop\" | \"skewb diamond\" | \"FTO\" | \"Christopher's jewel\" | \"octastar\" | \"Trajber's octahedron\" | \"radio chop\" | \"icosamate\" | \"icosahedron 2\" | \"icosahedron 3\" | \"icosahedron static faces\" | \"icosahedron moving faces\" | \"Eita\";\n\nexport function getPuzzleGeometryByDesc(desc: string, options: string[] = []): PuzzleGeometry {\n  const [shape, cuts] = parsedesc(desc);\n  const pg = new PuzzleGeometry(shape, cuts, [\"allmoves\", \"true\"].concat(options));\n  pg.allstickers();\n  pg.genperms();\n  return pg;\n}\n\nexport function getPuzzleGeometryByName(puzzleName: PuzzleName, options: string[] = []): PuzzleGeometry {\n  return getPuzzleGeometryByDesc(Puzzles[puzzleName], options);\n}\n\nfunction getmovename(geo: any, bits: number, slices: number): any {\n  // generate a move name based on bits, slice, and geo\n  // if the move name is from the opposite face, say so.\n  // find the face that's turned.\n  let nbits = 0;\n  let inverted = false;\n  for (let i = 0; i <= slices; i++) {\n    if ((bits >> i) & 1) {\n      nbits |= 1 << (slices - i);\n    }\n  }\n  if (nbits < bits) { // flip if most of the move is on the other side\n    geo = [geo[2], geo[3], geo[0], geo[1]];\n    bits = nbits;\n    inverted = true;\n  }\n  let movenameFamily = geo[0];\n  let movenamePrefix = \"\";\n  let hibit = 0;\n  while (bits >> (1 + hibit)) {\n    hibit++;\n  }\n  if (bits === (2 << slices) - 1) {\n    movenameFamily = movenameFamily + \"v\";\n  } else if (bits === (1 << hibit)) {\n    if (hibit > 0) {\n      movenamePrefix = String(hibit + 1);\n    }\n  } else if (bits === ((2 << hibit) - 1)) {\n    movenameFamily = movenameFamily.toLowerCase();\n    if (hibit > 1) {\n      movenamePrefix = String(hibit + 1);\n    }\n  } else {\n    movenamePrefix = \"_\" + bits + \"_\";\n    //       throw \"We only support slice and outer block moves right now. \" + bits ;\n  }\n  return [movenamePrefix + movenameFamily, inverted];\n}\n\n// split a geometrical element into face names.  The facenames must\n// be prefix-free.\nfunction splitByFaceNames(s: string, facenames: any[]): string[] {\n  const r: string[] = [];\n  let at = 0;\n  while (at < s.length) {\n    let found = false;\n    for (let i = 0; i < facenames.length; i++) {\n      if (s.substr(at).startsWith(facenames[i][1])) {\n        r.push(facenames[i][1]);\n        at += facenames[i][1].length;\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      throw new Error((\"Could not split \" + s + \" into face names.\"));\n    }\n  }\n  return r;\n}\n\nfunction toCoords(q: Quat, maxdist: number): number[] {\n  return [- q.b / maxdist, - q.c / maxdist, - q.d / maxdist];\n}\n\nfunction toFaceCoords(q: Quat[], maxdist: number): number[][] {\n  const r = [];\n  const n = q.length;\n  for (let i = 0; i < n; i++) {\n    r[n - i - 1] = toCoords(q[i], maxdist);\n  }\n  return r;\n}\n\nfunction trimEdges(face: Quat[], tr: number): Quat[] {\n  const r: Quat[] = [];\n  for (let iter = 1; iter < 10; iter++) {\n    for (let i = 0; i < face.length; i++) {\n      const pi = (i + face.length - 1) % face.length;\n      const ni = (i + 1) % face.length;\n      const A = face[pi].sub(face[i]).normalize();\n      const B = face[ni].sub(face[i]).normalize();\n      const d = A.dot(B);\n      const m = tr / Math.sqrt(1 - d * d);\n      r[i] = face[i].sum(A.sum(B).smul(m));\n    }\n    let good = true;\n    for (let i = 0; good && i < r.length; i++) {\n      const pi = (i + face.length - 1) % face.length;\n      const ni = (i + 1) % face.length;\n      if (r[pi].sub(r[i]).cross(r[ni].sub(r[i])).dot(r[i]) >= 0) {\n        good = false;\n      }\n    }\n    if (good) {\n      return r;\n    }\n    tr /= 2;\n  }\n  return face;\n}\n\nexport class PuzzleGeometry {\n  public args: string = \"\";\n  public rotations: Quat[];    // all members of the rotation group\n  public baseplanerot: Quat[]; // unique rotations of the baseplane\n  public baseplanes: Quat[];   // planes, corresponding to faces\n  public facenames: any[];     // face names\n  public faceplanes: any;           // face planes\n  public edgenames: any[];     // edge names\n  public vertexnames: any[];   // vertexnames\n  public geonormals: any[];    // all geometric directions, with names and types\n  public moveplanes: Quat[];   // the planes that split moves\n  public moveplanesets: any[]; // the move planes, in parallel sets\n  public movesetorders: any[]; // the order of rotations for each move set\n  public movesetgeos: any[];   // geometric feature information for move sets\n  public basefaces: Quat[][];  // polytope faces before cuts\n  public faces: Quat[][];      // all the stickers\n  public basefacecount: number;      // number of base faces\n  public stickersperface: number;    // number of stickers per face\n  public cornerfaces: number;        // number of faces that meet at a corner\n  public cubies: any[];        // the cubies\n  public shortedge: number;         // shortest edge\n  public vertexdistance: number;    // vertex distance\n  public edgedistance: number;      // edge distance\n  public orbits: number;            // count of cubie orbits\n  public facetocubies: any[];  // map a face to a cubie index and offset\n  public moverotations: Quat[][]; // move rotations\n  public cubiekey: any;             // cubie locator\n  public cubiekeys: string[];  // cubie keys\n  public facelisthash: any;         // face list by key\n  public cubiesetnames: any[]; // cubie set names\n  public cubieords: number[];  // the size of each orbit\n  public cubiesetnums: number[];\n  public cubieordnums: number[];\n  public orbitoris: number[];  // the orientation size of each orbit\n  public cubievaluemap: number[]; // the map for identical cubies\n  public cubiesetcubies: number[][]; // cubies in each cubie set\n  public movesbyslice: any[];  // move as perms by slice\n  public cmovesbyslice: any[] = []; // cmoves as perms by slice\n  // options\n  public verbose: number = 0;         // verbosity (console.log)\n  public allmoves: boolean = false; // generate all slice moves in ksolve\n  public outerblockmoves: boolean;  // generate outer block moves\n  public vertexmoves: boolean;      // generate vertex moves\n  public addrotations: boolean;     // add symmetry information to ksolve output\n  public movelist: any;             // move list to generate\n  public parsedmovelist: any;       // parsed move list\n  public cornersets: boolean = true; // include corner sets\n  public centersets: boolean = true; // include center sets\n  public edgesets: boolean = true;   // include edge sets\n  public graycorners: boolean = false; // make corner sets gray\n  public graycenters: boolean = false; // make center sets gray\n  public grayedges: boolean = false;   // make edge sets gray\n  public killorientation: boolean = false; // eliminate any orientations\n  public optimize: boolean = false;  // optimize PermOri\n  public scramble: number = 0;       // scramble?\n  public ksolvemovenames: string[]; // move names from ksolve\n  public fixPiece: string = \"\";      // fix a piece?\n  public orientCenters: boolean = false; // orient centers?\n  public duplicatedFaces: number[] = []; // which faces are duplicated\n  public duplicatedCubies: number[] = []; // which cubies are duplicated\n  public fixedCubie: number = -1;    // fixed cubie, if any\n  public svggrips: any[];       // grips from svg generation by svg coordinate\n  public net: any = [];\n  public colors: any = [];\n  public faceorder: any = [];\n  public faceprecedence: number[] = [];\n  constructor(shape: string, cuts: string[][], optionlist: any[] | undefined) {\n    if (optionlist !== undefined) {\n      if (optionlist.length % 2 !== 0) {\n        throw new Error(\"Odd length in option list?\");\n      }\n      for (let i = 0; i < optionlist.length; i += 2) {\n        if (optionlist[i] === \"verbose\") {\n          this.verbose++;\n        } else if (optionlist[i] === \"quiet\") {\n          this.verbose = 0;\n        } else if (optionlist[i] === \"allmoves\") {\n          this.allmoves = optionlist[i + 1];\n        } else if (optionlist[i] === \"outerblockmoves\") {\n          this.outerblockmoves = optionlist[i + 1];\n        } else if (optionlist[i] === \"vertexmoves\") {\n          this.vertexmoves = optionlist[i + 1];\n        } else if (optionlist[i] === \"rotations\") {\n          this.addrotations = optionlist[i + 1];\n        } else if (optionlist[i] === \"cornersets\") {\n          this.cornersets = optionlist[i + 1];\n        } else if (optionlist[i] === \"centersets\") {\n          this.centersets = optionlist[i + 1];\n        } else if (optionlist[i] === \"edgesets\") {\n          this.edgesets = optionlist[i + 1];\n        } else if (optionlist[i] === \"graycorners\") {\n          this.graycorners = optionlist[i + 1];\n        } else if (optionlist[i] === \"graycenters\") {\n          this.graycenters = optionlist[i + 1];\n        } else if (optionlist[i] === \"grayedges\") {\n          this.grayedges = optionlist[i + 1];\n        } else if (optionlist[i] === \"movelist\") {\n          this.movelist = optionlist[i + 1];\n        } else if (optionlist[i] === \"killorientation\") {\n          this.killorientation = optionlist[i + 1];\n        } else if (optionlist[i] === \"optimize\") {\n          this.optimize = optionlist[i + 1];\n        } else if (optionlist[i] === \"scramble\") {\n          this.scramble = optionlist[i + 1];\n        } else if (optionlist[i] === \"fix\") {\n          this.fixPiece = optionlist[i + 1];\n        } else if (optionlist[i] === \"orientcenters\") {\n          this.orientCenters = optionlist[i + 1];\n        } else {\n          throw new Error(\"Bad option while processing option list \" + optionlist[i]);\n        }\n      }\n    }\n    this.args = shape + \" \" + (cuts.map((_) => _.join(\" \")).join(\" \"));\n    if (optionlist) {\n      this.args += \" \" + optionlist.join(\" \");\n    }\n    if (this.verbose > 0) {\n      console.log(this.header(\"# \"));\n    }\n    this.create(shape, cuts);\n  }\n\n  public create(shape: string, cuts: any[]): void {\n    // create the shape, doing all the essential geometry\n    // create only goes far enough to figure out how many stickers per\n    // face, and what the short edge is.  If the short edge is too short,\n    // we probably don't want to display or manipulate this one.  How\n    // short is too short is hard to say.\n    // var that = this ; // TODO\n    this.moveplanes = [];\n    this.faces = [];\n    this.cubies = [];\n    let g = null;\n    switch (shape) {\n      case \"c\": g = cube(); break;\n      case \"o\": g = octahedron(); break;\n      case \"i\": g = icosahedron(); break;\n      case \"t\": g = tetrahedron(); break;\n      case \"d\": g = dodecahedron(); break;\n      default: throw new Error(\"Bad shape argument: \" + shape);\n    }\n    this.rotations = closure(g);\n    if (this.verbose) { console.log(\"# Rotations: \" + this.rotations.length); }\n    const baseplane = g[0];\n    this.baseplanerot = uniqueplanes(baseplane, this.rotations);\n    const baseplanes = this.baseplanerot.map((_) => baseplane.rotateplane(_));\n    this.baseplanes = baseplanes;\n    this.basefacecount = baseplanes.length;\n    const net = defaultnets[baseplanes.length];\n    this.net = net;\n    this.colors = defaultcolors[baseplanes.length];\n    this.faceorder = defaultfaceorders[baseplanes.length];\n    if (this.verbose) { console.log(\"# Base planes: \" + baseplanes.length); }\n    const baseface = getface(baseplanes);\n    if (this.verbose) { console.log(\"# Face vertices: \" + baseface.length); }\n    const facenormal = baseplanes[0].makenormal();\n    const edgenormal = baseface[0].sum(baseface[1]).makenormal();\n    const vertexnormal = baseface[0].makenormal();\n    const cutplanes = [];\n    for (let i = 0; i < cuts.length; i++) {\n      let normal = null;\n      switch (cuts[i][0]) {\n        case \"f\": normal = facenormal; break;\n        case \"v\": normal = vertexnormal; break;\n        case \"e\": normal = edgenormal; break;\n        default: throw new Error(\"Bad cut argument: \" + cuts[i][0]);\n      }\n      cutplanes.push(normal.makecut(cuts[i][1]));\n    }\n    const boundary = new Quat(1, facenormal.b, facenormal.c, facenormal.d);\n    if (this.verbose) { console.log(\"# Boundary is \" + boundary); }\n    const planerot = uniqueplanes(boundary, this.rotations);\n    const planes = planerot.map((_) => boundary.rotateplane(_));\n    let faces = [getface(planes)];\n    this.basefaces = [];\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(faces[0]);\n      this.basefaces.push(face);\n    }\n    //\n    //   Determine names for edges, vertices, and planes.  Planes are defined\n    //   by the plane normal/distance; edges are defined by the midpoint;\n    //   vertices are defined by actual point.  In each case we define a name.\n    //   Note that edges have two potential names, and corners have n where\n    //   n planes meet at a vertex.  We arbitrarily choose the one that is\n    //   alphabetically first (and we will probably want to change this).\n    //\n    const facenames: any[] = [];\n    const faceplanes = [];\n    const vertexnames: any[] = [];\n    const edgenames: any[] = [];\n    const edgesperface = faces[0].length;\n    function searchaddelement(a: any[], p: Quat, name: any) {\n      for (let i = 0; i < a.length; i++) {\n        if (a[i][0].dist(p) < eps) {\n          a[i].push(name);\n          return;\n        }\n      }\n      a.push([p, name]);\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(faces[0]);\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        searchaddelement(edgenames, midpoint, i);\n      }\n    }\n    const otherfaces = [];\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(faces[0]);\n      const facelist = [];\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        const el = edgenames[findelement(edgenames, midpoint)];\n        if (i === el[1]) {\n          facelist.push(el[2]);\n        } else if (i === el[2]) {\n          facelist.push(el[1]);\n        } else {\n          throw new Error(\"Could not find edge\");\n        }\n      }\n      otherfaces.push(facelist);\n    }\n    const facenametoindex: any = {};\n    const faceindextoname: any = [];\n    faceindextoname.push(net[0][0]);\n    facenametoindex[net[0][0]] = 0;\n    faceindextoname[otherfaces[0][0]] = net[0][1];\n    facenametoindex[net[0][1]] = otherfaces[0][0];\n    for (let i = 0; i < net.length; i++) {\n      const f0 = net[i][0];\n      const fi = facenametoindex[f0];\n      if (fi === undefined) {\n        throw new Error(\"Bad edge description; first edge not connected\");\n      }\n      let ii = -1;\n      for (let j = 0; j < otherfaces[fi].length; j++) {\n        const fn2 = faceindextoname[otherfaces[fi][j]];\n        if (fn2 !== undefined && fn2 === net[i][1]) {\n          ii = j;\n          break;\n        }\n      }\n      if (ii < 0) {\n        throw new Error(\"First element of a net not known\");\n      }\n      for (let j = 2; j < net[i].length; j++) {\n        if (net[i][j] === \"\") {\n          continue;\n        }\n        const of = otherfaces[fi][(j + ii - 1) % edgesperface];\n        const fn2 = faceindextoname[of];\n        if (fn2 !== undefined && fn2 !== net[i][j]) {\n          throw new Error(\"Face mismatch in net\");\n        }\n        faceindextoname[of] = net[i][j];\n        facenametoindex[net[i][j]] = of;\n      }\n    }\n    for (let i = 0; i < faceindextoname.length; i++) {\n      let found = false;\n      for (let j = 0; j < this.faceorder.length; j++) {\n        if (faceindextoname[i] === this.faceorder[j]) {\n          this.faceprecedence[i] = j;\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        throw new Error(\"Could not find face \" + faceindextoname[i] +\n          \" in face order list \" + this.faceorder);\n      }\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(faces[0]);\n      const faceplane = boundary.rotateplane(this.baseplanerot[i]);\n      const facename = faceindextoname[i];\n      facenames.push([face, facename]);\n      faceplanes.push([faceplane, facename]);\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(faces[0]);\n      const facename = faceindextoname[i];\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        const jjj = (j + 2) % face.length;\n        const midpoint2 = face[jj].sum(face[jjj]).smul(0.5);\n        const e1 = findelement(edgenames, midpoint);\n        const e2 = findelement(edgenames, midpoint2);\n        searchaddelement(vertexnames, face[jj], [facename, e2, e1]);\n      }\n    }\n    // fix the edge names; use face precedence order\n    for (let i = 0; i < edgenames.length; i++) {\n      if (edgenames[i].length !== 3) {\n        throw new Error(\"Bad length in edge names \" + edgenames[i]);\n      }\n      let c1 = faceindextoname[edgenames[i][1]];\n      const c2 = faceindextoname[edgenames[i][2]];\n      if (this.faceprecedence[edgenames[i][1]] <\n        this.faceprecedence[edgenames[i][2]]) {\n        c1 = c1 + c2;\n      } else {\n        c1 = c2 + c1;\n      }\n      edgenames[i] = [edgenames[i][0], c1];\n    }\n    // fix the vertex names; clockwise rotations; low face first.\n    this.cornerfaces = vertexnames[0].length - 1;\n    for (let i = 0; i < vertexnames.length; i++) {\n      if (vertexnames[i].length < 4) {\n        throw new Error(\"Bad length in vertex names\");\n      }\n      let st = 1;\n      for (let j = 2; j < vertexnames[i].length; j++) {\n        if (this.faceprecedence[facenametoindex[vertexnames[i][j][0]]] <\n          this.faceprecedence[facenametoindex[vertexnames[i][st][0]]]) {\n          st = j;\n        }\n      }\n      let r = \"\";\n      for (let j = 1; j < vertexnames[i].length; j++) {\n        r = r + vertexnames[i][st][0];\n        for (let k = 1; k < vertexnames[i].length; k++) {\n          if (vertexnames[i][st][2] === vertexnames[i][k][1]) {\n            st = k;\n            break;\n          }\n        }\n      }\n      vertexnames[i] = [vertexnames[i][0], r];\n    }\n    if (this.verbose > 1) {\n      console.log(\"Face precedence list: \" + this.faceorder.join(\" \"));\n      console.log(\"Face names: \" + facenames.map((_: any) => _[1]).join(\" \"));\n      console.log(\"Edge names: \" + edgenames.map((_: any) => _[1]).join(\" \"));\n      console.log(\"Vertex names: \" + vertexnames.map((_: any) => _[1]).join(\" \"));\n    }\n    const geonormals = [];\n    for (let i = 0; i < faceplanes.length; i++) {\n      geonormals.push(\n        [faceplanes[i][0].makenormal(), faceplanes[i][1], \"f\"]);\n    }\n    for (let i = 0; i < edgenames.length; i++) {\n      geonormals.push([edgenames[i][0].makenormal(), edgenames[i][1], \"e\"]);\n    }\n    for (let i = 0; i < vertexnames.length; i++) {\n      geonormals.push(\n        [vertexnames[i][0].makenormal(), vertexnames[i][1], \"v\"]);\n    }\n    this.facenames = facenames;\n    this.faceplanes = faceplanes;\n    this.edgenames = edgenames;\n    this.vertexnames = vertexnames;\n    this.geonormals = geonormals;\n    const zero = new Quat(0, 0, 0, 0);\n    this.edgedistance = faces[0][0].sum(faces[0][1]).smul(0.5).dist(zero);\n    this.vertexdistance = faces[0][0].dist(zero);\n    if (this.verbose) {\n      console.log(\"# Distances: face \" + 1 + \" edge \" + this.edgedistance +\n        \" vertex \" + this.vertexdistance);\n    }\n    // expand cutplanes by rotations.  We only work with one face here.\n    for (let c = 0; c < cutplanes.length; c++) {\n      for (let i = 0; i < this.rotations.length; i++) {\n        const q = cutplanes[c].rotateplane(this.rotations[i]);\n        let wasseen = false;\n        for (let j = 0; j < this.moveplanes.length; j++) {\n          if (q.sameplane(this.moveplanes[j])) {\n            wasseen = true;\n            break;\n          }\n        }\n        if (!wasseen) {\n          this.moveplanes.push(q);\n          faces = q.cutfaces(faces);\n        }\n      }\n    }\n    this.faces = faces;\n    if (this.verbose) { console.log(\"# Faces is now \" + faces.length); }\n    this.stickersperface = faces.length;\n    //  Find and report the shortest edge in any of the faces.  If this\n    //  is small the puzzle is probably not practical or displayable.\n    let shortedge = 1e99;\n    for (let i = 0; i < faces.length; i++) {\n      for (let j = 0; j < faces[i].length; j++) {\n        const k = (j + 1) % faces[i].length;\n        const t = faces[i][j].dist(faces[i][k]);\n        if (t < shortedge) {\n          shortedge = t;\n        }\n      }\n    }\n    this.shortedge = shortedge;\n    if (this.verbose) { console.log(\"# Short edge is \" + shortedge); }\n  }\n\n  public keyface(face: Quat[]): string {\n    // take a face and figure out the sides of each move plane\n    let s = \"\";\n    for (let i = 0; i < this.moveplanesets.length; i++) {\n      let t = 0;\n      for (let j = 0; j < this.moveplanesets[i].length; j++) {\n        if (this.moveplanesets[i][j].faceside(face) > 0) {\n          t++;\n        }\n      }\n      s = s + \" \" + t;\n    }\n    return s;\n  }\n\n  public findcubie(face: Quat[]): number {\n    return this.facetocubies[this.findface(face)][0];\n  }\n\n  public findface(face: Quat[]): number {\n    const cm = centermassface(face);\n    const key = this.keyface(face);\n    for (let i = 0; i < this.facelisthash[key].length; i++) {\n      const face2 = this.facelisthash[key][i];\n      if (Math.abs(cm.dist(\n        centermassface(this.faces[face2]))) < eps) {\n        return face2;\n      }\n    }\n    throw new Error(\"Could not find face.\");\n  }\n\n  public project2d(facen: number, edgen: number, targvec: Quat[]): any {\n    // calculate geometry to map a particular edge of a particular\n    //  face to a given 2D vector.  The face is given as an index into the\n    //  facenames/baseplane arrays, and the edge is given as an offset into\n    //  the vertices.\n    const face = this.facenames[facen][0];\n    const edgen2 = (edgen + 1) % face.length;\n    const plane = this.baseplanes[facen];\n    let x0 = face[edgen2].sub(face[edgen]);\n    const olen = x0.len();\n    x0 = x0.normalize();\n    const y0 = x0.cross(plane).normalize();\n    let delta = targvec[1].sub(targvec[0]);\n    const len = delta.len() / olen;\n    delta = delta.normalize();\n    const cosr = delta.b;\n    const sinr = delta.c;\n    const x1 = x0.smul(cosr).sub(y0.smul(sinr)).smul(len);\n    const y1 = y0.smul(cosr).sum(x0.smul(sinr)).smul(len);\n    const off = new Quat(0, targvec[0].b - x1.dot(face[edgen]),\n      targvec[0].c - y1.dot(face[edgen]), 0);\n    return [x1, y1, off];\n  }\n\n  public allstickers(): void {\n    // next step is to calculate all the stickers and orbits\n    // We do enough work here to display the cube on the screen.\n    // take our newly split base face and expand it by the rotation matrix.\n    // this generates our full set of \"stickers\".\n    this.faces = expandfaces(this.baseplanerot, this.faces);\n    if (this.verbose) { console.log(\"# Total stickers is now \" + this.faces.length); }\n    // Split moveplanes into a list of parallel planes.\n    const moveplanesets = [];\n    for (let i = 0; i < this.moveplanes.length; i++) {\n      let wasseen = false;\n      const q = this.moveplanes[i];\n      const qnormal = q.makenormal();\n      for (let j = 0; j < moveplanesets.length; j++) {\n        if (qnormal.sameplane(moveplanesets[j][0].makenormal())) {\n          moveplanesets[j].push(q);\n          wasseen = true;\n          break;\n        }\n      }\n      if (!wasseen) {\n        moveplanesets.push([q]);\n      }\n    }\n    // make the normals all face the same way in each set.\n    for (let i = 0; i < moveplanesets.length; i++) {\n      const q: Quat[] = moveplanesets[i].map((_) => _.normalizeplane());\n      const goodnormal = q[0].makenormal();\n      for (let j = 0; j < q.length; j++) {\n        if (q[j].makenormal().dist(goodnormal) > eps) {\n          q[j] = q[j].smul(-1);\n        }\n      }\n      q.sort((a, b) => a.a - b.a);\n      moveplanesets[i] = q;\n    }\n    this.moveplanesets = moveplanesets;\n    const sizes = moveplanesets.map((_) => _.length);\n    if (this.verbose) { console.log(\"# Move plane sets: \" + sizes); }\n    // for each of the move planes, find the rotations that are relevant\n    const moverotations: Quat[][] = [];\n    for (let i = 0; i < moveplanesets.length; i++) {\n      moverotations.push([]);\n    }\n    for (let i = 0; i < this.rotations.length; i++) {\n      const q: Quat = this.rotations[i];\n      if (Math.abs(Math.abs(q.a) - 1) < eps) {\n        continue;\n      }\n      const qnormal = q.makenormal();\n      for (let j = 0; j < moveplanesets.length; j++) {\n        if (qnormal.sameplane(moveplanesets[j][0].makenormal())) {\n          moverotations[j].push(q);\n          break;\n        }\n      }\n    }\n    this.moverotations = moverotations;\n    //  Sort the rotations by the angle of rotation.  A bit tricky because\n    //  while the norms should be the same, they need not be.  So we start\n    //  by making the norms the same, and then sorting.\n    for (let i = 0; i < moverotations.length; i++) {\n      const r = moverotations[i];\n      const goodnormal = r[0].makenormal();\n      for (let j = 0; j < r.length; j++) {\n        if (goodnormal.dist(r[j].makenormal()) > eps) {\n          r[j] = r[j].smul(-1);\n        }\n      }\n      r.sort((a, b) => a.angle() - b.angle());\n      if (moverotations[i][0].dot(moveplanesets[i][0]) < 0) {\n        r.reverse();\n      }\n    }\n    const sizes2 = moverotations.map((_) => 1 + _.length);\n    this.movesetorders = sizes2;\n    const movesetgeos = [];\n    for (let i = 0; i < moveplanesets.length; i++) {\n      const p0 = moveplanesets[i][0].makenormal();\n      let neg = null;\n      let pos = null;\n      for (let j = 0; j < this.geonormals.length; j++) {\n        const d = p0.dot(this.geonormals[j][0]);\n        if (Math.abs(d - 1) < eps) {\n          pos = [this.geonormals[j][1], this.geonormals[j][2]];\n        } else if (Math.abs(d + 1) < eps) {\n          neg = [this.geonormals[j][1], this.geonormals[j][2]];\n        }\n      }\n      if (pos === null || neg === null) {\n        throw new Error(\"Saw positive or negative sides as null\");\n      }\n      movesetgeos.push([pos[0], pos[1], neg[0], neg[1],\n      1 + moveplanesets[i].length]);\n    }\n    this.movesetgeos = movesetgeos;\n    //  Cubies are split by move plane sets.  For each cubie we can\n    //  average its points to find a point on the interior of that\n    //  cubie.  We can then check that point against all the move\n    //  planes and from that derive a coordinate for the cubie.\n    //  This also works for faces; no face should ever lie on a move\n    //  plane.  This allows us to take a set of stickers and break\n    //  them up into cubie sets.\n    const cubiehash: any = {};\n    const facelisthash: any = {};\n    const cubiekey: any = {};\n    const cubiekeys = [];\n    const cubies: Quat[][][] = [];\n    const faces = this.faces;\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      const s = this.keyface(face);\n      if (!cubiehash[s]) {\n        cubiekey[s] = cubies.length;\n        cubiekeys.push(s);\n        cubiehash[s] = [];\n        facelisthash[s] = [];\n        cubies.push(cubiehash[s]);\n      }\n      facelisthash[s].push(i);\n      cubiehash[s].push(face);\n      //  If we find a core cubie, split it up into multiple cubies,\n      //  because ksolve doesn't handle orientations that are not\n      //  cyclic, and the rotation group of the core is not cyclic.\n      if (facelisthash[s].length === this.basefacecount) {\n        if (this.verbose) { console.log(\"# Splitting core.\"); }\n        for (let suff = 0; suff < this.basefacecount; suff++) {\n          const s2 = s + \" \" + suff;\n          facelisthash[s2] = [facelisthash[s][suff]];\n          cubiehash[s2] = [cubiehash[s][suff]];\n          cubiekeys.push(s2);\n          cubiekey[s2] = cubies.length;\n          cubies.push(cubiehash[s2]);\n        }\n        cubiehash[s] = [];\n        cubies[cubiekey[s]] = [];\n      }\n    }\n    this.cubiekey = cubiekey;\n    this.facelisthash = facelisthash;\n    this.cubiekeys = cubiekeys;\n    if (this.verbose) { console.log(\"# Cubies: \" + Object.keys(cubiehash).length); }\n    const that = this;\n    function getfaceindex(facenum: number): number {\n      const divid = that.stickersperface;\n      return Math.floor(facenum / divid);\n    }\n    //  Sort the faces around each corner so they are clockwise.  Only\n    //  relevant for cubies that actually are corners (three or more\n    //  faces).  In general cubies might have many faces; for icosohedrons\n    //  there are five faces on the corner cubies.\n    this.cubies = cubies;\n    for (let k = 0; k < cubies.length; k++) {\n      const cubie = cubies[k];\n      if (cubie.length < 2) {\n        continue;\n      }\n      if (cubie.length === this.basefacecount) { // looks like core?  don't sort\n        continue;\n      }\n      if (cubie.length > 5) {\n        throw new Error(\"Bad math; too many faces on this cubie \" + cubie.length);\n      }\n      const s = this.keyface(cubie[0]);\n      const facelist = facelisthash[s];\n      const cm = cubie.map((_) => centermassface(_));\n      const cmall = centermassface(cm);\n      for (let looplimit = 0; cubie.length > 2; looplimit++) {\n        let changed = false;\n        for (let i = 0; i < cubie.length; i++) {\n          const j = (i + 1) % cubie.length;\n          // var ttt = cmall.dot(cm[i].cross(cm[j])) ; // TODO\n          if (cmall.dot(cm[i].cross(cm[j])) < 0) {\n            const t = cubie[i];\n            cubie[i] = cubie[j];\n            cubie[j] = t;\n            const u = cm[i];\n            cm[i] = cm[j];\n            cm[j] = u;\n            const v = facelist[i];\n            facelist[i] = facelist[j];\n            facelist[j] = v;\n            changed = true;\n          }\n        }\n        if (!changed) {\n          break;\n        }\n        if (looplimit > 1000) {\n          throw new Error((\"Bad epsilon math; too close to border\"));\n        }\n      }\n      let mini = 0;\n      let minf = this.findface(cubie[mini]);\n      for (let i = 1; i < cubie.length; i++) {\n        const temp = this.findface(cubie[i]);\n        if (this.faceprecedence[getfaceindex(temp)] <\n          this.faceprecedence[getfaceindex(minf)]) {\n          mini = i;\n          minf = temp;\n        }\n      }\n      if (mini !== 0) {\n        const ocubie = cubie.slice();\n        const ofacelist = facelist.slice();\n        for (let i = 0; i < cubie.length; i++) {\n          cubie[i] = ocubie[(mini + i) % cubie.length];\n          facelist[i] = ofacelist[(mini + i) % cubie.length];\n        }\n      }\n    }\n    //  Build an array that takes each face to a cubie ordinal and a\n    //  face number.\n    const facetocubies = [];\n    for (let i = 0; i < cubies.length; i++) {\n      const facelist = facelisthash[cubiekeys[i]];\n      for (let j = 0; j < facelist.length; j++) {\n        facetocubies[facelist[j]] = [i, j];\n      }\n    }\n    this.facetocubies = facetocubies;\n    //  Calculate the orbits of each cubie.  Assumes we do all moves.\n    //  Also calculates which cubies are identical.\n    const typenames = [\"?\", \"CENTER\", \"EDGE\", \"CORNER\", \"C4RNER\", \"C5RNER\"];\n    const cubiesetnames = [];\n    const cubietypecounts = [0, 0, 0, 0, 0, 0];\n    const orbitoris = [];\n    const seen = [];\n    let cubiesetnum = 0;\n    const cubiesetnums = [];\n    const cubieordnums = [];\n    const cubieords = [];\n    // var cubiesetnumhash = {} ; // TODO\n    const cubievaluemap = [];\n    // Later we will make this smarter to use a get color for face function\n    // so we support puzzles with multiple faces the same color\n    function getcolorkey(cubienum: number): string {\n      return cubies[cubienum].map(\n        (_) => getfaceindex(that.findface(_))).join(\" \");\n    }\n    const cubiesetcubies: any = [];\n    for (let i = 0; i < cubies.length; i++) {\n      if (seen[i]) {\n        continue;\n      }\n      const cubie = cubies[i];\n      if (cubie.length === 0) {\n        continue;\n      }\n      const cubiekeymap: any = {};\n      let cubievalueid = 0;\n      cubieords.push(0);\n      cubiesetcubies.push([]);\n      const facecnt = cubie.length;\n      const typectr = cubietypecounts[facecnt]++;\n      let typename = typenames[facecnt];\n      if (typename === undefined || facecnt === this.basefacecount) {\n        typename = \"CORE\";\n      }\n      typename = typename + (typectr === 0 ? \"\" : (typectr + 1));\n      cubiesetnames[cubiesetnum] = typename;\n      orbitoris[cubiesetnum] = facecnt;\n      const queue = [i];\n      let qg = 0;\n      seen[i] = true;\n      while (qg < queue.length) {\n        const cind = queue[qg++];\n        const cubiecolorkey = getcolorkey(cind);\n        if (cubie.length > 1 || cubiekeymap[cubiecolorkey] === undefined) {\n          cubiekeymap[cubiecolorkey] = cubievalueid++;\n        }\n        cubievaluemap[cind] = cubiekeymap[cubiecolorkey];\n        cubiesetnums[cind] = cubiesetnum;\n        cubiesetcubies[cubiesetnum].push(cind);\n        cubieordnums[cind] = cubieords[cubiesetnum]++;\n        for (let j = 0; j < moverotations.length; j++) {\n          const tq = this.findcubie(moverotations[j][0].rotateface(cubies[cind][0]));\n          if (!seen[tq]) {\n            queue.push(tq);\n            seen[tq] = true;\n          }\n        }\n      }\n      cubiesetnum++;\n    }\n    this.orbits = cubieords.length;\n    this.cubiesetnums = cubiesetnums;\n    this.cubieordnums = cubieordnums;\n    this.cubiesetnames = cubiesetnames;\n    this.cubieords = cubieords;\n    this.orbitoris = orbitoris;\n    this.cubievaluemap = cubievaluemap;\n    this.cubiesetcubies = cubiesetcubies;\n    // if we fix a cubie, find a cubie to fix\n    if (this.fixPiece !== \"\") {\n      for (let i = 0; i < cubies.length; i++) {\n        if ((this.fixPiece === \"v\" && cubies[i].length > 2) ||\n          (this.fixPiece === \"e\" && cubies[i].length === 2) ||\n          (this.fixPiece === \"f\" && cubies[i].length === 1)) {\n          this.fixedCubie = i;\n          break;\n        }\n      }\n      if (this.fixedCubie < 0) {\n        throw new Error(\"Could not find a cubie of type \" + this.fixPiece + \" to fix.\");\n      }\n    }\n    // show the orbits\n    if (this.verbose) { console.log(\"# Cubie orbit sizes \" + cubieords); }\n  }\n\n  public spinmatch(a: string, b: string): boolean {\n    // are these the same rotationally?\n    if (a === b) {\n      return true;\n    }\n    if (a.length !== b.length) {\n      return false;\n    }\n    try {\n      const e1 = splitByFaceNames(a, this.facenames);\n      const e2 = splitByFaceNames(b, this.facenames);\n      if (e1.length !== e2.length) {\n        return false;\n      }\n      for (let i = 0; i < e1.length; i++) {\n        if (e1[i] === e2[0]) {\n          for (let j = 0; j < e2.length; j++) {\n            if (e1[(i + j) % e1.length] !== e2[j]) {\n              return false;\n            }\n          }\n          return true;\n        }\n      }\n      return false;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  public parsemove(mv: string): any { // parse a move from the command line\n    const re = RegExp(\"^(([0-9]+)-)?([0-9]+)?([A-Za-z]+)([-'0-9]+)?$\");\n    const p = mv.match(re);\n    if (p === null) {\n      throw new Error(\"Bad move passed \" + mv);\n    }\n    let grip = p[4];\n    let fullrotation = false;\n    if (grip.endsWith(\"v\") && grip[0] <= \"Z\") {\n      if (p[2] !== undefined || p[3] !== undefined) {\n        throw new Error(\"Cannot use a prefix with full cube rotations\");\n      }\n      grip = grip.slice(0, -1);\n      fullrotation = true;\n    }\n    let geo;\n    let msi = -1;\n    const upperCaseGrip = grip.toUpperCase();\n    let firstgrip = false;\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const g = this.movesetgeos[i];\n      if (this.spinmatch(g[0], upperCaseGrip)) {\n        firstgrip = true;\n        geo = g;\n        msi = i;\n      }\n      if (this.spinmatch(g[2], upperCaseGrip)) {\n        firstgrip = false;\n        geo = g;\n        msi = i;\n      }\n    }\n    let loslice = 1;\n    let hislice = 1;\n    if (upperCaseGrip !== grip) {\n      hislice = 2;\n    }\n    if (geo === undefined) {\n      throw new Error(\"Bad grip in move \" + mv);\n    }\n    if (p[2] !== undefined) {\n      if (p[3] === undefined) {\n        throw new Error(\"Missing second number in range\");\n      }\n      loslice = parseInt(p[2], 10);\n    }\n    if (p[3] !== undefined) {\n      if (p[2] === undefined) {\n        hislice = parseInt(p[3], 10);\n        if (upperCaseGrip === grip) {\n          loslice = hislice;\n        } else {\n          loslice = 1;\n        }\n      } else {\n        hislice = parseInt(p[3], 10);\n      }\n    }\n    loslice--;\n    hislice--;\n    if (fullrotation) {\n      loslice = 0;\n      hislice = this.moveplanesets[msi].length;\n    }\n    if (loslice < 0 || loslice > this.moveplanesets[msi].length ||\n      hislice < 0 || hislice > this.moveplanesets[msi].length) {\n      throw new Error(\"Bad slice spec \" + loslice + \" \" + hislice);\n    }\n    let amountstr = \"1\";\n    let amount = 1;\n    if (p[5] !== undefined) {\n      amountstr = p[5];\n      if (amountstr[0] === \"'\") {\n        amountstr = \"-\" + amountstr.substring(1);\n      }\n      if (amountstr[0] === \"+\") {\n        amountstr = amountstr.substring(1);\n      } else if (amountstr[0] === \"-\") {\n        if (amountstr === \"-\") {\n          amountstr = \"-1\";\n        }\n      }\n      amount = parseInt(amountstr, 10);\n    }\n    const r = [mv, msi, loslice, hislice, firstgrip, amount];\n    return r;\n  }\n\n  public genperms(): void { // generate permutations for moves\n    if (this.cmovesbyslice.length > 0) { // did this already?\n      return;\n    }\n    const movesbyslice = [];\n    const cmovesbyslice = [];\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveplaneset = this.moveplanesets[k];\n      const slicenum = [];\n      const slicecnts = [];\n      for (let i = 0; i < this.faces.length; i++) {\n        const face = this.faces[i];\n        let t = 0;\n        for (let j = 0; j < moveplaneset.length; j++) {\n          if (moveplaneset[j].faceside(face) < 0) {\n            t++;\n          }\n        }\n        slicenum.push(t);\n        while (slicecnts.length <= t) {\n          slicecnts.push(0);\n        }\n        slicecnts[t]++;\n      }\n      const axismoves = [];\n      const axiscmoves = [];\n      for (let sc = 0; sc < slicecnts.length; sc++) {\n        const slicemoves = [];\n        const slicecmoves = [];\n        const cubiedone = [];\n        for (let i = 0; i < this.faces.length; i++) {\n          if (slicenum[i] !== sc) {\n            continue;\n          }\n          const a = [i];\n          const b = this.facetocubies[i].slice();\n          let face = this.faces[i];\n          let fi2 = i;\n          while (true) {\n            slicenum[fi2] = -1;\n            const face2 = this.moverotations[k][0].rotateface(face);\n            fi2 = this.findface(face2);\n            if (slicenum[fi2] < 0) {\n              break;\n            }\n            if (slicenum[fi2] !== sc) {\n              throw new Error(\"Bad movement?\");\n            }\n            a.push(fi2);\n            const c = this.facetocubies[fi2];\n            b.push(c[0], c[1]);\n            face = face2;\n          }\n          if (a.length === 1 && this.orientCenters) {\n            for (let ii = 1; ii < this.movesetorders[k]; ii++) {\n              a.push(a[0]);\n              b.push(b[0], ii);\n              // <><>\n              this.cubies[b[0]].push(this.cubies[b[0]][0]);\n            }\n            this.duplicatedFaces[a[0]] = this.movesetorders[k];\n            this.duplicatedCubies[b[0]] = this.movesetorders[k];\n            this.orbitoris[this.cubiesetnums[b[0]]] = this.movesetorders[k];\n          }\n          if (a.length > 1) {\n            slicemoves.push(a);\n          }\n          if (b.length > 2 && !cubiedone[b[0]]) {\n            slicecmoves.push(b);\n          }\n          for (let j = 0; j < b.length; j += 2) {\n            cubiedone[b[j]] = true;\n          }\n        }\n        axismoves.push(slicemoves);\n        axiscmoves.push(slicecmoves);\n      }\n      movesbyslice.push(axismoves);\n      cmovesbyslice.push(axiscmoves);\n    }\n    this.movesbyslice = movesbyslice;\n    this.cmovesbyslice = cmovesbyslice;\n    if (this.movelist !== undefined) {\n      const parsedmovelist: any[] = [];\n      // make sure the movelist makes sense based on the geos.\n      for (let i = 0; i < this.movelist.length; i++) {\n        parsedmovelist.push(this.parsemove(this.movelist[i]));\n      }\n      this.parsedmovelist = parsedmovelist;\n    }\n  }\n\n  public getfaces(): number[][][] { // get the faces for 3d.\n    return this.faces.map((_) => {\n      return _.map((__) => [__.b, __.c, __.d]);\n    });\n  }\n\n  public getboundarygeometry(): any { // get the boundary geometry\n    return {\n      baseplanes: this.baseplanes,\n      facenames: this.facenames,\n      faceplanes: this.faceplanes,\n      vertexnames: this.vertexnames,\n      edgenames: this.edgenames,\n      geonormals: this.geonormals,\n    };\n  }\n\n  public getmovesets(k: number): any {\n    // get the move sets we support based on slices\n    // for even values we omit the middle \"slice\".  This isn't perfect\n    // but it is what we do for now.\n    // if there was a move list specified, pull values from that\n    const slices = this.moveplanesets[k].length;\n    if (slices > 30) {\n      throw new Error(\"Too many slices for getmovesets bitmasks\");\n    }\n    let r = [];\n    if (this.parsedmovelist !== undefined) {\n      for (let i = 0; i < this.parsedmovelist.length; i++) {\n        const parsedmove = this.parsedmovelist[i];\n        if (parsedmove[1] !== k) {\n          continue;\n        }\n        if (parsedmove[4]) {\n          r.push((2 << parsedmove[3]) - (1 << parsedmove[2]));\n        } else {\n          r.push((2 << (slices - parsedmove[2])) - (1 << (slices - parsedmove[3])));\n        }\n        r.push(parsedmove[5]);\n      }\n    } else if (this.vertexmoves && !this.allmoves) {\n      const msg = this.movesetgeos[k];\n      if (msg[1] !== msg[3]) {\n        for (let i = 0; i < slices; i++) {\n          if (msg[1] !== \"v\") {\n            if (this.outerblockmoves) {\n              r.push((2 << slices) - (2 << i));\n            } else {\n              r.push(2 << i);\n            }\n            r.push(1);\n          } else {\n            if (this.outerblockmoves) {\n              r.push((2 << i) - 1);\n            } else {\n              r.push(1 << i);\n            }\n            r.push(1);\n          }\n        }\n      }\n    } else {\n      for (let i = 0; i <= slices; i++) {\n        if (!this.allmoves && i + i === slices) {\n          continue;\n        }\n        if (this.outerblockmoves) {\n          if (i + i > slices) {\n            r.push((2 << slices) - (1 << i));\n          } else {\n            r.push((2 << i) - 1);\n          }\n        } else {\n          r.push(1 << i);\n        }\n        r.push(1);\n      }\n    }\n    if (this.fixedCubie >= 0) {\n      const dep = 1 << +this.cubiekeys[this.fixedCubie].trim().split(\" \")[k];\n      const newr = [];\n      for (let i = 0; i < r.length; i += 2) {\n        let o = r[i];\n        if (o & dep) {\n          o = (2 << slices) - 1 - o;\n        }\n        let found = false;\n        for (let j = 0; j < newr.length; j += 2) {\n          if (newr[j] === o && newr[j + 1] === r[i + 1]) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          newr.push(o);\n          newr.push(r[i + 1]);\n        }\n      }\n      r = newr;\n    }\n    if (this.addrotations) {\n      r.push((2 << slices) - 1);\n      r.push(1);\n    }\n    return r;\n  }\n\n  public graybyori(cubie: number): boolean {\n    let ori = this.cubies[cubie].length;\n    if (this.duplicatedCubies[cubie]) {\n      ori = 1;\n    }\n    return ((ori === 1 && (this.graycenters || !this.centersets)) ||\n      (ori === 2 && (this.grayedges || !this.edgesets)) ||\n      (ori > 2 && (this.graycorners || !this.cornersets)));\n  }\n\n  public skipbyori(cubie: number): boolean {\n    let ori = this.cubies[cubie].length;\n    if (this.duplicatedCubies[cubie]) {\n      ori = 1;\n    }\n    return ((ori === 1 && !this.centersets) ||\n      (ori === 2 && !this.edgesets) ||\n      (ori > 2 && !this.cornersets));\n  }\n\n  public skipcubie(set: number[]): boolean {\n    if (set.length === 0) {\n      return true;\n    }\n    const fi = set[0];\n    return this.skipbyori(fi);\n  }\n\n  public skipset(set: number[]): boolean {\n    if (set.length === 0) {\n      return true;\n    }\n    const fi = set[0];\n    return this.skipbyori(this.facetocubies[fi][0]);\n  }\n\n  public header(comment: string): string {\n    return comment + copyright + \"\\n\" +\n      comment + this.args + \"\\n\";\n  }\n\n  public writegap(): string { // write out a gap set of generators\n    const os = this.getOrbitsDef(false);\n    const r = [];\n    const mvs = [];\n    for (let i = 0; i < os.moveops.length; i++) {\n      const movename = \"M_\" + os.movenames[i];\n      // gap doesn't like angle brackets in IDs\n      mvs.push(movename);\n      r.push(movename + \":=\" + os.moveops[i].toPerm().toGap() + \";\");\n    }\n    r.push(\"Gen:=[\");\n    r.push(mvs.join(\",\"));\n    r.push(\"];\");\n    const ip = os.solved.identicalPieces();\n    r.push(\"ip:=[\" + ip.map((_) => \"[\" + _.map((__) => __ + 1).join(\",\") + \"]\").\n      join(\",\") + \"];\");\n    r.push(\"\");\n    return this.header(\"# \") + r.join(\"\\n\");\n  }\n\n  public writeksolve(name: string = \"PuzzleGeometryPuzzle\", fortwisty: boolean = false): string {\n    const od = this.getOrbitsDef(fortwisty);\n    if (fortwisty) {\n      return od.toKsolve(name, fortwisty).join(\"\\n\");\n    } else {\n      return this.header(\"# \") + od.toKsolve(name, fortwisty).join(\"\\n\");\n    }\n  }\n  public writekpuzzle(): any {\n    return this.getOrbitsDef(true).toKpuzzle();\n  }\n\n  public getOrbitsDef(fortwisty: boolean): OrbitsDef {\n    // generate a representation of the puzzle\n    const setmoves = [];\n    const setnames: string[] = [];\n    const setdefs: OrbitDef[] = [];\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveset = this.getmovesets(k);\n      // check there's no redundancy in moveset.\n      for (let i = 0; i < moveset.length; i += 2) {\n        for (let j = 0; j < i; j += 2) {\n          if (moveset[i] === moveset[j] && moveset[i + 1] === moveset[j + 1]) {\n            throw new Error(\"Redundant moves in moveset.\");\n          }\n        }\n      }\n      let allbits = 0;\n      for (let i = 0; i < moveset.length; i += 2) {\n        allbits |= moveset[i];\n      }\n      const axiscmoves = this.cmovesbyslice[k];\n      for (let i = 0; i < axiscmoves.length; i++) {\n        if (((allbits >> i) & 1) === 0) {\n          continue;\n        }\n        const slicecmoves = axiscmoves[i];\n        for (let j = 0; j < slicecmoves.length; j++) {\n          if (this.skipcubie(slicecmoves[j])) {\n            continue;\n          }\n          const ind = this.cubiesetnums[slicecmoves[j][0]];\n          setmoves[ind] = 1;\n        }\n      }\n    }\n    for (let i = 0; i < this.cubiesetnames.length; i++) {\n      if (!setmoves[i]) {\n        continue;\n      }\n      setnames.push(this.cubiesetnames[i]);\n      setdefs.push(new OrbitDef(this.cubieords[i],\n        this.killorientation ? 1 : this.orbitoris[i]));\n    }\n    const solved: Orbit[] = [];\n    for (let i = 0; i < this.cubiesetnames.length; i++) {\n      if (!setmoves[i]) {\n        continue;\n      }\n      const p = [];\n      const o = [];\n      for (let j = 0; j < this.cubieords[i]; j++) {\n        if (fortwisty) {\n          p.push(j);\n        } else {\n          const cubie = this.cubiesetcubies[i][j];\n          p.push(this.cubievaluemap[cubie]);\n        }\n        o.push(0);\n      }\n      solved.push(new Orbit(p, o,\n        this.killorientation ? 1 : this.orbitoris[i]));\n    }\n    const movenames: string[] = [];\n    const moves: Transformation[] = [];\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveplaneset = this.moveplanesets[k];\n      const slices = moveplaneset.length;\n      const moveset = this.getmovesets(k);\n      const movesetgeo = this.movesetgeos[k];\n      for (let i = 0; i < moveset.length; i += 2) {\n        const movebits = moveset[i];\n        const mna = getmovename(movesetgeo, movebits, slices);\n        const movename = mna[0];\n        const inverted = mna[1];\n        movenames.push(movename);\n        const moveorbits: Orbit[] = [];\n        const perms = [];\n        const oris = [];\n        for (let ii = 0; ii < this.cubiesetnames.length; ii++) {\n          const p = [];\n          for (let kk = 0; kk < this.cubieords[ii]; kk++) {\n            p.push(kk);\n          }\n          perms.push(p);\n          const o = [];\n          for (let kk = 0; kk < this.cubieords[ii]; kk++) {\n            o.push(0);\n          }\n          oris.push(o);\n        }\n        const axiscmoves = this.cmovesbyslice[k];\n        for (let m = 0; m < axiscmoves.length; m++) {\n          if (((movebits >> m) & 1) === 0) {\n            continue;\n          }\n          const slicecmoves = axiscmoves[m];\n          for (let j = 0; j < slicecmoves.length; j++) {\n            const mperm = slicecmoves[j].slice();\n            const setnum = this.cubiesetnums[mperm[0]];\n            for (let ii = 0; ii < mperm.length; ii += 2) {\n              mperm[ii] = this.cubieordnums[mperm[ii]];\n            }\n            let inc = 2;\n            let oinc = 3;\n            if (inverted) {\n              inc = mperm.length - 2;\n              oinc = mperm.length - 1;\n            }\n            for (let ii = 0; ii < mperm.length; ii += 2) {\n              perms[setnum][mperm[(ii + inc) % mperm.length]] = mperm[ii];\n              if (this.killorientation) {\n                oris[setnum][mperm[ii]] = 0;\n              } else {\n                oris[setnum][mperm[ii]] =\n                  (mperm[(ii + oinc) % mperm.length] -\n                    mperm[(ii + 1) % mperm.length] +\n                    this.orbitoris[setnum]) % this.orbitoris[setnum];\n              }\n            }\n          }\n        }\n        for (let ii = 0; ii < this.cubiesetnames.length; ii++) {\n          if (!setmoves[ii]) {\n            continue;\n          }\n          const no = new Array<number>(oris[ii].length);\n          // convert ksolve oris to our internal ori rep\n          for (let jj = 0; jj < perms[ii].length; jj++) {\n            no[jj] = oris[ii][perms[ii][jj]];\n          }\n          moveorbits.push(new Orbit(perms[ii], no,\n            this.killorientation ? 1 : this.orbitoris[ii]));\n        }\n        let mv = new Transformation(moveorbits);\n        if (moveset[i + 1] !== 1) {\n          mv = mv.mulScalar(moveset[i + 1]);\n        }\n        moves.push(mv);\n      }\n    }\n    this.ksolvemovenames = movenames; // hack!\n    let r = new OrbitsDef(setnames, setdefs, new VisibleState(solved),\n      movenames, moves);\n    if (this.optimize) {\n      r = r.optimize();\n    }\n    if (this.scramble !== 0) {\n      r.scramble(this.scramble);\n    }\n    return r;\n  }\n\n  public getMovesAsPerms(): Perm[] {\n    return this.getOrbitsDef(false).moveops.\n      map((_: Transformation) => _.toPerm());\n  }\n\n  public showcanon(disp: (s: string) => void): void {\n    // show information for canonical move derivation\n    showcanon(this.getOrbitsDef(false), disp);\n  }\n\n  public getsolved(): Perm { // get a solved position\n    const r = [];\n    for (let i = 0; i < this.basefacecount; i++) {\n      for (let j = 0; j < this.stickersperface; j++) {\n        r.push(i);\n      }\n    }\n    return new Perm(r);\n  }\n\n  public getInitial3DRotation() {\n    const basefacecount = this.basefacecount;\n    if (basefacecount === 4) {\n      return new Quat(0.7043069543230507, 0.0617237605829268,\n        0.4546068756768417, 0.5417328493446099);\n    } else if (basefacecount === 6) {\n      return new Quat(0.3419476009844782, 0.17612448544695208,\n        -0.42284908551877964, 0.8205185279339757);\n    } else if (basefacecount === 8) {\n      return new Quat(-0.6523285484575103, 0.2707374015470506,\n        0.6537994145576647, 0.27150515611112014);\n    } else if (basefacecount === 12) {\n      return new Quat(-0.5856747836703331, 0.02634133605619232,\n        0.7075560342412421, 0.39453217891103587);\n    } else if (basefacecount === 20) {\n      return new Quat(0.7052782621769977, 0.6377976252204238,\n        0.30390357803973855, 0.05864620549043545);\n    } else {\n      throw new Error(\"Wrong base face count\");\n    }\n  }\n\n  public generatesvg(w: number = 800, h: number = 500, trim: number = 10, threed: boolean = false): string {\n    // generate svg to interoperate with Lucas twistysim\n    w -= 2 * trim;\n    h -= 2 * trim;\n    function extendedges(a: number[][], n: number): void {\n      let dx = a[1][0] - a[0][0];\n      let dy = a[1][1] - a[0][1];\n      const ang = 2 * Math.PI / n;\n      const cosa = Math.cos(ang);\n      const sina = Math.sin(ang);\n      for (let i = 2; i < n; i++) {\n        const ndx = dx * cosa + dy * sina;\n        dy = dy * cosa - dx * sina;\n        dx = ndx;\n        a.push([a[i - 1][0] + dx, a[i - 1][1] + dy]);\n      }\n    }\n    // if we don't add this noise to coordinate values, then Safari\n    // doesn't render our polygons correctly.  What a hack.\n    function noise(c: number): number {\n      return c + 0 * (Math.random() - 0.5);\n    }\n    function drawedges(id: string, pts: number[][], color: string)\n      : string {\n      return \"<polygon id=\\\"\" + id + \"\\\" class=\\\"sticker\\\" style=\\\"fill: \" + color +\n        \"\\\" points=\\\"\" +\n        pts.map((p) => noise(p[0]) + \" \" + noise(p[1])).join(\" \") +\n        \"\\\"/>\\n\";\n    }\n    // What grips do we need?  if rotations, add all grips.\n    let needvertexgrips = this.addrotations;\n    let neededgegrips = this.addrotations;\n    let needfacegrips = this.addrotations;\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const msg = this.movesetgeos[i];\n      for (let j = 1; j <= 3; j += 2) {\n        if (msg[j] === \"v\") {\n          needvertexgrips = true;\n        }\n        if (msg[j] === \"f\") {\n          needfacegrips = true;\n        }\n        if (msg[j] === \"e\") {\n          neededgegrips = true;\n        }\n      }\n    }\n    // Find a net from a given face count.  Walk it, assuming we locate\n    // the first edge from (0,0) to (1,1) and compute the minimum and\n    // maximum vertex locations from this.  Then do a second walk, and\n    // assign the actual geometry.\n    this.genperms();\n    const boundarygeo = this.getboundarygeometry();\n    const face0 = boundarygeo.facenames[0][0];\n    const polyn = face0.length; // number of vertices; 3, 4, or 5\n    const net = this.net;\n    if (net === null) {\n      throw new Error(\"No net?\");\n    }\n    const edges: any = {};\n    let minx = 0;\n    let miny = 0;\n    let maxx = 1;\n    let maxy = 0;\n    edges[net[0][0]] = [[1, 0], [0, 0]];\n    extendedges(edges[net[0][0]], polyn);\n    for (let i = 0; i < net.length; i++) {\n      const f0 = net[i][0];\n      if (!edges[f0]) {\n        throw new Error(\"Bad edge description; first edge not connected.\");\n      }\n      for (let j = 1; j < net[i].length; j++) {\n        const f1 = net[i][j];\n        if (f1 === \"\" || edges[f1]) {\n          continue;\n        }\n        edges[f1] = [edges[f0][j % polyn], edges[f0][(j + polyn - 1) % polyn]];\n        extendedges(edges[f1], polyn);\n      }\n    }\n    for (const f in edges) {\n      const es = edges[f];\n      for (let i = 0; i < es.length; i++) {\n        minx = Math.min(minx, es[i][0]);\n        maxx = Math.max(maxx, es[i][0]);\n        miny = Math.min(miny, es[i][1]);\n        maxy = Math.max(maxy, es[i][1]);\n      }\n    }\n    const sc = Math.min(w / (maxx - minx), h / (maxy - miny));\n    const xoff = 0.5 * (w - sc * (maxx + minx));\n    const yoff = 0.5 * (h - sc * (maxy + miny));\n    const geos: any = {};\n    const bg = this.getboundarygeometry();\n    const edges2: any = {};\n    const initv = [[sc + xoff, yoff], [xoff, yoff]];\n    edges2[net[0][0]] = initv;\n    extendedges(edges2[net[0][0]], polyn);\n    geos[this.facenames[0][1]] = this.project2d(0, 0,\n      [new Quat(0, initv[0][0], initv[0][1], 0),\n      new Quat(0, initv[1][0], initv[1][1], 0)]);\n    const connectat = [];\n    connectat[0] = 0;\n    for (let i = 0; i < net.length; i++) {\n      const f0 = net[i][0];\n      if (!edges2[f0]) {\n        throw new Error(\"Bad edge description; first edge not connected.\");\n      }\n      let gfi = -1;\n      for (let j = 0; j < bg.facenames.length; j++) {\n        if (f0 === bg.facenames[j][1]) {\n          gfi = j;\n          break;\n        }\n      }\n      if (gfi < 0) {\n        throw new Error(\"Could not find first face name \" + f0);\n      }\n      const thisface = bg.facenames[gfi][0];\n      for (let j = 1; j < net[i].length; j++) {\n        const f1 = net[i][j];\n        if (f1 === \"\" || edges2[f1]) {\n          continue;\n        }\n        edges2[f1] = [edges2[f0][j % polyn], edges2[f0][(j + polyn - 1) % polyn]];\n        extendedges(edges2[f1], polyn);\n        // what edge are we at?\n        const caf0 = connectat[gfi];\n        const mp = thisface[(caf0 + j) % polyn].sum(thisface[(caf0 + j + polyn - 1) % polyn]).smul(0.5);\n        const epi = findelement(bg.edgenames, mp);\n        const edgename = bg.edgenames[epi][1];\n        const el = splitByFaceNames(edgename, this.facenames);\n        const gf1 = el[(f0 === el[0]) ? 1 : 0];\n        let gf1i = -1;\n        for (let k = 0; k < bg.facenames.length; k++) {\n          if (gf1 === bg.facenames[k][1]) {\n            gf1i = k;\n            break;\n          }\n        }\n        if (gf1i < 0) {\n          throw new Error(\"Could not find second face name\");\n        }\n        const otherface = bg.facenames[gf1i][0];\n        for (let k = 0; k < otherface.length; k++) {\n          const mp2 = otherface[k].sum(otherface[(k + 1) % polyn]).smul(0.5);\n          if (mp2.dist(mp) <= eps) {\n            const p1 = edges2[f0][(j + polyn - 1) % polyn];\n            const p2 = edges2[f0][j % polyn];\n            connectat[gf1i] = k;\n            geos[gf1] = this.project2d(gf1i, k,\n              [new Quat(0, p2[0], p2[1], 0), new Quat(0, p1[0], p1[1], 0)]);\n            break;\n          }\n        }\n      }\n    }\n    // Let's build arrays for faster rendering.  We want to map from geo\n    // base face number to color, and we want to map from geo face number\n    // to 2D geometry.  These can be reused as long as the puzzle overall\n    // orientation and canvas size remains unchanged.\n    const pos = this.getsolved();\n    const colormap = [];\n    const facegeo = [];\n    for (let i = 0; i < this.basefacecount; i++) {\n      colormap[i] = this.colors[this.facenames[i][1]];\n    }\n    let hix = 0;\n    let hiy = 0;\n    const rot = this.getInitial3DRotation();\n    for (let i = 0; i < this.faces.length; i++) {\n      let face = this.faces[i];\n      face = rot.rotateface(face);\n      for (let j = 0; j < face.length; j++) {\n        hix = Math.max(hix, Math.abs(face[j].b));\n        hiy = Math.max(hiy, Math.abs(face[j].c));\n      }\n    }\n    const sc2 = Math.min(h / hiy / 2, (w - trim) / hix / 4);\n    const that = this;\n    function mappt2d(fn: number, q: Quat): number[] {\n      if (threed) {\n        const xoff2 = 0.5 * trim + 0.25 * w;\n        const xmul = (that.baseplanes[fn].rotateplane(rot).d < 0 ? 1 : -1);\n        return [trim + w * 0.5 + xmul * (xoff2 - q.b * sc2), trim + h * 0.5 + q.c * sc2];\n      } else {\n        const g = geos[that.facenames[fn][1]];\n        return [trim + q.dot(g[0]) + g[2].b, trim + h - q.dot(g[1]) - g[2].c];\n      }\n    }\n    for (let i = 0; i < this.faces.length; i++) {\n      let face = that.faces[i];\n      const facenum = Math.floor(i / that.stickersperface);\n      if (threed) {\n        face = rot.rotateface(face);\n      }\n      facegeo.push(face.map((_: Quat) => mappt2d(facenum, _)));\n    }\n    const svg = [];\n    // group each base face so we can add a hover element\n    for (let j = 0; j < this.basefacecount; j++) {\n      svg.push(\"<g>\");\n      svg.push(\"<title>\" + this.facenames[j][1] + \"</title>\\n\");\n      for (let ii = 0; ii < this.stickersperface; ii++) {\n        const i = j * this.stickersperface + ii;\n        const cubie = this.facetocubies[i][0];\n        const cubieori = this.facetocubies[i][1];\n        const cubiesetnum = this.cubiesetnums[cubie];\n        const cubieord = this.cubieordnums[cubie];\n        const color = this.graybyori(cubie) ? \"#808080\" : colormap[pos.p[i]];\n        let id = this.cubiesetnames[cubiesetnum] +\n          \"-l\" + cubieord + \"-o\" + cubieori;\n        svg.push(drawedges(id, facegeo[i], color));\n        if (this.duplicatedFaces[i]) {\n          for (let jj = 1; jj < this.duplicatedFaces[i]; jj++) {\n            id = this.cubiesetnames[cubiesetnum] +\n              \"-l\" + cubieord + \"-o\" + jj;\n            svg.push(drawedges(id, facegeo[i], color));\n          }\n        }\n      }\n      svg.push(\"</g>\");\n    }\n    const svggrips: any[] = [];\n    function addgrip(onface: number, name: string, pt: Quat, order: number): void {\n      const pt2 = mappt2d(onface, pt);\n      for (let i = 0; i < svggrips.length; i++) {\n        if (Math.hypot(pt2[0] - svggrips[i][0], pt2[1] - svggrips[i][1]) < eps) {\n          return;\n        }\n      }\n      svggrips.push([pt2[0], pt2[1], name, order]);\n    }\n    for (let i = 0; i < this.faceplanes.length; i++) {\n      const baseface = this.facenames[i][0];\n      let facecoords = baseface;\n      if (threed) {\n        facecoords = rot.rotateface(facecoords);\n      }\n      if (needfacegrips) {\n        let pt = this.faceplanes[i][0];\n        if (threed) {\n          pt = pt.rotatepoint(rot);\n        }\n        addgrip(i, this.faceplanes[i][1], pt, polyn);\n      }\n      for (let j = 0; j < baseface.length; j++) {\n        if (neededgegrips) {\n          const mp = baseface[j].sum(\n            baseface[(j + 1) % baseface.length]).smul(0.5);\n          const ep = findelement(this.edgenames, mp);\n          const mpc = facecoords[j].sum(\n            facecoords[(j + 1) % baseface.length]).smul(0.5);\n          addgrip(i, this.edgenames[ep][1], mpc, 2);\n        }\n        if (needvertexgrips) {\n          const vp = findelement(\n            this.vertexnames, baseface[j]);\n          addgrip(i, this.vertexnames[vp][1], facecoords[j],\n            this.cornerfaces);\n        }\n      }\n    }\n    const html = '<svg id=\"svg\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 800 500\">\\n' +\n      '<style type=\"text/css\"><![CDATA[' +\n      \".sticker { stroke: #000000; stroke-width: 1px; }\" +\n      \"]]></style>\\n\" +\n      svg.join(\"\") + \"</svg>\";\n    this.svggrips = svggrips;\n    return html;\n  }\n\n  public get3d(trim?: number): StickerDat {\n    const stickers: any = [];\n    const rot = this.getInitial3DRotation();\n    const faces: any = [];\n    const maxdist: number = 0.52 * this.basefaces[0][0].len();\n    for (let i = 0; i < this.basefaces.length; i++) {\n      const coords = rot.rotateface(this.basefaces[i]);\n      const name = this.facenames[i][1];\n      faces.push({ coords: toFaceCoords(coords, maxdist), name });\n    }\n    for (let i = 0; i < this.faces.length; i++) {\n      const facenum = Math.floor(i / this.stickersperface);\n      const cubie = this.facetocubies[i][0];\n      const cubieori = this.facetocubies[i][1];\n      const cubiesetnum = this.cubiesetnums[cubie];\n      const cubieord = this.cubieordnums[cubie];\n      const color = this.graybyori(cubie) ? \"#808080\" :\n        this.colors[this.facenames[facenum][1]];\n      let coords = rot.rotateface(this.faces[i]);\n      if (trim && trim > 0) {\n        coords = trimEdges(coords, trim);\n      }\n      stickers.push({\n        coords: toFaceCoords(coords, maxdist),\n        color, orbit: this.cubiesetnames[cubiesetnum],\n        ord: cubieord, ori: cubieori,\n      });\n      if (this.duplicatedFaces[i]) {\n        for (let jj = 1; jj < this.duplicatedFaces[i]; jj++) {\n          stickers.push({\n            coords: toFaceCoords(coords, maxdist),\n            color, orbit: this.cubiesetnames[cubiesetnum],\n            ord: cubieord, ori: jj,\n          });\n        }\n      }\n    }\n    const grips: StickerDatAxis[] = [];\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const msg = this.movesetgeos[i];\n      const order = this.movesetorders[i];\n      for (let j = 0; j < this.geonormals.length; j++) {\n        const gn = this.geonormals[j];\n        if (msg[0] === gn[1] && msg[1] === gn[2]) {\n          grips.push([toCoords(gn[0].rotatepoint(rot), 1),\n          msg[0], order]);\n          grips.push([toCoords(gn[0].rotatepoint(rot).smul(-1), 1),\n          msg[2], order]);\n        }\n      }\n    }\n    return { stickers, faces, axis: grips };\n  }\n}\n","import { identity, Perm } from \"./Perm\";\n\nclass FactoredNumber {\n  public mult: number[];\n  constructor() {\n    this.mult = [];\n  }\n\n  public multiply(n: number): void {\n    for (let f = 2; f * f <= n; f++) {\n      while (n % f === 0) {\n        if (undefined !== this.mult[f]) {\n          this.mult[f]++;\n        } else {\n          this.mult[f] = 1;\n        }\n        n /= f;\n      }\n    }\n    if (n > 1) {\n      if (undefined !== this.mult[n]) {\n        this.mult[n]++;\n      } else {\n        this.mult[n] = 1;\n      }\n    }\n  }\n\n  public toString(): string {\n    let r = \"\";\n    for (let i = 0; i < this.mult.length; i++) {\n      if (undefined !== this.mult[i]) {\n        if (r !== \"\") {\n          r += \"*\";\n        }\n        r += i;\n        if (this.mult[i] > 1) {\n          r += \"^\" + this.mult[i];\n        }\n      }\n    }\n    return r;\n  }\n}\n\nexport function schreierSims(g: Perm[], disp: (s: string) => void): number {\n  const n = g[0].p.length;\n  const e = identity(n);\n  let sgs: Perm[][] = [];\n  let sgsi: Perm[][] = [];\n  let sgslen: number[][] = [];\n  let Tk: Perm[][] = [];\n  let Tklen: number[][] = [];\n  function resolve(p: Perm): boolean {\n    for (let i = p.p.length - 1; i >= 0; i--) {\n      const j = p.p[i];\n      if (j !== i) {\n        if (!sgs[i][j]) {\n          return false;\n        }\n        p = p.mul(sgsi[i][j]);\n      }\n    }\n    return true;\n  }\n  function knutha(k: number, p: Perm, len: number): void {\n    Tk[k].push(p);\n    Tklen[k].push(len);\n    for (let i = 0; i < sgs[k].length; i++) {\n      if (sgs[k][i]) {\n        knuthb(k, sgs[k][i].mul(p), len + sgslen[k][i]);\n      }\n    }\n  }\n  function knuthb(k: number, p: Perm, len: number): void {\n    const j = p.p[k];\n    if (!sgs[k][j]) {\n      sgs[k][j] = p;\n      sgsi[k][j] = p.inv();\n      sgslen[k][j] = len;\n      for (let i = 0; i < Tk[k].length; i++) {\n        knuthb(k, p.mul(Tk[k][i]), len + Tklen[k][i]);\n      }\n      return;\n    }\n    const p2 = p.mul(sgsi[k][j]);\n    if (!resolve(p2)) {\n      knutha(k - 1, p2, len + sgslen[k][j]);\n    }\n  }\n  function getsgs(): number {\n    sgs = [];\n    sgsi = [];\n    Tk = [];\n    sgslen = [];\n    Tklen = [];\n    for (let i = 0; i < n; i++) {\n      sgs.push([]);\n      sgsi.push([]);\n      sgslen.push([]);\n      Tk.push([]);\n      Tklen.push([]);\n      sgs[i][i] = e;\n      sgsi[i][i] = e;\n      sgslen[i][i] = 0;\n    }\n    let none = 0;\n    let sz = 1;\n    for (let i = 0; i < g.length; i++) {\n      knutha(n - 1, g[i], 1);\n      sz = 1;\n      let tks = 0;\n      let sollen = 0;\n      const avgs = [];\n      const mults = new FactoredNumber();\n      for (let j = 0; j < n; j++) {\n        let cnt = 0;\n        let lensum = 0;\n        for (let k = 0; k < n; k++) {\n          if (sgs[j][k]) {\n            cnt++;\n            lensum += sgslen[j][k];\n            if (j !== k) {\n              none++;\n            }\n          }\n        }\n        tks += Tk[j].length;\n        sz *= cnt;\n        if (cnt > 1) {\n          mults.multiply(cnt);\n        }\n        const avg = lensum / cnt;\n        avgs.push(avg);\n        sollen += avg;\n      }\n      disp(\"\" + i + \": sz \" + sz + \" T \" + tks + \" sol \" + sollen + \" none \" + none + \" mults \" + mults);\n    }\n    return sz;\n  }\n  return getsgs();\n}\n","// To run this file directly: npx ts-node src/puzzle-geometry/bin/puzzle-geometry-bin.ts\n\nimport { PuzzleGeometry } from \"..\";\nimport { getpuzzles, parsedesc } from \"../PuzzleGeometry\";\nimport { schreierSims } from \"../SchreierSims\";\n\nlet dosvg = false;\nlet doss = false;\nlet doksolve = false;\nlet dogap = false;\nlet docanon = false;\nlet do3d = false;\nif (typeof (process) !== \"undefined\" &&\n  process.argv && process.argv.length <= 2) {\n  console.log(`Usage:  puzzle-geometry [options] [puzzle]\n\nOptions:\n--ksolve: write ksolve (tws) file\n--svg: write SVG (default is flat; --3d makes it 3D)\n--gap: write gap\n--ss: execute Schrier-Sims calculation\n--3d: use 3D format for SVG file\n--canon: write canonical string analysis\n--rotations: include full-puzzle rotations as moves\n--allmoves: includes all moves (i.e., slice moves for 3x3x3)\n--outerblockmoves: use outer block moves rather than slice moves\n--vertexmoves: for tetrahedral puzzles, prefer vertex moves to face moves\n--nocorners: ignore all corners\n--noedges: ignore all edges\n--nocenters: ignore all centers\n--noorientation: ignore orientations\n--orientcenters: give centers an orientation\n--moves movenames: restrict moves to this list (e.g, U2,F,r)\n--optimize: optimize tws/ksolve/gap output\n--scramble: scramble solved position\n--fixcorner: choose moves to keep one corner fixed\n--fixedge: choose moves to keep one edge fixed\n--fixcenter: choose moves to keep one center fixed\n--verbose (-v): make verbose\n\nThe puzzle can be given as a geometric description or by name.\nThe geometric description starts with c (cube), t (tetrahedron),\nd (dodecahedron), i (icosahedron), or o (octahedron), then a\nspace, then a series of cuts.  Each cut begins with f (for a\ncut parallel to faces), v (for a cut perpendicular to a ray\nfrom the center through a corner), or e (for a cut perpendicular\nto a ray from the center through an edge) followed by a decimal\nnumber giving a distance, where 1 is the distance between the\ncenter of the puzzle and the center of a face.\n\nThe puzzle names recognized are 2x2x2 through 13x13x13, 20x20x20,\nmaster skewb, professor skewb, compy cube, helicopter, dino,\nlittle chop, pyramorphix, mastermorphix, pyraminx, Jing pyraminx,\nmaster paramorphix, megaminx, gigaminx, pentultimate, starminx,\nstarminx 2, pyraminx crystal, chopasaurus, big chop, skewb diamond,\nFTO, Christopher's jewel, octastar, Trajber's octahedron, radio chop,\nicosamate, icosahedron 2, icosahedron 3, icosahedron static faces,\nicosahedron moving faces, and Eitan's star.\n\nExamples:\n   puzzlegeometry --ss 2x2x2\n   puzzlegeometry --ss --fixcorner 2x2x2\n   puzzlegeometry --ss --moves U,F2,r 4x4x4\n   puzzlegeometry --ksolve --optimize --moves U,F,R megaminx\n   puzzlegeometry --gap kilominx\n`);\n}\nif (typeof (process) !== \"undefined\" &&\n  process.argv && process.argv.length >= 3) {\n  let desc;\n  const puzzleList = getpuzzles();\n  let argp = 2;\n  const optionlist = [];\n  let showargs = true;\n  while (argp < process.argv.length && process.argv[argp][0] === \"-\") {\n    const option = process.argv[argp++];\n    if (option === \"--verbose\" || option === \"-v\") {\n      optionlist.push(\"verbose\", true);\n    } else if (option === \"--quiet\" || option === \"-q\") {\n      optionlist.push(\"quiet\", true);\n      showargs = false;\n    } else if (option === \"--ksolve\") {\n      doksolve = true;\n    } else if (option === \"--svg\") {\n      showargs = false;\n      optionlist.push(\"quiet\", true);\n      dosvg = true;\n    } else if (option === \"--gap\") {\n      dogap = true;\n    } else if (option === \"--ss\") {\n      doss = true;\n    } else if (option === \"--3d\") {\n      do3d = true;\n    } else if (option === \"--canon\") {\n      docanon = true;\n    } else if (option === \"--rotations\") {\n      optionlist.push(\"rotations\", true);\n    } else if (option === \"--allmoves\") {\n      optionlist.push(\"allmoves\", true);\n    } else if (option === \"--outerblockmoves\") {\n      optionlist.push(\"outerblockmoves\", true);\n    } else if (option === \"--vertexmoves\") {\n      optionlist.push(\"vertexmoves\", true);\n    } else if (option === \"--nocorners\") {\n      optionlist.push(\"cornersets\", false);\n    } else if (option === \"--noedges\") {\n      optionlist.push(\"edgesets\", false);\n    } else if (option === \"--noorientation\") {\n      optionlist.push(\"killorientation\", true);\n    } else if (option === \"--nocenters\") {\n      optionlist.push(\"centersets\", false);\n    } else if (option === \"--moves\") {\n      optionlist.push(\"movelist\", process.argv[argp].split(\",\"));\n      argp++;\n    } else if (option === \"--optimize\") {\n      optionlist.push(\"optimize\", true);\n    } else if (option === \"--scramble\") {\n      optionlist.push(\"scramble\", 100);\n    } else if (option === \"--fixcorner\") {\n      optionlist.push(\"fix\", \"v\");\n    } else if (option === \"--fixedge\") {\n      optionlist.push(\"fix\", \"e\");\n    } else if (option === \"--fixcenter\") {\n      optionlist.push(\"fix\", \"f\");\n    } else if (option === \"--orientcenters\") {\n      optionlist.push(\"orientcenters\", true);\n    } else {\n      throw new Error(\"Bad option: \" + option);\n    }\n  }\n  for (const [name, curDesc] of Object.entries(puzzleList)) {\n    if (name === process.argv[argp]) {\n      desc = curDesc;\n      break;\n    }\n  }\n  let createargs = [];\n  if (showargs) {\n    console.log(\"# \" + process.argv.join(\" \"));\n  }\n  if (desc !== undefined) {\n    createargs = parsedesc(desc);\n    argp++;\n  } else {\n    const cuts = [];\n    const cutarg = argp++;\n    while (argp + 1 < process.argv.length && process.argv[argp].length === 1) {\n      cuts.push([process.argv[argp], process.argv[argp + 1]]);\n      argp += 2;\n    }\n    createargs = [process.argv[cutarg], cuts];\n  }\n  const pg = new PuzzleGeometry(createargs[0], createargs[1], optionlist);\n  pg.allstickers();\n  pg.genperms();\n  // TODO: if (optionlist.indexOf(\"verbose\") !== -1)\n  // if (this.verbose) {\n  //    console.log(\"# Stickers \" + pg.stickersperface + \" cubies \" +\n  //       pg.cubies.length + \" orbits \" + pg.orbits +\n  //       \" shortedge \" + pg.shortedge);\n  // }\n  if (argp < process.argv.length) {\n    throw new Error(\"Unprocessed content at end of command line\");\n  }\n  if (dogap) {\n    console.log(pg.writegap());\n  } else if (doksolve) {\n    console.log(pg.writeksolve()); // TODO: Update arguments\n  } else if (dosvg) {\n    console.log(pg.generatesvg()); // TODO: Update arguments\n  } else if (do3d) {\n    console.log(JSON.stringify(pg.get3d()));\n  } else if (doss) {\n    const os = pg.getOrbitsDef(false);\n    const as = os.reassemblySize();\n    console.log(\"Reassembly size is \" + as);\n    const ss = schreierSims(os.moveops.map((_) => _.toPerm()),\n      (_) => console.log(_));\n    const r = as / ss;\n    console.log(\"Ratio is \" + r);\n  } else if (docanon) {\n    pg.showcanon((_) => console.log(_));\n  }\n}\n"],"names":["iota","n","c","Array","i","lcm","a","b","t","m","gcd","Perm","[object Object]","this","length","p","join","p2","cyc","seen","incyc","j","push","r","cs","OrbitDef","size","mod","factorial","Math","pow","OrbitsDef","orbitnames","orbitdefs","solved","movenames","moveops","name","forTwisty","result","o","orbits","toKsolveVS","isIdentity","toKsolve","start","numPieces","orientations","toKpuzzle","moves","mp","startPieces","neworbitnames","neworbitdefs","newsolved","newmoveops","om","du","DisjointUnion","changed","k","perm","ori","union","keepori","duo","find","nontriv","multiple","h","no","on","nv","remapVS","remap","killOri","VisibleState","map","_","Transformation","pool","floor","random","ri","rj","rm","mul","s","reassemblySize","Orbit","orimod","zeros","newPerm","newOri","done","v","undefined","toPerm","order","nextNew","reassign","ov","newori","permutation","orientation","TransformationBase","newOrbits","inv","equal","perms","identicalPieces","super","internalMul","e","internalInv","heads","ah","bh","centermassface","face","Quat","sum","smul","solvethreeplanes","p1","p3","planes","intersect3","dt","d","q","hypot","sqrt","dot","normalize","acos","a00","a01","a02","a10","a11","a12","a20","a21","a22","invrot","that","rotatepoint","cubie","rotateface","det","det3x3","abs","x","faces","nfaces","inout","side","nface","kk","vk","pt","Error","dist","uniqueplanes","g","planerot","rotateplane","wasseen","getface","cross","Puzzles","2x2x2","3x3x3","4x4x4","5x5x5","6x6x6","7x7x7","8x8x8","9x9x9","10x10x10","11x11x11","12x12x12","13x13x13","20x20x20","30x30x30","skewb","master skewb","professor skewb","compy cube","helicopter","dino","little chop","pyramorphix","mastermorphix","pyraminx","Jing pyraminx","master paramorphix","megaminx","gigaminx","pentultimate","starminx","starminx 2","pyraminx crystal","chopasaurus","big chop","skewb diamond","FTO","Christopher's jewel","octastar","Trajber's octahedron","radio chop","icosamate","icosahedron 2","icosahedron 3","icosahedron static faces","icosahedron moving faces","Eitan's star","2x2x2 + dino","2x2x2 + little chop","dino + little chop","2x2x2 + dino + little chop","megaminx + chopasaurus","starminx combo","defaultnets","4","6","8","12","20","defaultcolors","F","D","L","R","U","B","M","N","C","A","E","BF","BR","BL","I","G","S","H","J","K","O","P","Q","defaultfaceorders","findelement","getmovename","geo","bits","slices","nbits","inverted","movenameFamily","movenamePrefix","hibit","String","toLowerCase","splitByFaceNames","facenames","at","found","substr","startsWith","toCoords","maxdist","toFaceCoords","trimEdges","tr","iter","pi","ni","sub","good","PuzzleGeometry","shape","cuts","optionlist","verbose","allmoves","outerblockmoves","vertexmoves","addrotations","cornersets","centersets","edgesets","graycorners","graycenters","grayedges","movelist","killorientation","optimize","scramble","fixPiece","orientCenters","args","console","log","header","create","moveplanes","cubies","s5","cube","octahedron","dx","dy","dd","ang","PI","cos","sin","icosahedron","d36","dodecahedron","rotations","ns","negns","closure","baseplane","baseplanerot","baseplanes","basefacecount","net","colors","faceorder","baseface","facenormal","makenormal","edgenormal","vertexnormal","cutplanes","normal","makecut","boundary","basefaces","faceplanes","vertexnames","edgenames","edgesperface","searchaddelement","jj","otherfaces","facelist","el","facenametoindex","faceindextoname","fi","ii","fn2","of","faceprecedence","faceplane","facename","midpoint","jjj","midpoint2","e1","e2","c1","c2","cornerfaces","st","geonormals","zero","edgedistance","vertexdistance","sameplane","cutfaces","stickersperface","shortedge","moveplanesets","faceside","facetocubies","findface","cm","key","keyface","facelisthash","face2","facen","edgen","targvec","edgen2","plane","x0","olen","len","y0","delta","cosr","sinr","x1","y1","off","rots","expandfaces","qnormal","normalizeplane","goodnormal","sort","sizes","moverotations","angle","reverse","sizes2","movesetorders","movesetgeos","p0","neg","pos","cubiehash","cubiekey","cubiekeys","suff","s2","Object","keys","getfaceindex","facenum","divid","cmall","looplimit","u","mini","minf","temp","ocubie","slice","ofacelist","typenames","cubiesetnames","cubietypecounts","orbitoris","cubiesetnum","cubiesetnums","cubieordnums","cubieords","cubievaluemap","cubiesetcubies","cubiekeymap","cubievalueid","facecnt","typectr","typename","queue","qg","cind","cubiecolorkey","tq","findcubie","fixedCubie","mv","re","RegExp","match","grip","fullrotation","endsWith","msi","upperCaseGrip","toUpperCase","firstgrip","spinmatch","loslice","hislice","parseInt","amountstr","amount","substring","cmovesbyslice","movesbyslice","moveplaneset","slicenum","slicecnts","axismoves","axiscmoves","sc","slicemoves","slicecmoves","cubiedone","fi2","duplicatedFaces","duplicatedCubies","parsedmovelist","parsemove","__","parsedmove","msg","dep","trim","split","newr","set","skipbyori","comment","os","getOrbitsDef","mvs","movename","toGap","ip","fortwisty","od","setmoves","setnames","setdefs","moveset","getmovesets","allbits","skipcubie","movesetgeo","movebits","mna","moveorbits","oris","mperm","setnum","inc","oinc","mulScalar","ksolvemovenames","disp","orders","commutes","permA","permB","curlev","0","nextlev","uniq","sti","cnt","nst","showcanon","w","threed","extendedges","cosa","sina","ndx","noise","drawedges","id","pts","color","needvertexgrips","neededgegrips","needfacegrips","genperms","polyn","getboundarygeometry","edges","minx","miny","maxx","maxy","f0","f1","f","es","min","max","xoff","yoff","geos","bg","edges2","initv","project2d","connectat","gfi","thisface","caf0","epi","gf1","gf1i","otherface","getsolved","colormap","facegeo","hix","hiy","rot","getInitial3DRotation","sc2","mappt2d","fn","xoff2","xmul","svg","cubieori","cubieord","graybyori","svggrips","addgrip","onface","pt2","facecoords","ep","mpc","vp","html","stickers","coords","orbit","ord","grips","gn","axis","FactoredNumber","mult","dosvg","doss","doksolve","dogap","docanon","do3d","process","argv","desc","puzzleList","argp","showargs","option","curDesc","entries","createargs","filter","Boolean","parsedesc","cutarg","pg","allstickers","writegap","writeksolve","generatesvg","JSON","stringify","get3d","as","identity","sgs","sgsi","sgslen","Tk","Tklen","knutha","knuthb","resolve","none","sz","tks","sollen","mults","lensum","multiply","getsgs","schreierSims"],"mappings":"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"}