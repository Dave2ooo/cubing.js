{"version":3,"file":"index-3df29a49.js","sources":["../../src/alg/debug.ts","../../src/alg/algorithm/alg-part.ts","../../src/alg/algorithm/block-move.ts","../../src/alg/operation.ts","../../src/alg/traversal.ts","../../src/alg/example.ts","../../src/alg/json.ts","../../src/alg/validation.ts","../../src/alg/parser/parser.js","../../src/alg/parser/index.ts","../../src/alg/keyboard.ts","../../src/alg/url.ts"],"sourcesContent":["type ReportingLevel = \"none\" | \"warn\" | \"error\";\nlet currentReportingLevel = \"warn\";\n\nconst MAX_NUMBER_OF_TIMES_TO_WARN = 10;\nlet numWarned = 0;\n\n// TODO: Avoid creating the string message if it won't be used (e.g. by taking a function?).\nexport function reportTypeMismatch(msg: string): void {\n  switch (currentReportingLevel) {\n    case \"error\":\n      throw new Error(msg);\n    case \"warn\":\n      numWarned++;\n      if (numWarned < MAX_NUMBER_OF_TIMES_TO_WARN) {\n        if (numWarned + 1 === MAX_NUMBER_OF_TIMES_TO_WARN) {\n          console.warn(msg);\n        }\n      }\n      return;\n  }\n}\n\nexport function setAlgPartTypeMismatchReportingLevel(level: ReportingLevel): void {\n  currentReportingLevel = level;\n}\n","import { reportTypeMismatch } from \"../debug\";\n\nexport type AlgPartType = string;\n\nexport abstract class AlgPart {\n  public abstract type: AlgPartType;\n}\n\n// type Constructor<T> = Function & { prototype: T }\nexport function matchesAlgType<T extends AlgPart>(a: any, t: AlgPartType): boolean {\n  return a.type === t;\n}\n\nexport function assertMatchesType<T extends AlgPart>(a: any, t: AlgPartType): T {\n  if (!matchesAlgType(a, t)) {\n    reportTypeMismatch(`Expected \"type\": \"${t}\", saw \"type\": \\\"${a.type}\\\".`);\n  }\n  return a;\n}\n\n// Assumes that every `AlgPart` is a `Unit` or a `Sequence`.\nexport function isUnit(a: AlgPart): boolean {\n  if (!(\"type\" in a)) {\n    return false;\n  }\n  return !matchesAlgType(a, \"sequence\");\n}\n\nexport function assertIsUnit(a: AlgPart): Unit {\n  if (!(\"type\" in a)) {\n    reportTypeMismatch(`Expected \"unit\", saw a value that was not an AlgPart.`);\n  }\n  if (matchesAlgType(a, \"sequence\")) {\n    reportTypeMismatch(`Expected unit, saw \"sequence\".`);\n  }\n  return a;\n}\n\nexport abstract class Unit extends AlgPart { }\n\nexport abstract class Move extends Unit { }\nexport abstract class Annotation extends Unit { }\nexport abstract class Container extends Unit { }\n\n// TODO: Reintroduce an Algorithm class, and allow a mutable sequence too?\nexport class Sequence extends AlgPart {\n  public type: string = \"sequence\";\n  constructor(public nestedUnits: Unit[]) {\n    super();\n    for (const n of nestedUnits) {\n      assertIsUnit(n);\n    }\n    Object.freeze(this.nestedUnits);\n    Object.freeze(this);\n  }\n}\n\nexport interface WithAmount {\n  // TODO: Allow `amount` to be `undefined`, to distinguish between R and R1?\n  amount: number;\n}\nexport class Group extends Container implements WithAmount {\n  public type: string = \"group\";\n  constructor(public nestedSequence: Sequence, public amount: number = 1) {\n    super();\n    Object.freeze(this);\n  }\n}\nexport class Commutator extends Container implements WithAmount {\n  public type: string = \"commutator\";\n  constructor(public A: Sequence, public B: Sequence, public amount: number = 1) {\n    super();\n    Object.freeze(this);\n  }\n}\nexport class Conjugate extends Container implements WithAmount {\n  public type: string = \"conjugate\";\n  constructor(public A: Sequence, public B: Sequence, public amount: number = 1) {\n    super();\n    Object.freeze(this);\n  }\n}\nexport class Pause extends Move {\n  public type: string = \"pause\";\n  constructor() {\n    super();\n    Object.freeze(this);\n  }\n}\nexport class NewLine extends Annotation {\n  public type: string = \"newLine\";\n  constructor() {\n    super();\n    Object.freeze(this);\n  }\n}\n\n// TODO: must be followed by a newline, unless at the end of an alg?\nexport class CommentShort extends Annotation {\n  public type: string = \"commentShort\";\n  constructor(public comment: string) {\n    super();\n    Object.freeze(this);\n  }\n}\nexport class CommentLong extends Annotation {\n  public type: string = \"commentLong\";\n  constructor(public comment: string) {\n    super();\n    Object.freeze(this);\n  }\n}\n\n// TODO\n// export class TimeStamp extends AlgPart implements AlgPart\n","import { Move } from \"./alg-part\";\n\nexport type MoveFamily = string; // TODO: Convert to an enum with string mappings.\n\n// TODO: Rename to `LetterMove`?\nexport class BlockMove extends Move {\n  public type: string = \"blockMove\";\n\n  // If `outerLayer` is set, `innerLayer` must also be set.\n  public outerLayer?: number;\n  public innerLayer?: number;\n  constructor(outerLayer: number | undefined, innerLayer: number | undefined, public family: MoveFamily, public amount: number = 1) {\n    super();\n    if (innerLayer) {\n      this.innerLayer = innerLayer;\n      if (outerLayer) {\n        this.outerLayer = outerLayer;\n      }\n    }\n    if (outerLayer && !innerLayer) {\n      throw new Error(\"Attempted to contruct block move with outer layer but no inner layer\");\n    }\n    Object.freeze(this);\n  }\n}\n\nexport function BareBlockMove(family: MoveFamily, amount?: number): BlockMove {\n  return new BlockMove(undefined, undefined, family, amount);\n}\n\nexport function LayerBlockMove(innerLayer: number, family: MoveFamily, amount?: number): BlockMove {\n  return new BlockMove(undefined, innerLayer, family, amount);\n}\n\nexport function RangeBlockMove(outerLayer: number, innerLayer: number, family: MoveFamily, amount?: number): BlockMove {\n  return new BlockMove(outerLayer, innerLayer, family, amount);\n}\n","import { BlockMove, Sequence } from \"./algorithm\";\n\nfunction canCoalesce(m1: BlockMove, m2: BlockMove): boolean {\n  return m1.family === m2.family && m1.innerLayer === m2.innerLayer && m1.outerLayer === m2.outerLayer;\n}\n\ninterface BlockMoveModifications {\n  outerLayer?: number;\n  innerLayer?: number;\n  family?: string;\n  amount?: number;\n}\n\nexport function modifiedBlockMove(original: BlockMove, modifications: BlockMoveModifications): BlockMove {\n  // TODO: use the nullish coalescing operator once it becomes available to us.\n  return new BlockMove(\n    modifications.outerLayer ?? original.outerLayer,\n    modifications.innerLayer ?? original.innerLayer,\n    modifications.family ?? original.family,\n    modifications.amount ?? original.amount,\n  );\n}\n\nexport function experimentalAppendBlockMove(s: Sequence, newMove: BlockMove, coalesceLastMove: boolean = false, mod: number = 0): Sequence {\n  const oldNestedUnits = s.nestedUnits;\n  const oldLastMove = oldNestedUnits[oldNestedUnits.length - 1] as (BlockMove | null);\n  if (coalesceLastMove && oldLastMove && canCoalesce(oldLastMove, newMove)) {\n    const newNestedUnits = s.nestedUnits.slice(0, oldNestedUnits.length - 1);\n    let newAmount = oldLastMove.amount + newMove.amount;\n    if (mod > 1) {\n      newAmount = (newAmount % mod + mod) % mod ;\n      if (newAmount * 2 > mod) {\n        newAmount -= mod ;\n      }\n    }\n    if (newAmount !== 0) {\n      newNestedUnits.push(modifiedBlockMove(oldLastMove, { amount: newAmount }));\n    }\n    return new Sequence(newNestedUnits);\n  } else {\n    return new Sequence([...oldNestedUnits, newMove]);\n  }\n}\n\n// This purposely takes sequences as individual arguments, instead of a lsit of sequences, because:\n//\n// 1. This matches Javascript's built-in `Array.concat()` functionality.\n// 2. It encourages avoiding lists of sequences (which might lead to coding mistakes).\n//\n// TODO: Now useful is it to coalesce at alg boundaries (rather than coalescing the whole result)?\n// Should that be a separate function, or should we change this to accept coalescing option arg like `experimentalAppendBlockMove()`?\nexport function experimentalConcatAlgs(...args: Sequence[]): Sequence {\n  return new Sequence(Array.prototype.concat.apply([], [...args].map((s) => s.nestedUnits)));\n}\n","import { assertIsUnit, assertMatchesType, isUnit, matchesAlgType } from \"./algorithm/alg-part\";\n\nimport {\n  AlgPart,\n  BlockMove,\n  CommentLong,\n  CommentShort,\n  Commutator,\n  Conjugate,\n  Group,\n  NewLine,\n  Pause,\n  Sequence,\n  Unit,\n  WithAmount,\n} from \"./algorithm\";\n\nfunction dispatch<DataDown, DataUp>(t: TraversalDownUp<DataDown, DataUp>, algPart: AlgPart, dataDown: DataDown): DataUp {\n  switch (algPart.type) {\n    case \"sequence\":\n      assertMatchesType(algPart, \"sequence\");\n      return t.traverseSequence(algPart as Sequence, dataDown);\n    case \"group\":\n      assertMatchesType(algPart, \"group\");\n      return t.traverseGroup(algPart as Group, dataDown);\n    case \"blockMove\":\n      assertMatchesType(algPart, \"blockMove\");\n      return t.traverseBlockMove(algPart as BlockMove, dataDown);\n    case \"commutator\":\n      assertMatchesType(algPart, \"commutator\");\n      return t.traverseCommutator(algPart as Commutator, dataDown);\n    case \"conjugate\":\n      assertMatchesType(algPart, \"conjugate\");\n      return t.traverseConjugate(algPart as Conjugate, dataDown);\n    case \"pause\":\n      assertMatchesType(algPart, \"pause\");\n      return t.traversePause(algPart as Pause, dataDown);\n    case \"newLine\":\n      assertMatchesType(algPart, \"newLine\");\n      return t.traverseNewLine(algPart as NewLine, dataDown);\n    case \"commentShort\":\n      assertMatchesType(algPart, \"commentShort\");\n      return t.traverseCommentShort(algPart as CommentShort, dataDown);\n    case \"commentLong\":\n      assertMatchesType(algPart, \"commentLong\");\n      return t.traverseCommentLong(algPart as CommentLong, dataDown);\n    default:\n      throw new Error(`Unknown AlgPart type: ${algPart.type}`);\n  }\n}\n\nexport abstract class TraversalDownUp<DataDown, DataUp> {\n  // Immediate subclasses should overwrite this.\n  public traverse(algPart: AlgPart, dataDown: DataDown): DataUp {\n    return dispatch(this, algPart, dataDown);\n  }\n\n  public traverseIntoUnit(algPart: AlgPart, dataDown: DataDown): Unit {\n    return assertIsUnit(this.traverse(algPart, dataDown) as any);\n  }\n\n  public abstract traverseSequence(sequence: Sequence, dataDown: DataDown): DataUp;\n  public abstract traverseGroup(group: Group, dataDown: DataDown): DataUp;\n  public abstract traverseBlockMove(blockMove: BlockMove, dataDown: DataDown): DataUp;\n  public abstract traverseCommutator(commutator: Commutator, dataDown: DataDown): DataUp;\n  public abstract traverseConjugate(conjugate: Conjugate, dataDown: DataDown): DataUp;\n  public abstract traversePause(pause: Pause, dataDown: DataDown): DataUp;\n  public abstract traverseNewLine(newLine: NewLine, dataDown: DataDown): DataUp;\n  public abstract traverseCommentShort(commentShort: CommentShort, dataDown: DataDown): DataUp;\n  public abstract traverseCommentLong(commentLong: CommentLong, dataDown: DataDown): DataUp;\n}\n\nexport abstract class TraversalUp<DataUp> extends TraversalDownUp<undefined, DataUp> {\n  public traverse(algPart: AlgPart): DataUp {\n    return dispatch<undefined, DataUp>(this, algPart, undefined);\n  }\n\n  public traverseIntoUnit(algPart: AlgPart): Unit {\n    return assertIsUnit(this.traverse(algPart) as any);\n  }\n\n  public abstract traverseSequence(sequence: Sequence): DataUp;\n  public abstract traverseGroup(group: Group): DataUp;\n  public abstract traverseBlockMove(blockMove: BlockMove): DataUp;\n  public abstract traverseCommutator(commutator: Commutator): DataUp;\n  public abstract traverseConjugate(conjugate: Conjugate): DataUp;\n  public abstract traversePause(pause: Pause): DataUp;\n  public abstract traverseNewLine(newLine: NewLine): DataUp;\n  public abstract traverseCommentShort(commentShort: CommentShort): DataUp;\n  public abstract traverseCommentLong(commentLong: CommentLong): DataUp;\n}\n\n// TODO: Test that inverses are bijections.\nexport class Invert extends TraversalUp<AlgPart> {\n  public traverseSequence(sequence: Sequence): Sequence {\n    // TODO: Handle newLines and comments correctly\n    return new Sequence(sequence.nestedUnits.slice().reverse().map((a) => this.traverseIntoUnit(a)));\n  }\n  public traverseGroup(group: Group): AlgPart {\n    return new Group(this.traverseSequence(group.nestedSequence), group.amount);\n  }\n  public traverseBlockMove(blockMove: BlockMove): AlgPart {\n    return new BlockMove(blockMove.outerLayer, blockMove.innerLayer, blockMove.family, -blockMove.amount);\n  }\n  public traverseCommutator(commutator: Commutator): AlgPart {\n    return new Commutator(commutator.B, commutator.A, commutator.amount);\n  }\n  public traverseConjugate(conjugate: Conjugate): AlgPart {\n    return new Conjugate(conjugate.A, this.traverseSequence(conjugate.B), conjugate.amount);\n  }\n  public traversePause(pause: Pause): AlgPart { return pause; }\n  public traverseNewLine(newLine: NewLine): AlgPart { return newLine; }\n  public traverseCommentShort(commentShort: CommentShort): AlgPart { return commentShort; }\n  public traverseCommentLong(commentLong: CommentLong): AlgPart { return commentLong; }\n}\n\nexport class Expand extends TraversalUp<AlgPart> {\n\n  public traverseSequence(sequence: Sequence): Sequence {\n    return new Sequence(this.flattenSequenceOneLevel(sequence.nestedUnits.map((a) => this.traverse(a))));\n  }\n  public traverseGroup(group: Group): AlgPart {\n    // TODO: Pass raw AlgPart[] to sequence.\n    return this.repeat(this.flattenSequenceOneLevel([this.traverse(group.nestedSequence)]), group);\n  }\n  public traverseBlockMove(blockMove: BlockMove): AlgPart {\n    return blockMove;\n  }\n  public traverseCommutator(commutator: Commutator): AlgPart {\n    const expandedA = this.traverseSequence(commutator.A);\n    const expandedB = this.traverseSequence(commutator.B);\n    let once: AlgPart[] = [];\n    once = once.concat(\n      expandedA,\n      expandedB,\n      invert(expandedA),\n      invert(expandedB),\n    );\n    return this.repeat(this.flattenSequenceOneLevel(once), commutator);\n  }\n  public traverseConjugate(conjugate: Conjugate): AlgPart {\n    const expandedA = this.traverseSequence(conjugate.A);\n    const expandedB = this.traverseSequence(conjugate.B);\n    let once: AlgPart[] = [];\n    once = once.concat(\n      expandedA,\n      expandedB,\n      invert(expandedA),\n    );\n    return this.repeat(this.flattenSequenceOneLevel(once), conjugate);\n  }\n  public traversePause(pause: Pause): AlgPart { return pause; }\n  public traverseNewLine(newLine: NewLine): AlgPart { return newLine; }\n  public traverseCommentShort(commentShort: CommentShort): AlgPart { return commentShort; }\n  public traverseCommentLong(commentLong: CommentLong): AlgPart { return commentLong; }\n  private flattenSequenceOneLevel(algList: AlgPart[]): Unit[] {\n    let flattened: Unit[] = [];\n    for (const part of algList) {\n      if (matchesAlgType(part, \"sequence\")) {\n        flattened = flattened.concat((part as Sequence).nestedUnits);\n      } else if (isUnit(part)) {\n        flattened.push(part);\n      } else {\n        throw new Error(\"expand() encountered an internal error. Did you pass in a valid Algorithm?\");\n      }\n    }\n    return flattened;\n  }\n\n  private repeat(algList: Unit[], accordingTo: WithAmount): Sequence {\n    const amount = Math.abs(accordingTo.amount);\n    const amountDir = (accordingTo.amount > 0) ? 1 : -1; // Mutable\n\n    // TODO: Cleaner inversion\n    let once: Unit[];\n    if (amountDir === -1) {\n      // TODO: Avoid casting to sequence.\n      once = ((invert(new Sequence(algList))) as Sequence).nestedUnits;\n    } else {\n      once = algList;\n    }\n\n    let repeated: Unit[] = [];\n    for (let i = 0; i < amount; i++) {\n      repeated = repeated.concat(once);\n    }\n\n    return new Sequence(repeated);\n  }\n}\n\nexport class StructureEquals extends TraversalDownUp<AlgPart, boolean> {\n  public traverseSequence(sequence: Sequence, dataDown: AlgPart): boolean {\n    if (isUnit(dataDown)) {\n      return false;\n    }\n    const dataDownSeq = dataDown as Sequence;\n    if (sequence.nestedUnits.length !== dataDownSeq.nestedUnits.length) {\n      return false;\n    }\n    for (let i = 0; i < sequence.nestedUnits.length; i++) {\n      if (!this.traverse(sequence.nestedUnits[i], dataDownSeq.nestedUnits[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  public traverseGroup(group: Group, dataDown: AlgPart): boolean {\n    return (matchesAlgType(dataDown, \"group\")) && this.traverse(group.nestedSequence, (dataDown as Group).nestedSequence);\n  }\n  public traverseBlockMove(blockMove: BlockMove, dataDown: AlgPart): boolean {\n    // TODO: Handle layers.\n    return matchesAlgType(dataDown, \"blockMove\") &&\n      blockMove.outerLayer === (dataDown as BlockMove).outerLayer &&\n      blockMove.innerLayer === (dataDown as BlockMove).innerLayer &&\n      blockMove.family === (dataDown as BlockMove).family &&\n      blockMove.amount === (dataDown as BlockMove).amount;\n  }\n  public traverseCommutator(commutator: Commutator, dataDown: AlgPart): boolean {\n    return matchesAlgType(dataDown, \"commutator\") &&\n      this.traverse(commutator.A, (dataDown as Commutator).A) &&\n      this.traverse(commutator.B, (dataDown as Commutator).B);\n  }\n  public traverseConjugate(conjugate: Conjugate, dataDown: AlgPart): boolean {\n    return matchesAlgType(dataDown, \"conjugate\") &&\n      this.traverse(conjugate.A, (dataDown as Conjugate).A) &&\n      this.traverse(conjugate.B, (dataDown as Conjugate).B);\n  }\n  public traversePause(pause: Pause, dataDown: AlgPart): boolean {\n    return matchesAlgType(dataDown, \"pause\");\n  }\n  public traverseNewLine(newLine: NewLine, dataDown: AlgPart): boolean {\n    return matchesAlgType(dataDown, \"newLine\");\n  }\n  public traverseCommentShort(commentShort: CommentShort, dataDown: AlgPart): boolean {\n    return matchesAlgType(dataDown, \"commentShort\") && (commentShort.comment === (dataDown as CommentShort).comment);\n  }\n  public traverseCommentLong(commentLong: CommentLong, dataDown: AlgPart): boolean {\n    return matchesAlgType(dataDown, \"commentLong\") && (commentLong.comment === (dataDown as CommentLong).comment);\n  }\n}\n\n// TODO: Test that inverses are bijections.\nexport class CoalesceBaseMoves extends TraversalUp<AlgPart> {\n\n  // TODO: Handle\n  public traverseSequence(sequence: Sequence): Sequence {\n    const coalesced: Unit[] = [];\n    for (const part of sequence.nestedUnits) {\n      if (!matchesAlgType(part, \"blockMove\")) {\n        coalesced.push(this.traverseIntoUnit(part));\n      } else if (coalesced.length > 0) {\n        const last = coalesced[coalesced.length - 1];\n        if (matchesAlgType(last, \"blockMove\") &&\n          this.sameBlock((last as BlockMove), (part as BlockMove))) {\n          // TODO: This is cube-specific. Perhaps pass the modules as DataDown?\n          const amount = (last as BlockMove).amount + (part as BlockMove).amount;\n          coalesced.pop();\n          if (amount !== 0) {\n            // We could modify the last element instead of creating a new one,\n            // but this is safe against shifting coding practices.\n            // TODO: Figure out if the shoot-in-the-foot risk\n            // modification is worth the speed.\n            coalesced.push(new BlockMove((part as BlockMove).outerLayer, (part as BlockMove).innerLayer, (part as BlockMove).family, amount));\n          }\n        } else {\n          coalesced.push(part);\n        }\n      } else {\n        coalesced.push(part);\n      }\n    }\n    return new Sequence(coalesced);\n  }\n  public traverseGroup(group: Group): AlgPart { return group; }\n  public traverseBlockMove(blockMove: BlockMove): AlgPart { return blockMove; }\n  public traverseCommutator(commutator: Commutator): AlgPart { return commutator; }\n  public traverseConjugate(conjugate: Conjugate): AlgPart { return conjugate; }\n  public traversePause(pause: Pause): AlgPart { return pause; }\n  public traverseNewLine(newLine: NewLine): AlgPart { return newLine; }\n  public traverseCommentShort(commentShort: CommentShort): AlgPart { return commentShort; }\n  public traverseCommentLong(commentLong: CommentLong): AlgPart { return commentLong; }\n  private sameBlock(moveA: BlockMove, moveB: BlockMove): boolean {\n    // TODO: Handle layers\n    return moveA.outerLayer === moveB.outerLayer &&\n      moveA.innerLayer === moveB.innerLayer &&\n      moveA.family === moveB.family;\n  }\n}\n\n// export class Concat extends TraversalDownUp<Algorithm, Sequence> {\n//   private concatIntoSequence(A: Unit[], B: Algorithm): Sequence {\n//     var nestedAlgs: Unit[] = A.slice();\n//     if (matchesAlgType(B, \"sequence\")) {\n//       nestedAlgs = nestedAlgs.concat((B as unknown as Sequence).nestedUnits)\n//     } else {\n//       nestedAlgs.push(B as unknown as Unit);\n//     }\n//     return new Sequence(nestedAlgs)\n//   }\n//   public traverseSequence(     sequence:     Sequence,     dataDown: Algorithm): Sequence {return this.concatIntoSequence(sequence.nestedUnits, dataDown); }\n//   public traverseGroup(        group:        Group,        dataDown: Algorithm): Sequence {return this.concatIntoSequence([group]          , dataDown); }\n//   public traverseBlockMove(    BlockMove:    BlockMove,    dataDown: Algorithm): Sequence {return this.concatIntoSequence([BlockMove]      , dataDown); }\n//   public traverseCommutator(   commutator:   Commutator,   dataDown: Algorithm): Sequence {return this.concatIntoSequence([commutator]     , dataDown); }\n//   public traverseConjugate(    conjugate:    Conjugate,    dataDown: Algorithm): Sequence {return this.concatIntoSequence([conjugate]      , dataDown); }\n//   public traversePause(        pause:        Pause,        dataDown: Algorithm): Sequence {return this.concatIntoSequence([pause]          , dataDown); }\n//   public traverseNewLine(      newLine:      NewLine,      dataDown: Algorithm): Sequence {return this.concatIntoSequence([newLine]        , dataDown); }\n//   public traverseCommentShort( commentShort: CommentShort, dataDown: Algorithm): Sequence {return this.concatIntoSequence([commentShort]   , dataDown); }\n//   public traverseCommentLong(  commentLong:  CommentLong,  dataDown: Algorithm): Sequence {return this.concatIntoSequence([commentLong]    , dataDown); }\n// }\n\nfunction repetitionSuffix(amount: number): string {\n  const absAmount = Math.abs(amount);\n  let s = \"\";\n  if (absAmount !== 1) {\n    s += String(absAmount);\n  }\n  if (absAmount !== amount) {\n    s += \"'\";\n  }\n  return s;\n}\nexport function blockMoveToString(blockMove: BlockMove): string {\n  let out = blockMove.family + repetitionSuffix(blockMove.amount);\n  if (typeof blockMove.innerLayer !== \"undefined\") {\n    out = String(blockMove.innerLayer) + out;\n    if (typeof blockMove.outerLayer !== \"undefined\") {\n      out = String(blockMove.outerLayer) + \"-\" + out;\n    }\n  }\n  return out;\n}\n\nexport class ToString extends TraversalUp<string> {\n  public traverseSequence(sequence: Sequence): string {\n    let output = \"\";\n    if (sequence.nestedUnits.length > 0) {\n      output += this.traverse(sequence.nestedUnits[0]);\n      for (let i = 1; i < sequence.nestedUnits.length; i++) {\n        output += this.spaceBetween(sequence.nestedUnits[i - 1], sequence.nestedUnits[i]);\n        output += this.traverse(sequence.nestedUnits[i]);\n      }\n    }\n    return output;\n  }\n  public traverseGroup(group: Group): string { return \"(\" + this.traverse(group.nestedSequence) + \")\" + repetitionSuffix(group.amount); }\n  public traverseBlockMove(blockMove: BlockMove): string {\n    return blockMoveToString(blockMove);\n  }\n  public traverseCommutator(commutator: Commutator): string { return \"[\" + this.traverse(commutator.A) + \", \" + this.traverse(commutator.B) + \"]\" + repetitionSuffix(commutator.amount); }\n  public traverseConjugate(conjugate: Conjugate): string { return \"[\" + this.traverse(conjugate.A) + \": \" + this.traverse(conjugate.B) + \"]\" + repetitionSuffix(conjugate.amount); }\n  // TODO: Remove spaces between repeated pauses (in traverseSequence)\n  public traversePause(pause: Pause): string { return \".\"; }\n  public traverseNewLine(newLine: NewLine): string { return \"\\n\"; }\n  // TODO: Enforce being followed by a newline (or the end of the alg)?\n  public traverseCommentShort(commentShort: CommentShort): string { return \"//\" + commentShort.comment; }\n  // TODO: Sanitize `*/`\n  public traverseCommentLong(commentLong: CommentLong): string { return \"/*\" + commentLong.comment + \"*/\"; }\n  private spaceBetween(u1: Unit, u2: Unit): string {\n    if (matchesAlgType(u1, \"pause\") && matchesAlgType(u2, \"pause\")) {\n      return \"\";\n    }\n    if (matchesAlgType(u1, \"newLine\") || matchesAlgType(u2, \"newLine\")) {\n      return \"\";\n    }\n    if (matchesAlgType(u1, \"commentShort\") && !matchesAlgType(u2, \"newLine\")) {\n      return \"\\n\";\n    }\n    return \" \";\n  }\n}\n\nconst invertInstance = new Invert();\nconst expandInstance = new Expand();\nconst structureEqualsInstance = new StructureEquals();\nconst coalesceBaseMovesInstance = new CoalesceBaseMoves();\nconst algToStringInstance = new ToString();\n\nexport const invert = invertInstance.traverseSequence.bind(invertInstance) as (a: Sequence) => Sequence;\nexport const expand = expandInstance.traverseSequence.bind(expandInstance) as (a: Sequence) => Sequence;\nexport const structureEquals = structureEqualsInstance.traverseSequence.bind(structureEqualsInstance) as (a1: Sequence, a2: Sequence) => boolean;\nexport const coalesceBaseMoves = coalesceBaseMovesInstance.traverseSequence.bind(coalesceBaseMovesInstance) as (a: Sequence) => Sequence;\nexport const algToString = algToStringInstance.traverseSequence.bind(algToStringInstance) as (a: Sequence) => string;\n\nexport const algPartStructureEqualsForTesting = algToStringInstance.traverse.bind(algToStringInstance) as (a1: AlgPart, a2: AlgPart) => boolean;\nexport const algPartToStringForTesting = algToStringInstance.traverse.bind(algToStringInstance) as (a: AlgPart) => string;\n\nexport function experimentalBlockMoveQuantumName(move: BlockMove): string {\n  return algPartToStringForTesting(new BlockMove(move.outerLayer, move.innerLayer, move.family, 1));\n}\n","import {\n  AlgPart,\n  BareBlockMove,\n  CommentLong,\n  CommentShort,\n  Commutator,\n  Conjugate,\n  Group,\n  NewLine,\n  Pause,\n  Sequence,\n} from \"./algorithm\";\n\n// tslint:disable-next-line no-namespace // TODO: nested module\nexport namespace Example {\n\n  export const Sune: Sequence = new Sequence([\n    BareBlockMove(\"R\", 1),\n    BareBlockMove(\"U\", 1),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"U\", 1),\n    BareBlockMove(\"R\", 1),\n    BareBlockMove(\"U\", -2),\n    BareBlockMove(\"R\", -1),\n  ]);\n\n  export const AntiSune: Sequence = new Sequence([\n    BareBlockMove(\"R\", 1),\n    BareBlockMove(\"U\", 2),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"U\", -1),\n    BareBlockMove(\"R\", 1),\n    BareBlockMove(\"U\", -1),\n    BareBlockMove(\"R\", -1),\n  ]);\n\n  export const SuneCommutator: Sequence = new Sequence([new Commutator(\n    new Sequence([\n      BareBlockMove(\"R\", 1),\n      BareBlockMove(\"U\", 1),\n      BareBlockMove(\"R\", -2),\n    ]),\n    new Sequence([new Conjugate(\n      new Sequence([BareBlockMove(\"R\", 1)]),\n      new Sequence([BareBlockMove(\"U\", 1)]),\n      1,\n    )]),\n    1,\n  )]);\n\n  export const Niklas: Sequence = new Sequence([\n    BareBlockMove(\"R\", 1),\n    BareBlockMove(\"U\", -1),\n    BareBlockMove(\"L\", -1),\n    BareBlockMove(\"U\", 1),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"U\", -1),\n    BareBlockMove(\"L\", 1),\n    BareBlockMove(\"U\", 1),\n  ]);\n\n  export const EPerm: Sequence = new Sequence([\n    BareBlockMove(\"x\", -1),\n    new Commutator(\n      new Sequence([new Conjugate(\n        new Sequence([BareBlockMove(\"R\", 1)]),\n        new Sequence([BareBlockMove(\"U\", -1)]),\n      )]),\n      new Sequence([BareBlockMove(\"D\", 1)]),\n      1,\n    ),\n    new Commutator(\n      new Sequence([new Conjugate(\n        new Sequence([BareBlockMove(\"R\", 1)]),\n        new Sequence([BareBlockMove(\"U\", 1)]),\n      )]),\n      new Sequence([BareBlockMove(\"D\", 1)]),\n      1,\n    ),\n    BareBlockMove(\"x\", 1),\n  ]);\n\n  export const FURURFCompact: Sequence = new Sequence([new Conjugate(\n    new Sequence([BareBlockMove(\"F\", 1)]),\n    new Sequence([new Commutator(\n      new Sequence([BareBlockMove(\"U\", 1)]),\n      new Sequence([BareBlockMove(\"R\", 1)]),\n      1,\n    )]),\n    1,\n  )]);\n\n  export const APermCompact: Sequence = new Sequence([new Conjugate(\n    new Sequence([BareBlockMove(\"R\", 2)]),\n    new Sequence([new Commutator(\n      new Sequence([BareBlockMove(\"F\", 2)]),\n      new Sequence([\n        BareBlockMove(\"R\", -1),\n        BareBlockMove(\"B\", -1),\n        BareBlockMove(\"R\", 1),\n      ]),\n      1,\n    )]),\n    1,\n  )]);\n\n  export const FURURFMoves: Sequence = new Sequence([\n    BareBlockMove(\"F\", 1),\n    BareBlockMove(\"U\", 1),\n    BareBlockMove(\"R\", 1),\n    BareBlockMove(\"U\", -1),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"F\", -1),\n  ]);\n\n  export const TPerm: Sequence = new Sequence([\n    BareBlockMove(\"R\", 1),\n    BareBlockMove(\"U\", 1),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"U\", -1),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"F\", 1),\n    BareBlockMove(\"R\", 2),\n    BareBlockMove(\"U\", -1),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"U\", -1),\n    BareBlockMove(\"R\", 1),\n    BareBlockMove(\"U\", 1),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"F\", -1),\n  ]);\n\n  export const HeadlightSwaps: Sequence = new Sequence([new Conjugate(\n    new Sequence([BareBlockMove(\"F\", 1)]),\n    new Sequence([new Commutator(\n      new Sequence([BareBlockMove(\"R\", 1)]),\n      new Sequence([BareBlockMove(\"U\", 1)]),\n      3,\n    )]),\n    1,\n  )]);\n\n  export const TriplePause: Sequence = new Sequence([\n    new Pause(),\n    new Pause(),\n    new Pause(),\n  ],\n  );\n\n  export const AllAlgParts: AlgPart[] = [\n    new Sequence([BareBlockMove(\"R\", 1), BareBlockMove(\"U\", -1)]),\n    new Group(new Sequence([BareBlockMove(\"F\", 1)]), 2),\n    // new Rotation(\"y\", -1),\n    BareBlockMove(\"R\", 2),\n    new Commutator(new Sequence([BareBlockMove(\"R\", 2)]), new Sequence([BareBlockMove(\"U\", 2)]), 2),\n    new Conjugate(new Sequence([BareBlockMove(\"L\", 2)]), new Sequence([BareBlockMove(\"D\", -1)]), 2),\n    new Pause(),\n    new NewLine(),\n    new CommentShort(\"short comment\"),\n    new CommentLong(\"long comment\"),\n  ];\n\n}\n","import {\n  BlockMove,\n  CommentLong,\n  CommentShort,\n  Commutator,\n  Conjugate,\n  Group,\n  NewLine,\n  Pause,\n  Sequence,\n  Unit,\n} from \"./algorithm\";\n\n// TODO: Turn this into a union.\nexport interface AlgJSON {\n  type: string;\n  nestedSequence?: AlgJSON;\n  nestedUnits?: AlgJSON[];\n  innerLayer?: number;\n  outerLayer?: number;\n  family?: string;\n  amount?: number;\n  A?: AlgJSON;\n  B?: AlgJSON;\n  comment?: string;\n}\n\nexport function fromJSON(json: AlgJSON): Sequence {\n  if (json.type !== \"sequence\") {\n    throw new Error(`Expected Sequence while parsing, got: ${json.type}`);\n  }\n  if (!json.nestedUnits) { throw new Error(\"Missing nestedUnits\"); }\n  return new Sequence(json.nestedUnits.map((j) => unitFromJSON(j)));\n}\n\nfunction unitFromJSON(json: AlgJSON): Unit {\n  switch (json.type) {\n    case \"sequence\":\n      throw new Error(`Expected AlgPart while parsing, got \\`Sequence\\`.`);\n    case \"group\":\n      if (!json.nestedSequence) { throw new Error(\"Missing nestedSequence\"); }\n      if (!json.amount) { throw new Error(\"Missing amount\"); }\n      return new Group(fromJSON(json.nestedSequence), json.amount);\n    case \"blockMove\":\n      // TODO: Double-check that there is no outer layer without an inner layer?\n      if (!json.family) { throw new Error(\"Missing family\"); }\n      if (!json.amount) { throw new Error(\"Missing amount\"); }\n      return new BlockMove(json.outerLayer, json.innerLayer, json.family, json.amount);\n    case \"commutator\":\n      if (!json.A) { throw new Error(\"Missing A\"); }\n      if (!json.B) { throw new Error(\"Missing B\"); }\n      if (!json.amount) { throw new Error(\"Missing amount\"); }\n      return new Commutator(fromJSON(json.A), fromJSON(json.B), json.amount);\n    case \"conjugate\":\n      if (!json.A) { throw new Error(\"Missing A\"); }\n      if (!json.B) { throw new Error(\"Missing B\"); }\n      if (!json.amount) { throw new Error(\"Missing amount\"); }\n      return new Conjugate(fromJSON(json.A), fromJSON(json.B), json.amount);\n    case \"pause\":\n      return new Pause();\n    case \"newLine\":\n      return new NewLine();\n    case \"commentShort\":\n      if (!json.comment) { throw new Error(\"Missing comment\"); }\n      return new CommentShort(json.comment);\n    case \"commentLong\":\n      if (!json.comment) { throw new Error(\"Missing comment\"); }\n      return new CommentLong(json.comment);\n    default:\n      throw new Error(`Unknown alg type: ${json.type}`);\n  }\n}\n","import {\n  BlockMove,\n  CommentLong,\n  CommentShort,\n  Commutator,\n  Conjugate,\n  Group,\n  NewLine,\n  Pause,\n  Sequence,\n} from \"./algorithm\";\n\nimport { TraversalUp } from \"./traversal\";\n\nexport class ValidationError extends Error { }\n\nexport abstract class ValidatorTraversal extends TraversalUp<void> { }\n\ninterface FamilyList { [s: string]: boolean; }\n\nfunction validateFamily(family: string, allowedFamilyLists: FamilyList[]): boolean {\n  for (const list of allowedFamilyLists) {\n    if (list[family] === true) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// TODO: Switch to `Set`?\nconst plainMoveFamilies: FamilyList = {\n  x: true,\n  y: true,\n  z: true,\n  M: true,\n  E: true,\n  S: true,\n  m: true,\n  e: true,\n  s: true,\n};\n\nconst singleSliceMoveFamilies: FamilyList = {\n  U: true,\n  L: true,\n  F: true,\n  R: true,\n  B: true,\n  D: true,\n};\n\nconst wideMoveFamilies: FamilyList = {\n  u: true,\n  l: true,\n  f: true,\n  r: true,\n  b: true,\n  d: true,\n  Uw: true,\n  Lw: true,\n  Fw: true,\n  Rw: true,\n  Bw: true,\n  Dw: true,\n};\n\nabstract class BaseMoveValidator extends ValidatorTraversal {\n  public traverseSequence(sequence: Sequence): void {\n    // TODO: Handle newLines and comments correctly\n    for (const unit of sequence.nestedUnits) {\n      this.traverse(unit);\n    }\n  }\n  public traverseGroup(group: Group): void {\n    return this.traverse(group.nestedSequence);\n  }\n  public traverseCommutator(commutator: Commutator): void {\n    this.traverse(commutator.A);\n    this.traverse(commutator.B);\n  }\n  public traverseConjugate(conjugate: Conjugate): void {\n    this.traverse(conjugate.A);\n    this.traverse(conjugate.B);\n  }\n  public traversePause(pause: Pause): void { return; }\n  public traverseNewLine(newLine: NewLine): void { return; }\n  public traverseCommentShort(commentShort: CommentShort): void { return; }\n  public traverseCommentLong(commentLong: CommentLong): void { return; }\n}\n\n// TODO: Export function instead?\nexport class BlockMoveValidator extends BaseMoveValidator {\n  public traverseBlockMove(blockMove: BlockMove): void {\n    if (typeof blockMove.outerLayer !== \"undefined\") {\n      if (typeof blockMove.innerLayer === \"undefined\") {\n        throw new ValidationError(\"A BlockMove with an outer layer must have an inner layer.\");\n      }\n      if (!validateFamily(blockMove.family, [wideMoveFamilies])) {\n        throw new ValidationError(`The provided SiGN move family is invalid, or cannot have an outer and inner layer: ${blockMove.family}`);\n      }\n      if (blockMove.outerLayer <= 0) {\n        throw new ValidationError(\"Cannot have an outer layer of 0 or less.\");\n      }\n      // TODO: Allow 2-2r?\n      if (blockMove.outerLayer >= blockMove.innerLayer) {\n        throw new ValidationError(\"The outer layer must be less than the inner layer.\");\n      }\n      return;\n    } else if (typeof blockMove.innerLayer !== \"undefined\") {\n      if (!validateFamily(blockMove.family, [wideMoveFamilies, singleSliceMoveFamilies])) {\n        throw new ValidationError(`The provided SiGN move family is invalid, or cannot have an inner slice: ${blockMove.family}`);\n      }\n      if (blockMove.innerLayer <= 0) {\n        throw new ValidationError(\"Cannot have an inner layer of 0 or less.\");\n      }\n      return;\n    } else {\n      if (!validateFamily(blockMove.family, [wideMoveFamilies, singleSliceMoveFamilies, plainMoveFamilies])) {\n        throw new ValidationError(`Invalid SiGN plain move family: ${blockMove.family}`);\n      }\n      return;\n    }\n  }\n}\n\n// TODO: Export function instead?\nexport class FlatAlgValidator extends ValidatorTraversal {\n\n  public traverseSequence(sequence: Sequence): void {\n    // TODO: Handle newLines and comments correctly\n    for (const unit of sequence.nestedUnits) {\n      this.traverse(unit);\n    }\n    return;\n  }\n  public traverseGroup(group: Group): void {\n    throw new ValidationError(\"A flat alg cannot contain a group.\");\n  }\n  public traverseBlockMove(blockMove: BlockMove): void {\n    return;\n  }\n  public traverseCommutator(commutator: Commutator): void {\n    throw new ValidationError(\"A flat alg cannot contain a commutator.\");\n  }\n  public traverseConjugate(conjugate: Conjugate): void {\n    throw new ValidationError(\"A flat alg cannot contain a conjugate.\");\n  }\n  public traversePause(pause: Pause): void { return; }\n  public traverseNewLine(newLine: NewLine): void { return; }\n  public traverseCommentShort(commentShort: CommentShort): void { return; }\n  public traverseCommentLong(commentLong: CommentLong): void { return; }\n}\n\nexport type Validator = (a: Sequence) => void;\n\nconst BlockMoveValidatorInstance = new BlockMoveValidator();\nexport const validateSiGNMoves = BlockMoveValidatorInstance.traverse.bind(BlockMoveValidatorInstance) as Validator;\n\nconst flatAlgValidatorInstance = new FlatAlgValidator();\nexport const validateFlatAlg = flatAlgValidatorInstance.traverse.bind(flatAlgValidatorInstance) as Validator;\n\n// TODO: Option for puzzle size?\nexport function validateSiGNAlg(a: Sequence): void {\n  validateSiGNMoves(a);\n  validateFlatAlg(a);\n}\n","// Workaround per https://github.com/pegjs/pegjs/pull/481\nimport parser from \"./parser.pegjs\";\nconst {parse} = parser;\nexport {parse};\n","import { Sequence } from \"../algorithm\";\nimport { fromJSON } from \"../json\";\nimport { validateSiGNAlg, Validator } from \"../validation\";\nimport { parse as pegParse } from \"./parser\";\n\nexport interface ParseOptions {\n  validators?: Validator[];\n}\n\n// TODO: Include token location info.\n// TODO: Take validators in a way that allows optimizing parsing.\nexport function parse(s: string, options: ParseOptions = { validators: [] }): Sequence {\n  options.validators = options.validators || [];\n\n  const algo = fromJSON(pegParse(s));\n  for (const validate of options.validators) {\n    validate(algo);\n  }\n  return algo;\n}\n\nexport function parseSiGN(s: string): Sequence {\n  return parse(s, { validators: [validateSiGNAlg] });\n}\n","import { BareBlockMove, BlockMove } from \"./algorithm\";\n\nconst cubeKeyMapping: { [key: number]: BlockMove } = {\n  73: BareBlockMove(\"R\"), 75: BareBlockMove(\"R\", -1),\n  87: BareBlockMove(\"B\"), 79: BareBlockMove(\"B\", -1),\n  83: BareBlockMove(\"D\"), 76: BareBlockMove(\"D\", -1),\n  68: BareBlockMove(\"L\"), 69: BareBlockMove(\"L\", -1),\n  74: BareBlockMove(\"U\"), 70: BareBlockMove(\"U\", -1),\n  72: BareBlockMove(\"F\"), 71: BareBlockMove(\"F\", -1), // Heise\n  78: BareBlockMove(\"F\"), 86: BareBlockMove(\"F\", -1), // Kirjava\n\n  67: BareBlockMove(\"l\"), 82: BareBlockMove(\"l\", -1),\n  85: BareBlockMove(\"r\"), 77: BareBlockMove(\"r\", -1),\n\n  84: BareBlockMove(\"x\"), 89: BareBlockMove(\"x\"), 66: BareBlockMove(\"x\", -1), // 84 (T) and 89 (Y) are alternatives.\n  186: BareBlockMove(\"y\"), 59: BareBlockMove(\"y\"), 65: BareBlockMove(\"y\", -1), // 186 is WebKit, 59 is Mozilla; see http://unixpapa.com/js/key.html\n  80: BareBlockMove(\"z\"), 81: BareBlockMove(\"z\", -1),\n\n  190: BareBlockMove(\"M\", -1),\n};\n\n// TODO: options about whether to ignore modifier keys (e.g. alt, ctrl).\n// TODO: Support different mappings.\n// TODO: Return BaseMove instead?\nexport function keyToMove(e: KeyboardEvent): BlockMove | null {\n  if (e.altKey || e.ctrlKey) {\n    return null;\n  }\n\n  return cubeKeyMapping[e.keyCode] || null;\n}\n","import { Sequence } from \"./algorithm\";\nimport { parse } from \"./parser\";\nimport { algToString } from \"./traversal\";\n\n// This is not the most sophisticated scheme, but it has been used in production\n// at alg.cubing.net for years.\nexport function serializeURLParam(a: Sequence): string {\n  let escaped = algToString(a);\n  escaped = escaped.replace(/_/g, \"&#95;\").replace(/ /g, \"_\");\n  escaped = escaped.replace(/\\+/g, \"&#2b;\");\n  escaped = escaped.replace(/-/g, \"&#45;\").replace(/'/g, \"-\");\n  return escaped;\n}\n\nexport function deserializeURLParam(a: string): Sequence {\n  let unescaped = a;\n  unescaped = unescaped.replace(/-/g, \"'\").replace(/&#45;/g, \"-\");\n  unescaped = unescaped.replace(/\\+/g, \" \").replace(/&#2b;/g, \"+\"); // Recognize + as space. Many URL encodings will do this.\n  unescaped = unescaped.replace(/_/g, \" \").replace(/&#95;/g, \"_\");\n  return parse(unescaped);\n}\n\n// Returns an empty sequence if the parameter is not present.\n// Throws an error if an alg is present but not valid.\nexport function getAlgURLParam(name: string): Sequence {\n  const s = new URLSearchParams(window.location.search).get(name) || \"\";\n  return deserializeURLParam(s);\n}\n\nexport interface AlgCubingNetOptions {\n  alg?: Sequence;\n  setup?: Sequence;\n  title?: string;\n  puzzle?: \"1x1x1\" | \"2x2x2\" | \"3x3x3\" | \"4x4x4\" | \"5x5x5\" | \"6x6x6\" | \"7x7x7\" | \"8x8x8\" | \"9x9x9\" | \"10x10x10\" | \"11x11x11\" | \"12x12x12\" | \"13x13x13\" | \"14x14x14\" | \"16x16x16\" | \"17x17x17\";\n  stage?: \"full\" | \"cross\" | \"F2L\" | \"LL\" | \"OLL\" | \"PLL\" | \"CLS\" | \"ELS\" | \"L6E\" | \"CMLL\" | \"WV\" | \"ZBLL\" | \"void\";\n  view?: \"editor\" | \"playback\" | \"fullscreen\";\n  type?: \"moves\" | \"reconstruction\" | \"alg\" | \"reconstruction-end-with-setup\";\n}\n\n// TODO: runtime validation?\nexport function algCubingNetLink(options: AlgCubingNetOptions): string {\n  const url = new URL(\"https://alg.cubing.net\");\n  if (!options.alg) {\n    throw new Error((\"An alg parameter is required.\"));\n  }\n  url.searchParams.set(\"alg\", serializeURLParam(options.alg));\n\n  if (options.setup) {\n    url.searchParams.set(\"setup\", serializeURLParam(options.setup));\n  }\n  if (options.title) {\n    url.searchParams.set(\"title\", options.title);\n  }\n  if (options.puzzle) {\n    if ([\"1x1x1\", \"2x2x2\", \"3x3x3\", \"4x4x4\", \"5x5x5\", \"6x6x6\", \"7x7x7\", \"8x8x8\", \"9x9x9\", \"10x10x10\", \"11x11x11\", \"12x12x12\", \"13x13x13\", \"14x14x14\", \"16x16x16\", \"17x17x17\"].indexOf(options.puzzle) === -1) {\n      throw new Error(`Invalid puzzle parameter: ${options.puzzle}`);\n    }\n    url.searchParams.set(\"puzzle\", options.puzzle);\n  }\n  if (options.stage) {\n    if ([\"full\", \"cross\", \"F2L\", \"LL\", \"OLL\", \"PLL\", \"CLS\", \"ELS\", \"L6E\", \"CMLL\", \"WV\", \"ZBLL\", \"void\"].indexOf(options.stage) === -1) {\n      throw new Error(`Invalid stage parameter: ${options.stage}`);\n    }\n    url.searchParams.set(\"stage\", options.stage);\n  }\n  if (options.view) {\n    if ([\"editor\", \"playback\", \"fullscreen\"].indexOf(options.view) === -1) {\n      throw new Error(`Invalid view parameter: ${options.view}`);\n    }\n    url.searchParams.set(\"view\", options.view);\n  }\n  if (options.type) {\n    if ([\"moves\", \"reconstruction\", \"alg\", \"reconstruction-end-with-setup\"].indexOf(options.type) === -1) {\n      throw new Error(`Invalid type parameter: ${options.type}`);\n    }\n    url.searchParams.set(\"type\", options.type);\n  }\n  return url.toString();\n}\n"],"names":["currentReportingLevel","numWarned","reportTypeMismatch","msg","Error","console","warn","setAlgPartTypeMismatchReportingLevel","level","AlgPart","matchesAlgType","a","t","type","assertMatchesType","isUnit","assertIsUnit","Unit","Move","Annotation","Container","Sequence","[object Object]","nestedUnits","super","this","n","Object","freeze","Group","nestedSequence","amount","Commutator","A","B","Conjugate","Pause","NewLine","CommentShort","comment","CommentLong","BlockMove","outerLayer","innerLayer","family","BareBlockMove","undefined","LayerBlockMove","RangeBlockMove","modifiedBlockMove","original","modifications","experimentalAppendBlockMove","s","newMove","coalesceLastMove","mod","oldNestedUnits","oldLastMove","length","m2","m1","newNestedUnits","slice","newAmount","push","experimentalConcatAlgs","args","Array","prototype","concat","apply","map","dispatch","algPart","dataDown","traverseSequence","traverseGroup","traverseBlockMove","traverseCommutator","traverseConjugate","traversePause","traverseNewLine","traverseCommentShort","traverseCommentLong","TraversalDownUp","traverse","TraversalUp","repetitionSuffix","absAmount","Math","abs","String","blockMoveToString","blockMove","out","invertInstance","Invert","sequence","reverse","traverseIntoUnit","group","commutator","conjugate","pause","newLine","commentShort","commentLong","expandInstance","Expand","flattenSequenceOneLevel","repeat","expandedA","expandedB","once","invert","algList","flattened","part","accordingTo","repeated","i","structureEqualsInstance","StructureEquals","dataDownSeq","coalesceBaseMovesInstance","CoalesceBaseMoves","coalesced","last","sameBlock","pop","moveA","moveB","algToStringInstance","ToString","output","spaceBetween","u1","u2","bind","expand","structureEquals","coalesceBaseMoves","algToString","algPartToStringForTesting","Example","fromJSON","json","j","unitFromJSON","ValidationError","ValidatorTraversal","validateFamily","allowedFamilyLists","list","plainMoveFamilies","x","y","z","M","E","S","m","e","singleSliceMoveFamilies","U","L","F","R","D","wideMoveFamilies","u","l","f","r","b","d","Uw","Lw","Fw","Rw","Bw","Dw","BaseMoveValidator","unit","BlockMoveValidatorInstance","BlockMoveValidator","validateSiGNMoves","flatAlgValidatorInstance","FlatAlgValidator","validateFlatAlg","validateSiGNAlg","parse","parser","options","validators","algo","pegParse","validate","cubeKeyMapping","73","75","87","79","83","76","68","69","74","70","72","71","78","86","67","82","85","77","84","89","66","186","59","65","80","81","190","keyToMove","altKey","ctrlKey","keyCode","serializeURLParam","escaped","replace","deserializeURLParam","unescaped","getAlgURLParam","name","URLSearchParams","window","location","search","get","algCubingNetLink","url","URL","alg","searchParams","set","setup","title","puzzle","indexOf","stage","view","toString","move"],"mappings":"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"}