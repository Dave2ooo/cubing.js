{"version":3,"file":"index-7e411523.js","sources":["../../src/twisty/easing.ts","../../src/twisty/3D/twisty3D.ts","../../src/twisty/3D/cube3D.ts","../../src/twisty/3D/pg3D.ts","../../src/twisty/cursor.ts","../../src/twisty/puzzle.ts","../../src/twisty/stream/timeline.ts","../../src/twisty/anim.ts","../../src/twisty/widget.ts","../../src/twisty/twisty.ts"],"sourcesContent":["\nexport function smootherStep(x: number): number {\n  return x * x * x * (10 - x * (15 - 6 * x));\n}\n","import { PerspectiveCamera, Renderer, Scene, Vector3, WebGLRenderer } from \"three\";\nimport Stats from \"three/examples/jsm/libs/stats.module\";\nimport { Cursor } from \"../cursor\";\nimport { Puzzle } from \"../puzzle\";\n\nconst SHOW_STATS = false;\n\nexport const TAU = Math.PI * 2;\n\nconst useResizeObserver = typeof window !== \"undefined\" && \"ResizeObserver\" in window;\n\n// TODO: Turn into class?\nexport class Vantage {\n  public camera: PerspectiveCamera;\n  public renderer: WebGLRenderer;\n  private rafID: number | null = null;\n  private stats: Stats | null = null;\n  private shift: number = 0;\n  constructor(public element: HTMLElement, private scene: Scene, options: VantageOptions = {}) {\n    this.camera = new PerspectiveCamera(20, element.offsetWidth / element.offsetHeight, 0.1, 1000);\n    this.camera.position.copy(options.position ? options.position : defaultVantagePosition);\n    this.camera.lookAt(new Vector3(0, 0, 0));\n\n    this.renderer = /*options.renderer ? options.renderer : */createDefaultRenderer();\n    this.shift = options.shift ? options.shift : 0;\n    this.resize();\n\n    this.render();\n\n    if (SHOW_STATS) {\n      this.stats = Stats();\n      this.stats.dom.style.position = \"absolute\";\n      element.appendChild(this.stats.dom);\n    }\n\n    // TODO: Handle Safari (use a polyfill?)\n    if (useResizeObserver) {\n      const observer = new window.ResizeObserver(this.resize.bind(this));\n      observer.observe(this.element);\n    }\n    element.appendChild(this.renderer.domElement);\n  }\n\n  // TODO: Use a coarser debounce?\n  public resize(): void {\n    if (this.rafID !== null) {\n      return;\n    }\n    this.rafID = requestAnimationFrame(this.scheduledResize.bind(this));\n  }\n\n  public render(): void {\n    if (this.stats) {\n      this.stats.begin();\n    }\n    this.renderer.render(this.scene, this.camera);\n    if (this.stats) {\n      this.stats.end();\n    }\n  }\n\n  private scheduledResize(): void {\n    const w = this.element.offsetWidth;\n    const h = this.element.offsetHeight;\n    let off = 0;\n    if (this.shift > 0) {\n      off = Math.max(0, Math.floor((w - h) * 0.5));\n    } else if (this.shift < 0) {\n      off = - Math.max(0, Math.floor((w - h) * 0.5));\n    }\n    let yoff = 0;\n    let excess = 0;\n    if (h > w) {\n      excess = h - w;\n      yoff = -Math.floor(0.5 * excess);\n    }\n    this.camera.aspect = w / h;\n    this.camera.setViewOffset(w, h - excess, off, yoff, w, h);\n    this.camera.updateProjectionMatrix();\n\n    this.renderer.setPixelRatio(pixelRatio());\n    // TODO: Add a canvas wrapping class to handle sizing.\n    this.renderer.setSize(w, h, false);\n    this.render();\n\n    this.rafID = null;\n  }\n}\n\nexport interface VantageOptions {\n  position?: Vector3;\n  renderer?: Renderer;\n  shift?: number;\n}\n\n// TODO: Handle if you move across screens?\nfunction pixelRatio(): number {\n  return devicePixelRatio || 1;\n}\n\nconst defaultVantagePosition = new Vector3(2, 4, 4);\nfunction createDefaultRenderer(): WebGLRenderer {\n  return new WebGLRenderer({\n    antialias: true,\n    alpha: true,\n  });\n}\n\nexport abstract class Twisty3D<P extends Puzzle> {\n  // TODO: Expose scene or allow providing a partial scene.\n  protected scene: Scene;\n  protected vantages: Vantage[] = [];\n  constructor() {\n    this.scene = new Scene();\n  }\n\n  public newVantage(element: HTMLElement, options?: VantageOptions): Vantage {\n    const vantage = new Vantage(element, this.scene, options);\n    this.vantages.push(vantage);\n    return vantage;\n  }\n\n  public draw(p: Cursor.Position<P>): void {\n    this.updateScene(p);\n    for (const vantage of this.vantages) {\n      vantage.render();\n    }\n  }\n\n  public experimentalGetScene(): Scene {\n    return this.scene;\n  }\n\n  public experimentalGetVantages(): Vantage[] {\n    return this.vantages;\n  }\n\n  protected abstract updateScene(p: Cursor.Position<P>): void;\n}\n","import { BackSide, BoxGeometry, DoubleSide, Euler, Group, Matrix4, Mesh, MeshBasicMaterial, Object3D, PlaneGeometry, Quaternion, Vector3 } from \"three\";\nimport { BlockMove } from \"../../alg\";\nimport { KPuzzleDefinition, Puzzles, Transformation } from \"../../kpuzzle\";\n\nimport { Cursor } from \"../cursor\";\nimport { smootherStep } from \"../easing\";\nimport { Puzzle } from \"../puzzle\";\n\nimport { TAU, Twisty3D } from \"./twisty3D\";\n\nclass AxisInfo {\n  public stickerMaterial: MeshBasicMaterial;\n  public hintStickerMaterial: MeshBasicMaterial;\n  constructor(public vector: Vector3, public fromZ: Euler, public color: number) {\n    // TODO: Make sticker material single-sided when cubie base is rendered?\n    this.stickerMaterial = new MeshBasicMaterial({ color, side: DoubleSide });\n    this.hintStickerMaterial = new MeshBasicMaterial({ color, side: BackSide });\n  }\n}\n\nconst axesInfo: AxisInfo[] = [\n  new AxisInfo(new Vector3(0, 1, 0), new Euler(-TAU / 4, 0, 0), 0xffffff),\n  new AxisInfo(new Vector3(-1, 0, 0), new Euler(0, -TAU / 4, 0), 0xff8800),\n  new AxisInfo(new Vector3(0, 0, 1), new Euler(0, 0, 0), 0x00ff00),\n  new AxisInfo(new Vector3(1, 0, 0), new Euler(0, TAU / 4, 0), 0xff0000),\n  new AxisInfo(new Vector3(0, 0, -1), new Euler(0, TAU / 2, 0), 0x0000ff),\n  new AxisInfo(new Vector3(0, -1, 0), new Euler(TAU / 4, 0, 0), 0xffff00),\n];\n\nconst face: { [s: string]: number } = {\n  U: 0,\n  L: 1,\n  F: 2,\n  R: 3,\n  B: 4,\n  D: 5,\n};\n\nconst familyToAxis: { [s: string]: number } = {\n  U: face.U, u: face.U, y: face.U,\n  L: face.L, l: face.L, M: face.L,\n  F: face.F, f: face.F, S: face.F, z: face.F,\n  R: face.R, r: face.R, x: face.R,\n  B: face.B, b: face.B,\n  D: face.D, d: face.D, E: face.D,\n};\n\nconst cubieDimensions = {\n  stickerWidth: 0.85,\n  stickerElevation: 0.501,\n  foundationWidth: 1,\n  hintStickerElevation: 1.45,\n};\n\ntype OptionKey = \"showMainStickers\" | \"showHintStickers\" | \"showFoundation\";\n\ninterface Cube3DOptions {\n  showMainStickers?: boolean;\n  showHintStickers?: boolean;\n  showFoundation?: boolean; // TODO: better name\n}\n\nconst cube3DOptionsDefaults: Cube3DOptions = {\n  showMainStickers: true,\n  showHintStickers: true,\n  showFoundation: true,\n};\n\n// TODO: Make internal foundation faces one-sided, facing to the outside of the cube.\nconst blackMesh = new MeshBasicMaterial({ color: 0x000000, opacity: 0.3, transparent: true });\n\nclass CubieDef {\n  public matrix: Matrix4;\n  public stickerFaces: number[];\n  // stickerFaceNames can be e.g. [\"U\", \"F\", \"R\"], \"UFR\" if every face is a single letter.\n  constructor(public orbit: string, stickerFaceNames: string[] | string, q: Quaternion) {\n    const individualStickerFaceNames = typeof stickerFaceNames === \"string\" ? stickerFaceNames.split(\"\") : stickerFaceNames;\n    this.stickerFaces = individualStickerFaceNames.map((s) => face[s]);\n    this.matrix = new Matrix4();\n    this.matrix.setPosition(firstPiecePosition[orbit]);\n    this.matrix.premultiply(new Matrix4().makeRotationFromQuaternion(q));\n  }\n}\n\nfunction t(v: Vector3, t4: number): Quaternion {\n  return new Quaternion().setFromAxisAngle(v, TAU * t4 / 4);\n}\n\nconst r = {\n  O: new Vector3(0, 0, 0),\n  U: new Vector3(0, -1, 0),\n  L: new Vector3(1, 0, 0),\n  F: new Vector3(0, 0, -1),\n  R: new Vector3(-1, 0, 0),\n  B: new Vector3(0, 0, 1),\n  D: new Vector3(0, 1, 0),\n};\n\ninterface OrbitIndexed<T> { [s: string]: T; }\ninterface PieceIndexed<T> extends OrbitIndexed<T[]> { }\n\nconst firstPiecePosition: OrbitIndexed<Vector3> = {\n  EDGE: new Vector3(0, 1, 1),\n  CORNER: new Vector3(1, 1, 1),\n  CENTER: new Vector3(0, 1, 0),\n};\nconst orientationRotation: OrbitIndexed<Matrix4[]> = {\n  EDGE: [0, 1].map((i) => new Matrix4().makeRotationAxis(firstPiecePosition.EDGE.clone().normalize(), -i * TAU / 2)),\n  CORNER: [0, 1, 2].map((i) => new Matrix4().makeRotationAxis(firstPiecePosition.CORNER.clone().normalize(), -i * TAU / 3)),\n  CENTER: [0, 1, 2, 3].map((i) => new Matrix4().makeRotationAxis(firstPiecePosition.CENTER.clone().normalize(), -i * TAU / 4)),\n};\nconst cubieStickerOrder = [\n  face.U,\n  face.F,\n  face.R,\n];\n\nconst pieceDefs: PieceIndexed<CubieDef> = {\n  EDGE: [\n    new CubieDef(\"EDGE\", \"UF\", t(r.O, 0)),\n    new CubieDef(\"EDGE\", \"UR\", t(r.U, 3)),\n    new CubieDef(\"EDGE\", \"UB\", t(r.U, 2)),\n    new CubieDef(\"EDGE\", \"UL\", t(r.U, 1)),\n    new CubieDef(\"EDGE\", \"DF\", t(r.F, 2)),\n    new CubieDef(\"EDGE\", \"DR\", t(r.F, 2).premultiply(t(r.D, 1))),\n    new CubieDef(\"EDGE\", \"DB\", t(r.F, 2).premultiply(t(r.D, 2))),\n    new CubieDef(\"EDGE\", \"DL\", t(r.F, 2).premultiply(t(r.D, 3))),\n    new CubieDef(\"EDGE\", \"FR\", t(r.U, 3).premultiply(t(r.R, 3))),\n    new CubieDef(\"EDGE\", \"FL\", t(r.U, 1).premultiply(t(r.R, 3))),\n    new CubieDef(\"EDGE\", \"BR\", t(r.U, 3).premultiply(t(r.R, 1))),\n    new CubieDef(\"EDGE\", \"BL\", t(r.U, 1).premultiply(t(r.R, 1))),\n  ],\n  CORNER: [\n    new CubieDef(\"CORNER\", \"UFR\", t(r.O, 0)),\n    new CubieDef(\"CORNER\", \"URB\", t(r.U, 3)),\n    new CubieDef(\"CORNER\", \"UBL\", t(r.U, 2)),\n    new CubieDef(\"CORNER\", \"ULF\", t(r.U, 1)),\n    new CubieDef(\"CORNER\", \"DRF\", t(r.F, 2).premultiply(t(r.D, 1))),\n    new CubieDef(\"CORNER\", \"DFL\", t(r.F, 2).premultiply(t(r.D, 0))),\n    new CubieDef(\"CORNER\", \"DLB\", t(r.F, 2).premultiply(t(r.D, 3))),\n    new CubieDef(\"CORNER\", \"DBR\", t(r.F, 2).premultiply(t(r.D, 2))),\n  ],\n  CENTER: [\n    new CubieDef(\"CENTER\", \"U\", t(r.O, 0)),\n    new CubieDef(\"CENTER\", \"L\", t(r.R, 3).premultiply(t(r.U, 1))),\n    new CubieDef(\"CENTER\", \"F\", t(r.R, 3)),\n    new CubieDef(\"CENTER\", \"R\", t(r.R, 3).premultiply(t(r.D, 1))),\n    new CubieDef(\"CENTER\", \"B\", t(r.R, 3).premultiply(t(r.D, 2))),\n    new CubieDef(\"CENTER\", \"D\", t(r.R, 2)),\n  ],\n};\n\nconst CUBE_SCALE = 1 / 3;\n\n// TODO: Split into \"scene model\" and \"view\".\nexport class Cube3D extends Twisty3D<Puzzle> {\n  private cube: Group = new Group();\n  private pieces: PieceIndexed<Object3D> = {};\n  private options: Cube3DOptions;\n  // TODO: Keep track of option-based meshes better.\n  private experimentalHintStickerMeshes: Mesh[] = [];\n  private experimentalFoundationMeshes: Mesh[] = [];\n  constructor(def: KPuzzleDefinition, options: Cube3DOptions = {}) {\n    super();\n\n    this.options = {};\n    for (const key in cube3DOptionsDefaults) {\n      // TODO:Don't use `any`.\n      this.options[key as OptionKey] = (key in options) ? (options as any)[key] : (cube3DOptionsDefaults as any)[key];\n    }\n\n    if (def.name !== \"3x3x3\") {\n      throw new Error(\"Invalid puzzle for this Cube3D implementation.\");\n    }\n    for (const orbit in pieceDefs) {\n      this.pieces[orbit] = pieceDefs[orbit].map(this.createCubie.bind(this));\n    }\n    this.cube.scale.set(CUBE_SCALE, CUBE_SCALE, CUBE_SCALE);\n    this.scene.add(this.cube);\n  }\n\n  public experimentalGetCube(): Group {\n    return this.cube;\n  }\n\n  public experimentalUpdateOptions(options: Cube3DOptions): void {\n    if (\"showMainStickers\" in options) {\n      throw new Error(\"Unimplemented\");\n    }\n\n    const showFoundation = options.showFoundation;\n    if (typeof showFoundation !== \"undefined\" && this.options.showFoundation !== showFoundation) {\n      this.options.showFoundation = showFoundation;\n      for (const foundation of this.experimentalFoundationMeshes) {\n        foundation.visible = showFoundation;\n      }\n    }\n\n    const showHintStickers = options.showHintStickers;\n    if (typeof showHintStickers !== \"undefined\" && this.options.showHintStickers !== showHintStickers) {\n      this.options.showHintStickers = showHintStickers;\n      for (const hintSticker of this.experimentalHintStickerMeshes) {\n        hintSticker.visible = showHintStickers;\n      }\n    }\n  }\n\n  protected updateScene(p: Cursor.Position<Puzzle>): void {\n    const reid333 = p.state as Transformation;\n    for (const orbit in pieceDefs) {\n      const pieces = pieceDefs[orbit];\n      for (let i = 0; i < pieces.length; i++) {\n        const j = reid333[orbit].permutation[i];\n        this.pieces[orbit][j].matrix.copy(pieceDefs[orbit][i].matrix);\n        this.pieces[orbit][j].matrix.multiply(orientationRotation[orbit][reid333[orbit].orientation[i]]);\n      }\n      for (const moveProgress of p.moves) {\n        const blockMove = moveProgress.move as BlockMove;\n        const turnNormal = axesInfo[familyToAxis[blockMove.family]].vector;\n        const moveMatrix = new Matrix4().makeRotationAxis(turnNormal, - this.ease(moveProgress.fraction) * moveProgress.direction * blockMove.amount * TAU / 4);\n        for (let i = 0; i < pieces.length; i++) {\n          const k = Puzzles[\"3x3x3\"].moves[blockMove.family][orbit].permutation[i];\n          if (i !== k || Puzzles[\"3x3x3\"].moves[blockMove.family][orbit].orientation[i] !== 0) {\n            const j = reid333[orbit].permutation[i];\n            this.pieces[orbit][j].matrix.premultiply(moveMatrix);\n          }\n        }\n      }\n    }\n  }\n\n  // TODO: Always create (but sometimes hide parts) so we can show them later,\n  // or (better) support creating puzzle parts on demand.\n  private createCubie(edge: CubieDef): Object3D {\n    const cubie = new Group();\n    if (this.options.showFoundation) {\n      const foundation = this.createCubieFoundation();\n      cubie.add(foundation);\n      this.experimentalFoundationMeshes.push(foundation);\n    }\n    for (let i = 0; i < edge.stickerFaces.length; i++) {\n      cubie.add(this.createSticker(axesInfo[cubieStickerOrder[i]], axesInfo[edge.stickerFaces[i]], false));\n      if (this.options.showHintStickers) {\n        const hintSticker = this.createSticker(axesInfo[cubieStickerOrder[i]], axesInfo[edge.stickerFaces[i]], true);\n        cubie.add(hintSticker);\n        this.experimentalHintStickerMeshes.push(hintSticker);\n      }\n    }\n    cubie.matrix.copy(edge.matrix);\n    cubie.matrixAutoUpdate = false;\n    this.cube.add(cubie);\n    return cubie;\n  }\n\n  // TODO: Support creating only the outward-facing parts?\n  private createCubieFoundation(): Mesh {\n    const box = new BoxGeometry(cubieDimensions.foundationWidth, cubieDimensions.foundationWidth, cubieDimensions.foundationWidth);\n    return new Mesh(box, blackMesh);\n  }\n\n  private createSticker(posAxisInfo: AxisInfo, materialAxisInfo: AxisInfo, isHint: boolean): Mesh {\n    const geo = new PlaneGeometry(cubieDimensions.stickerWidth, cubieDimensions.stickerWidth);\n    const stickerMesh = new Mesh(geo, isHint ? materialAxisInfo.hintStickerMaterial : materialAxisInfo.stickerMaterial);\n    stickerMesh.setRotationFromEuler(posAxisInfo.fromZ);\n    stickerMesh.position.copy(posAxisInfo.vector);\n    stickerMesh.position.multiplyScalar(isHint ? cubieDimensions.hintStickerElevation : cubieDimensions.stickerElevation);\n    return stickerMesh;\n  }\n\n  private ease(fraction: number): number {\n    return smootherStep(fraction);\n  }\n}\n","import { Color, DoubleSide, Euler, Face3, FaceColors, Geometry, Group, Mesh, MeshBasicMaterial, Object3D, Vector3 } from \"three\";\nimport { BlockMove, modifiedBlockMove } from \"../../alg\";\nimport { KPuzzle, KPuzzleDefinition, stateForBlockMove, Transformation } from \"../../kpuzzle\";\nimport { StickerDatSticker } from \"../../puzzle-geometry\";\nimport { Cursor } from \"../cursor\";\nimport { smootherStep } from \"../easing\";\nimport { Puzzle } from \"../puzzle\";\nimport { TAU, Twisty3D } from \"./twisty3D\";\n\nconst foundationMaterial = new MeshBasicMaterial({ side: DoubleSide, color: 0x000000, transparent: true, opacity: 0.75 });\nconst stickerMaterial = new MeshBasicMaterial({ vertexColors: FaceColors,\n  //    side: DoubleSide,\n}) ;\nconst polyMaterial = new MeshBasicMaterial({ transparent: true, opacity: 0, color: 0x000000 });\n\nclass StickerDef {\n  public origColor: Color;\n  public faceColor: Color;\n  public cubie: Group;\n  protected geo: Geometry;\n  constructor(stickerDat: StickerDatSticker, showFoundation: boolean) {\n    this.origColor = new Color(stickerDat.color);\n    this.faceColor = new Color(stickerDat.color);\n    this.cubie = new Group();\n    this.geo = new Geometry();\n    const coords = stickerDat.coords as number[][];\n    const vertind: number[] = [];\n    for (const coord of coords) {\n      const v = new Vector3(coord[0]!, coord[1]!, coord[2]!);\n      vertind.push(this.geo.vertices.length);\n      this.geo.vertices.push(v);\n    }\n    for (let g = 1; g + 1 < vertind.length; g++) {\n      const face = new Face3(vertind[0], vertind[g], vertind[g + 1]);\n      face.color = this.faceColor;\n      this.geo.faces.push(face);\n    }\n    this.geo.computeFaceNormals();\n    const obj = new Mesh(this.geo, stickerMaterial) ;\n    this.cubie.add(obj);\n    if (showFoundation) {\n      const foundation = new Mesh(this.geo, foundationMaterial);\n      foundation.scale.setScalar(0.99); // TODO: hacky\n      this.cubie.add(foundation);\n    }\n  }\n  public setColor(c: Color): void {\n    this.geo.colorsNeedUpdate = true;\n    this.faceColor.copy(c);\n  }\n}\n\nclass HitPlaneDef {\n  public cubie: Group;\n  protected geo: Geometry;\n  constructor(hitface: any) {\n    this.cubie = new Group();\n    this.geo = new Geometry();\n    const coords = hitface.coords as number[][];\n    const vertind: number[] = [];\n    for (const coord of coords) {\n      const v = new Vector3(coord[0]!, coord[1]!, coord[2]!);\n      vertind.push(this.geo.vertices.length);\n      this.geo.vertices.push(v);\n    }\n    for (let g = 1; g + 1 < vertind.length; g++) {\n      const face = new Face3(vertind[0], vertind[g], vertind[g + 1]);\n      this.geo.faces.push(face);\n    }\n    this.geo.computeFaceNormals();\n    const obj = new Mesh(this.geo, polyMaterial) ;\n    obj.userData.name = hitface.name ;\n    this.cubie.scale.setScalar(0.99);\n    this.cubie.add(obj);\n  }\n}\n\nclass AxisInfo {\n  public axis: Vector3;\n  public order: number;\n  constructor(axisDat: any) {\n    const vec = axisDat[0] as number[];\n    this.axis = new Vector3(vec[0], vec[1], vec[2]);\n    this.order = axisDat[2];\n  }\n}\n\nconst PG_SCALE = 0.5;\n\n// TODO: Split into \"scene model\" and \"view\".\nexport class PG3D extends Twisty3D<Puzzle> {\n  private group: Group = new Group();\n\n  private stickers: { [key: string]: StickerDef[][] };\n  private axesInfo: { [key: string]: AxisInfo };\n\n  private stickerTargets: Object3D[] = [];\n  private controlTargets: Object3D[] = [];\n\n  constructor(private definition: KPuzzleDefinition, pgdat: any, showFoundation: boolean = false) {\n    super();\n    this.axesInfo = {};\n    const axesDef = pgdat.axis as any[];\n    for (const axis of axesDef) {\n      this.axesInfo[axis[1]] = new AxisInfo(axis);\n    }\n    const stickers = pgdat.stickers as any[];\n    this.stickers = {};\n    for (const sticker of stickers) {\n      const orbit = sticker.orbit as number;\n      const ord = sticker.ord as number;\n      const ori = sticker.ori as number;\n      if (!this.stickers[orbit]) {\n        this.stickers[orbit] = [];\n      }\n      if (!this.stickers[orbit][ori]) {\n        this.stickers[orbit][ori] = [];\n      }\n      const stickerdef = new StickerDef(sticker, showFoundation);\n      stickerdef.cubie.scale.set(PG_SCALE, PG_SCALE, PG_SCALE);\n      this.stickers[orbit][ori][ord] = stickerdef;\n      this.group.add(stickerdef.cubie);\n      this.stickerTargets.push(stickerdef.cubie.children[0]);\n    }\n    const hitfaces = pgdat.faces as any[];\n    for (const hitface of hitfaces) {\n      const facedef = new HitPlaneDef(hitface);\n      facedef.cubie.scale.set(PG_SCALE, PG_SCALE, PG_SCALE);\n      this.group.add(facedef.cubie);\n      this.controlTargets.push(facedef.cubie.children[0]);\n    }\n    this.scene.add(this.group);\n  }\n\n  public experimentalGetStickerTargets(): Object3D[] {\n    return this.stickerTargets;\n  }\n\n  public experimentalGetControlTargets(): Object3D[] {\n    return this.controlTargets\n      ;\n  }\n\n  public experimentalGetGroup(): Group {\n    return this.group;\n  }\n\n  protected updateScene(p: Cursor.Position<Puzzle>): void {\n    const pos = p.state as Transformation;\n    const noRotation = new Euler();\n    for (const orbit in this.stickers) {\n      const pieces = this.stickers[orbit];\n      const pos2 = pos[orbit];\n      const orin = pieces.length;\n      for (let ori = 0; ori < orin; ori++) {\n        const pieces2 = pieces[ori];\n        for (let i = 0; i < pieces2.length; i++) {\n          pieces2[i].cubie.rotation.copy(noRotation);\n          const nori = (ori + orin - pos2.orientation[i]) % orin;\n          const ni = pos2.permutation[i];\n          pieces2[i].setColor(pieces[nori][ni].origColor);\n        }\n      }\n    }\n    const kp = new KPuzzle(this.definition);\n    for (const moveProgress of p.moves) {\n      const blockMove = moveProgress.move as BlockMove;\n      const simpleMove = modifiedBlockMove(blockMove, { amount: 1 });\n      const unswizzled = kp.unswizzle(blockMove.family);\n      const baseMove = stateForBlockMove(this.definition, simpleMove);\n      const ax = this.axesInfo[unswizzled];\n      const turnNormal = ax.axis;\n      const angle = - this.ease(moveProgress.fraction) *\n           moveProgress.direction * blockMove.amount * TAU / ax.order;\n      for (const orbit in this.stickers) {\n        const pieces = this.stickers[orbit];\n        const orin = pieces.length;\n        const bmv = baseMove[orbit];\n        for (let ori = 0; ori < orin; ori++) {\n          const pieces2 = pieces[ori];\n          for (let i = 0; i < pieces2.length; i++) {\n            const ni = bmv.permutation[i];\n            if (ni !== i || bmv.orientation[i] !== 0) {\n              pieces2[i].cubie.rotateOnAxis(turnNormal, angle);\n            }\n          }\n        }\n      }\n    }\n  }\n  private ease(fraction: number): number {\n    return smootherStep(fraction);\n  }\n}\n","import { AlgPart, BlockMove, CommentLong, CommentShort, Commutator, Conjugate, expand, Group, NewLine, Pause, Sequence, TraversalDownUp, TraversalUp, Unit } from \"../alg\";\nimport { Puzzle, State } from \"./puzzle\";\n\n// TODO: Include Pause.\nclass CountAnimatedMoves extends TraversalUp<number> {\n  public traverseSequence(sequence: Sequence): number {\n    let total = 0;\n    for (const part of sequence.nestedUnits) {\n      total += this.traverse(part);\n    }\n    return total;\n  }\n  public traverseGroup(group: Group): number {\n    return this.traverseSequence(group.nestedSequence);\n  }\n  public traverseBlockMove(blockMove: BlockMove): number {\n    return 1;\n  }\n  public traverseCommutator(commutator: Commutator): number {\n    return 2 * (this.traverseSequence(commutator.A) + this.traverseSequence(commutator.B));\n  }\n  public traverseConjugate(conjugate: Conjugate): number {\n    return 2 * (this.traverseSequence(conjugate.A)) + this.traverseSequence(conjugate.B);\n  }\n  public traversePause(pause: Pause): number { return 0; }\n  public traverseNewLine(newLine: NewLine): number { return 0; }\n  public traverseCommentShort(commentShort: CommentShort): number { return 0; }\n  public traverseCommentLong(commentLong: CommentLong): number { return 0; }\n}\n\ninterface AlgorithmIndexer<P extends Puzzle> {\n  getMove(index: number): BlockMove;\n  indexToMoveStartTimestamp(index: number): Cursor.Timestamp;\n  stateAtIndex(index: number): State<P>;\n  transformAtIndex(index: number): State<P>;\n  numMoves(): number;\n  timestampToIndex(timestamp: Cursor.Timestamp): number;\n  algDuration(): Cursor.Duration;\n  moveDuration(index: number): number;\n}\n\nclass SimpleAlgorithmIndexer<P extends Puzzle> implements AlgorithmIndexer<P> {\n  private moves: Sequence;\n  // TODO: Allow custom `durationFn`.\n  private durationFn: TraversalUp<Cursor.Duration> = new Cursor.AlgDuration(Cursor.DefaultDurationForAmount);\n  constructor(private puzzle: P, alg: Sequence) {\n    this.moves = expand(alg);\n    // TODO: Avoid assuming all base moves are block moves.\n  }\n  public getMove(index: number): BlockMove {\n    return this.moves.nestedUnits[index] as BlockMove;\n  }\n\n  public indexToMoveStartTimestamp(index: number): Cursor.Timestamp {\n    const seq = new Sequence(this.moves.nestedUnits.slice(0, index));\n    return this.durationFn.traverse(seq);\n  }\n\n  public timestampToIndex(timestamp: Cursor.Timestamp): number {\n    let cumulativeTime = 0;\n    let i;\n    for (i = 0; i < this.numMoves(); i++) {\n      cumulativeTime += this.durationFn.traverseBlockMove(this.getMove(i));\n      if (cumulativeTime >= timestamp) {\n        return i;\n      }\n    }\n    return i;\n  }\n\n  public stateAtIndex(index: number): State<P> {\n    return this.puzzle.combine(this.puzzle.startState(), this.transformAtIndex(index)) ;\n  }\n\n  public transformAtIndex(index: number): State<P> {\n    let state = this.puzzle.identity();\n    for (const move of this.moves.nestedUnits.slice(0, index)) {\n      state = this.puzzle.combine(state, this.puzzle.stateFromMove(move as BlockMove));\n    }\n    return state;\n  }\n\n  public algDuration(): Cursor.Duration {\n    return this.durationFn.traverse(this.moves);\n  }\n\n  public numMoves(): number {\n    // TODO: Cache internally once performance matters.\n    return countAnimatedMoves(this.moves);\n  }\n  public moveDuration(index: number): number {\n    return this.durationFn.traverseBlockMove(this.getMove(index));\n  }\n}\n\nclass AlgPartDecoration<P extends Puzzle> {\n  constructor(puz: Puzzle, public moveCount: number,\n              public duration: number,\n              public forward: State<P>, public backward: State<P>,\n              public children: Array<AlgPartDecoration<P>> = []) {\n  }\n}\nclass DecoratorConstructor<P extends Puzzle> extends TraversalUp<AlgPartDecoration<P>> {\n  private identity: State<P>;\n  private dummyLeaf: AlgPartDecoration<P>;\n  private durationFn: TraversalUp<Cursor.Duration> = new Cursor.AlgDuration(Cursor.DefaultDurationForAmount);\n  constructor(private puz: Puzzle) {\n    super();\n    this.identity = puz.identity();\n    this.dummyLeaf = new AlgPartDecoration<P>(puz, 0, 0, this.identity,\n      this.identity, []);\n  }\n  public traverseSequence(sequence: Sequence): AlgPartDecoration<P> {\n    let moveCount = 0;\n    let duration = 0;\n    let state = this.identity;\n    const child: Array<AlgPartDecoration<P>> = [];\n    for (const part of sequence.nestedUnits) {\n      const apd = this.traverse(part);\n      moveCount += apd.moveCount;\n      duration += apd.duration;\n      state = this.puz.combine(state, apd.forward);\n      child.push(apd);\n    }\n    return new AlgPartDecoration<P>(\n      this.puz, moveCount, duration, state, this.puz.invert(state), child);\n  }\n  public traverseGroup(group: Group): AlgPartDecoration<P> {\n    const dec = this.traverseSequence(group.nestedSequence);\n    return this.mult(dec, group.amount, [dec]);\n  }\n  public traverseBlockMove(blockMove: BlockMove): AlgPartDecoration<P> {\n    return new AlgPartDecoration<P>(\n      this.puz, 1, this.durationFn.traverse(blockMove),\n      this.puz.stateFromMove(blockMove),\n      this.puz.stateFromMove(invertBlockMove(blockMove)));\n  }\n  public traverseCommutator(commutator: Commutator): AlgPartDecoration<P> {\n    const decA = this.traverseSequence(commutator.A);\n    const decB = this.traverseSequence(commutator.B);\n    const AB = this.puz.combine(decA.forward, decB.forward);\n    const ApBp = this.puz.combine(decA.backward, decB.backward);\n    const ABApBp = this.puz.combine(AB, ApBp);\n    const dec = new AlgPartDecoration<P>(this.puz,\n      2 * (decA.moveCount + decB.moveCount), 2 * (decA.duration + decB.duration),\n      ABApBp, this.puz.invert(ABApBp), [decA, decB]);\n    return this.mult(dec, commutator.amount, [dec, decA, decB]);\n  }\n  public traverseConjugate(conjugate: Conjugate): AlgPartDecoration<P> {\n    const decA = this.traverseSequence(conjugate.A);\n    const decB = this.traverseSequence(conjugate.B);\n    const AB = this.puz.combine(decA.forward, decB.forward);\n    const ABAp = this.puz.combine(AB, decA.backward);\n    const dec = new AlgPartDecoration<P>(this.puz,\n      2 * decA.moveCount + decB.moveCount, 2 * decA.duration + decB.duration,\n      ABAp, this.puz.invert(ABAp), [decA, decB]);\n    return this.mult(dec, conjugate.amount, [dec, decA, decB]);\n  }\n  public traversePause(pause: Pause): AlgPartDecoration<P> {\n    return new AlgPartDecoration<P>(this.puz, 1, this.durationFn.traverse(pause), this.identity, this.identity);\n  }\n  public traverseNewLine(newLine: NewLine): AlgPartDecoration<P> {\n    return this.dummyLeaf;\n  }\n  public traverseCommentShort(commentShort: CommentShort): AlgPartDecoration<P> {\n    return this.dummyLeaf;\n  }\n  public traverseCommentLong(commentLong: CommentLong): AlgPartDecoration<P> {\n    return this.dummyLeaf;\n  }\n  private mult(apd: AlgPartDecoration<P>, n: number, child: Array<AlgPartDecoration<P>>): AlgPartDecoration<P> {\n    const absn = Math.abs(n);\n    const st = this.puz.multiply(apd.forward, n);\n    return new AlgPartDecoration<P>(\n      this.puz, apd.moveCount * absn, apd.duration * absn, st,\n      this.puz.invert(st), child);\n  }\n}\nclass WalkerDown<P extends Puzzle> {\n  constructor(public apd: AlgPartDecoration<P>, public back: boolean) {\n    /**/\n  }\n}\nclass AlgWalker<P extends Puzzle> extends TraversalDownUp<WalkerDown<P>, boolean> {\n  public mv?: Unit;\n  public moveDur: number;\n  public back: boolean;\n  public st: State<P>;\n  public root: WalkerDown<P>;\n  public i: number;\n  public dur: number;\n  private goali: number;\n  private goaldur: number;\n  constructor(public puz: P, public alg: AlgPart, public apd: AlgPartDecoration<P>) {\n    super();\n    this.i = -1;\n    this.dur = -1;\n    this.goali = -1;\n    this.goaldur = -1;\n    this.mv = undefined;\n    this.back = false;\n    this.moveDur = 0;\n    this.st = this.puz.identity();\n    this.root = new WalkerDown(this.apd, false);\n  }\n  public moveByIndex(loc: number): boolean {\n    if (this.i >= 0 && this.i === loc) {\n      return this.mv !== undefined;\n    }\n    return this.dosearch(loc, Infinity);\n  }\n  public moveByDuration(dur: number): boolean {\n    if (this.dur >= 0 && this.dur < dur &&\n      this.dur + this.moveDur >= dur) {\n      return this.mv !== undefined;\n    }\n    return this.dosearch(Infinity, dur);\n  }\n  public dosearch(loc: number, dur: number): boolean {\n    this.goali = loc;\n    this.goaldur = dur;\n    this.i = 0;\n    this.dur = 0;\n    this.mv = undefined;\n    this.moveDur = 0;\n    this.back = false;\n    this.st = this.puz.identity();\n    const r = this.traverse(this.alg, this.root);\n    return r;\n  }\n  public traverseSequence(sequence: Sequence, wd: WalkerDown<P>): boolean {\n    if (!this.firstcheck(wd)) {\n      return false;\n    }\n    if (wd.back) {\n      for (let i = sequence.nestedUnits.length - 1; i >= 0; i--) {\n        const part = sequence.nestedUnits[i];\n        if (this.traverse(part, new WalkerDown(wd.apd.children[i], wd.back))) {\n          return true;\n        }\n      }\n    } else {\n      for (let i = 0; i < sequence.nestedUnits.length; i++) {\n        const part = sequence.nestedUnits[i];\n        if (this.traverse(part, new WalkerDown(wd.apd.children[i], wd.back))) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  public traverseGroup(group: Group, wd: WalkerDown<P>): boolean {\n    if (!this.firstcheck(wd)) {\n      return false;\n    }\n    const back = this.domult(wd, group.amount);\n    return this.traverse(group.nestedSequence, new WalkerDown(wd.apd.children[0], back));\n  }\n  public traverseBlockMove(blockMove: BlockMove, wd: WalkerDown<P>): boolean {\n    if (!this.firstcheck(wd)) {\n      return false;\n    }\n    this.mv = blockMove;\n    this.moveDur = wd.apd.duration;\n    this.back = wd.back;\n    return true;\n  }\n  public traverseCommutator(commutator: Commutator, wd: WalkerDown<P>): boolean {\n    if (!this.firstcheck(wd)) {\n      return false;\n    }\n    const back = this.domult(wd, commutator.amount);\n    if (back) {\n      return this.traverse(commutator.B, new WalkerDown(wd.apd.children[2], !back)) ||\n        this.traverse(commutator.A, new WalkerDown(wd.apd.children[1], !back)) ||\n        this.traverse(commutator.B, new WalkerDown(wd.apd.children[2], back)) ||\n        this.traverse(commutator.A, new WalkerDown(wd.apd.children[1], back));\n    } else {\n      return this.traverse(commutator.A, new WalkerDown(wd.apd.children[1], back)) ||\n        this.traverse(commutator.B, new WalkerDown(wd.apd.children[2], back)) ||\n        this.traverse(commutator.A, new WalkerDown(wd.apd.children[1], !back)) ||\n        this.traverse(commutator.B, new WalkerDown(wd.apd.children[2], !back));\n    }\n  }\n  public traverseConjugate(conjugate: Conjugate, wd: WalkerDown<P>): boolean {\n    if (!this.firstcheck(wd)) {\n      return false;\n    }\n    const back = this.domult(wd, conjugate.amount);\n    if (back) {\n      return this.traverse(conjugate.A, new WalkerDown(wd.apd.children[1], !back)) ||\n        this.traverse(conjugate.B, new WalkerDown(wd.apd.children[2], back)) ||\n        this.traverse(conjugate.A, new WalkerDown(wd.apd.children[1], back));\n    } else {\n      return this.traverse(conjugate.A, new WalkerDown(wd.apd.children[1], back)) ||\n        this.traverse(conjugate.B, new WalkerDown(wd.apd.children[2], back)) ||\n        this.traverse(conjugate.A, new WalkerDown(wd.apd.children[1], !back));\n    }\n  }\n  public traversePause(pause: Pause, wd: WalkerDown<P>): boolean {\n    if (!this.firstcheck(wd)) {\n      return false;\n    }\n    this.mv = pause;\n    this.moveDur = wd.apd.duration;\n    this.back = wd.back;\n    return true;\n  }\n  public traverseNewLine(newLine: NewLine, wd: WalkerDown<P>): boolean {\n    return false;\n  }\n  public traverseCommentShort(commentShort: CommentShort, wd: WalkerDown<P>): boolean {\n    return false;\n  }\n  public traverseCommentLong(commentLong: CommentLong, wd: WalkerDown<P>): boolean {\n    return false;\n  }\n  private firstcheck(wd: WalkerDown<P>): boolean {\n    if (wd.apd.moveCount + this.i <= this.goali && wd.apd.duration + this.dur < this.goaldur) {\n      return this.keepgoing(wd);\n    }\n    return true;\n  }\n  private domult(wd: WalkerDown<P>, amount: number): boolean {\n    let back = wd.back;\n    if (amount === 0) { // I don't believe this will ever happen\n      return back;\n    }\n    if (amount < 0) {\n      back = !back;\n      amount = - amount;\n    }\n    const base = wd.apd.children[0];\n    const full = Math.min(Math.floor((this.goali - this.i) / base.moveCount),\n      Math.ceil((this.goaldur - this.dur) / base.duration - 1));\n    if (full > 0) {\n      this.keepgoing(new WalkerDown<P>(base, back), full);\n    }\n    return back;\n  }\n  private keepgoing(wd: WalkerDown<P>, mul: number = 1): boolean {\n    this.i += mul * wd.apd.moveCount;\n    this.dur += mul * wd.apd.duration;\n    if (mul !== 1) {\n      if (wd.back) {\n        this.st = this.puz.combine(this.st, this.puz.multiply(wd.apd.backward, mul));\n      } else {\n        this.st = this.puz.combine(this.st, this.puz.multiply(wd.apd.forward, mul));\n      }\n\n    } else {\n      if (wd.back) {\n        this.st = this.puz.combine(this.st, wd.apd.backward);\n      } else {\n        this.st = this.puz.combine(this.st, wd.apd.forward);\n      }\n    }\n    return false;\n  }\n}\nexport function invertBlockMove(bm: BlockMove): BlockMove {\n  return new BlockMove(bm.outerLayer, bm.innerLayer, bm.family, -bm.amount);\n}\nexport class TreeAlgorithmIndexer<P extends Puzzle> implements AlgorithmIndexer<P> {\n  private decoration: AlgPartDecoration<P>;\n  private walker: AlgWalker<P>;\n  constructor(private puzzle: P, alg: Sequence) {\n    const deccon = new DecoratorConstructor<P>(this.puzzle);\n    this.decoration = deccon.traverse(alg);\n    this.walker = new AlgWalker<P>(this.puzzle, alg, this.decoration);\n  }\n  public getMove(index: number): BlockMove {\n    // FIXME need to support Pause\n    if (this.walker.moveByIndex(index)) {\n      const bm = this.walker.mv! as BlockMove;\n      // TODO: this type of negation needs to be in alg\n      if (this.walker.back) {\n        return invertBlockMove(bm);\n      }\n      return bm;\n    }\n    throw new Error(\"Out of algorithm: index \" + index);\n  }\n  public indexToMoveStartTimestamp(index: number): Cursor.Timestamp {\n    if (this.walker.moveByIndex(index) || this.walker.i === index) {\n      return this.walker.dur;\n    }\n    throw new Error(\"Out of algorithm: index \" + index);\n  }\n  public stateAtIndex(index: number): State<P> {\n    this.walker.moveByIndex(index);\n    return this.puzzle.combine(this.puzzle.startState(), this.walker.st);\n  }\n  public transformAtIndex(index: number): State<P> {\n    this.walker.moveByIndex(index);\n    return this.walker.st;\n  }\n  public numMoves(): number {\n    return this.decoration.moveCount;\n  }\n  public timestampToIndex(timestamp: Cursor.Timestamp): number {\n    this.walker.moveByDuration(timestamp);\n    return this.walker.i;\n  }\n  public algDuration(): Cursor.Duration {\n    return this.decoration.duration;\n  }\n  public moveDuration(index: number): number {\n    this.walker.moveByIndex(index);\n    return this.walker.moveDur;\n  }\n}\n\nconst countAnimatedMovesInstance = new CountAnimatedMoves();\nconst countAnimatedMoves = countAnimatedMovesInstance.traverse.bind(countAnimatedMovesInstance);\n\nclass SingleAnimatedMove<P extends Puzzle> {\n  public algTimestamp: Cursor.Duration ;\n  public moveDuration: Cursor.Duration ;\n  constructor(public priorState: State<P>, public move: BlockMove) {\n    this.moveDuration = Cursor.DefaultDurationForAmount(this.move.amount) ;\n    this.algTimestamp = 0 ;\n  }\n  // return value is: do we kill off the animated move.\n  public doLastMoveDelta(duration: Cursor.Duration): boolean {\n    this.algTimestamp += duration ;\n    if (this.algTimestamp < 0 || this.algTimestamp >= this.moveDuration) {\n      return true ;\n    }\n    return false ;\n  }\n}\n\nexport class Cursor<P extends Puzzle> {\n  private indexer: AlgorithmIndexer<P>;\n  private algTimestamp: Cursor.Duration;\n  private lastMoveData?: SingleAnimatedMove<P>;\n  constructor(public alg: Sequence, private puzzle: P) {\n    this.setMoves(alg);\n    this.setPositionToStart();\n  }\n\n  public experimentalSetMoves(alg: Sequence): void {\n    return this.setMoves(alg);\n  }\n\n  public experimentalUpdateAlgAnimate(alg: Sequence, move: BlockMove): void {\n     const priorState = this.indexer.stateAtIndex(this.indexer.numMoves()) ;\n     this.setMoves(alg) ;\n     this.lastMoveData = new SingleAnimatedMove(priorState, move) ;\n  }\n\n  public setPositionToStart(): void {\n    this.lastMoveData = undefined;\n    this.algTimestamp = 0;\n  }\n\n  public setPositionToEnd(): void {\n    this.lastMoveData = undefined;\n    this.setPositionToStart();\n    this.forward(this.endOfAlg(), false);\n  }\n\n  public startOfAlg(): Cursor.Duration {\n    return 0;\n  }\n\n  public endOfAlg(): Cursor.Duration {\n    return this.indexer.algDuration();\n  }\n\n  public currentPosition(): Cursor.Position<P> {\n    if (this.lastMoveData) {\n      const lmpos = {\n        state: this.lastMoveData.priorState,\n        moves: [],\n      } as Cursor.Position<P>;\n      const lmmove = this.lastMoveData.move;\n      const lmmoveTS = this.lastMoveData.algTimestamp;\n      if (lmmoveTS !== 0) {\n        lmpos.moves.push({\n          move: lmmove,\n          direction: Cursor.Direction.Forwards,\n          fraction: lmmoveTS / this.lastMoveData.moveDuration,\n        });\n      }\n      return lmpos;\n    }\n\n    const moveIdx = this.indexer.timestampToIndex(this.algTimestamp);\n    const pos = {\n      state: this.indexer.stateAtIndex(moveIdx),\n      moves: [],\n    } as Cursor.Position<P>;\n    // handle empty sequence.\n    if (this.indexer.numMoves() === 0) {\n      return pos;\n    }\n    const move = this.indexer.getMove(moveIdx);\n    const moveTS = this.algTimestamp - this.indexer.indexToMoveStartTimestamp(moveIdx);\n    // TODO: this should be done just by asking the indexer for this move's\n    // duration; this will avoid thrashing the tree indexer\n    const moveDuration = this.indexer.indexToMoveStartTimestamp(moveIdx + 1) - this.indexer.indexToMoveStartTimestamp(moveIdx);\n    if (moveTS !== 0) {\n      pos.moves.push({\n        move,\n        direction: Cursor.Direction.Forwards,\n        // TODO: Expose a way to traverse `Unit`s directly?\n        fraction: moveTS / moveDuration,\n      });\n    }\n    return pos;\n  }\n\n  public currentTimestamp(): Cursor.Duration {\n    return this.algTimestamp;\n  }\n\n  public delta(duration: Cursor.Duration, stopAtMoveBoundary: boolean): boolean {\n    if (this.lastMoveData) {\n      if (this.lastMoveData.doLastMoveDelta(duration)) {\n        // finished faking the last move; now skip to end\n        this.lastMoveData = undefined;\n        duration = 1e30;\n        this.algTimestamp = this.indexer.algDuration();\n        // fall through to skip to end\n      } else {\n        return false;\n      }\n    }\n    const moveIdx = this.indexer.timestampToIndex(this.algTimestamp);\n    const unclampedNewTimestamp = this.algTimestamp + duration;\n    const currentMoveStartTimestamp = this.indexer.indexToMoveStartTimestamp(moveIdx);\n    if (stopAtMoveBoundary) {\n      if (unclampedNewTimestamp < currentMoveStartTimestamp) {\n        this.algTimestamp = currentMoveStartTimestamp;\n        return true;\n      }\n      const nextMoveStartTimestamp = currentMoveStartTimestamp + this.indexer.moveDuration(moveIdx);\n      if (unclampedNewTimestamp > nextMoveStartTimestamp) {\n        this.algTimestamp = nextMoveStartTimestamp;\n        return true;\n      }\n    }\n\n    this.algTimestamp = Math.max(0, Math.min(this.indexer.algDuration(), unclampedNewTimestamp));\n    return this.algTimestamp === this.indexer.algDuration();\n  }\n\n  // TODO\n  public experimentalSetDurationScale(scale: number): void {\n    //   this.durationFn = new Cursor.AlgDuration(Cursor.ExperimentalScaledDefaultDurationForAmount.bind(Cursor.ExperimentalScaledDefaultDurationForAmount, scale));\n  }\n\n  // TODO: Avoid assuming a single move at a time.\n  public forward(duration: Cursor.Duration, stopAtEndOfMove: boolean): /* TODO: Remove this. Represents if move breakpoint was reached. */ boolean {\n    return this.delta(duration, stopAtEndOfMove);\n  }\n\n  public backward(duration: Cursor.Duration, stopAtStartOfMove: boolean): /* TODO: Remove this. Represents of move breakpoint was reached. */ boolean {\n    return this.delta(-duration, stopAtStartOfMove);\n  }\n\n  private setMoves(alg: Sequence): void {\n    this.lastMoveData = undefined;\n    if (false) {\n      this.indexer = new SimpleAlgorithmIndexer(this.puzzle, alg);\n    } else {\n      this.indexer = new TreeAlgorithmIndexer(this.puzzle, alg);\n    }\n  }\n}\n\n// tslint:disable-next-line no-namespace // TODO: nested module\nexport namespace Cursor {\n  export type Duration = number; // Duration in milliseconds\n  // TODO: Extend `number`, introduce MoveSequenceTimestamp vs. EpochTimestamp,\n  // force Duration to be a difference.\n  export type Timestamp = Duration; // Duration since a particular epoch.\n\n  export type Fraction = number; // Value from 0 to 1.\n\n  export enum Direction {\n    Forwards = 1,\n    Paused = 0,\n    Backwards = -1,\n  }\n\n  export interface MoveProgress {\n    move: AlgPart;\n    direction: Direction;\n    fraction: number;\n  }\n\n  export interface Position<P extends Puzzle> {\n    state: State<P>;\n    moves: MoveProgress[];\n  }\n\n  export enum BreakpointType {\n    Move,\n    EntireMoveSequence,\n  }\n\n  export type DurationForAmount = (amount: number) => Duration;\n\n  export function ConstantDurationForAmount(amount: number): Duration {\n    return 1000;\n  }\n\n  export function DefaultDurationForAmount(amount: number): Duration {\n    switch (Math.abs(amount)) {\n      case 0:\n        return 0;\n      case 1:\n        return 1000;\n      case 2:\n        return 1500;\n      default:\n        return 2000;\n    }\n  }\n\n  export function ExperimentalScaledDefaultDurationForAmount(scale: number, amount: number): Duration {\n    switch (Math.abs(amount)) {\n      case 0:\n        return 0;\n      case 1:\n        return scale * 1000;\n      case 2:\n        return scale * 1500;\n      default:\n        return scale * 2000;\n    }\n  }\n\n  export class AlgDuration extends TraversalUp<Duration> {\n    // TODO: Pass durationForAmount as Down type instead?\n    constructor(public durationForAmount: (amount: number) => Duration = DefaultDurationForAmount) {\n      super();\n    }\n\n    public traverseSequence(sequence: Sequence): Duration {\n      let total = 0;\n      for (const alg of sequence.nestedUnits) {\n        total += this.traverse(alg);\n      }\n      return total;\n    }\n    public traverseGroup(group: Group): Duration { return group.amount * this.traverse(group.nestedSequence); }\n    public traverseBlockMove(blockMove: BlockMove): Duration { return this.durationForAmount(blockMove.amount); }\n    public traverseCommutator(commutator: Commutator): Duration { return commutator.amount * 2 * (this.traverse(commutator.A) + this.traverse(commutator.B)); }\n    public traverseConjugate(conjugate: Conjugate): Duration { return conjugate.amount * (2 * this.traverse(conjugate.A) + this.traverse(conjugate.B)); }\n    public traversePause(pause: Pause): Duration { return this.durationForAmount(1); }\n    public traverseNewLine(newLine: NewLine): Duration { return this.durationForAmount(1); }\n    public traverseCommentShort(commentShort: CommentShort): Duration { return this.durationForAmount(0); }\n    public traverseCommentLong(commentLong: CommentLong): Duration { return this.durationForAmount(0); }\n  }\n}\n\n// var c = new Cursor(Example.APermCompact);\n// console.log(c.currentPosition());\n// c.forward(4321, false);\n// console.log(c.currentPosition());\n// c.forward(2000, false);\n// console.log(c.currentPosition());\n// c.backward(100, false);\n// console.log(c.currentPosition());\n// c.backward(1800, false);\n// console.log(c.currentPosition());\n// c.forward(605, false);\n// console.log(c.currentPosition());\n// c.forward(10000, true);\n// console.log(c.currentPosition());\n\n// abstract class Position<AlgType extends Algorithm> {\n//   Alg: AlgType;\n//   Direction: Timeline.Direction;\n//   TimeToSubAlg: Timeline.Duration;\n//   SubAlg: Algorithm | null;\n// }\n","import { BlockMove, blockMoveToString } from \"../alg\";\nimport { Combine, EquivalentStates, IdentityTransformation, Invert, KPuzzleDefinition, Puzzles, stateForBlockMove, Transformation } from \"../kpuzzle\";\n\nexport type MoveName = string;\n\nexport interface MoveProgress {\n  blockMove: BlockMove;\n  fraction: number;\n}\n\n// tslint:disable-next-line no-empty-interface\nexport interface State<T extends Puzzle> { }\n\nexport abstract class Puzzle {\n  public abstract startState(): State<Puzzle>;\n  public abstract invert(state: State<Puzzle>): State<Puzzle>;\n  public abstract combine(s1: State<Puzzle>, s2: State<Puzzle>): State<Puzzle>;\n  public multiply(state: State<Puzzle>, amount: number): State<Puzzle> {\n    if (amount < 0) {\n      return this.invert(this.multiply(state, -amount));\n    }\n\n    let newState = this.identity();\n    while (amount > 0) {\n      if (amount % 2 === 1) {\n        newState = this.combine(newState, state);\n      }\n      amount = Math.floor(amount / 2);\n      state = this.combine(state, state);\n    }\n    return newState;\n  }\n  public abstract stateFromMove(blockMove: BlockMove): State<Puzzle>;\n  public abstract identity(): State<Puzzle>;\n  public abstract equivalent(s1: State<Puzzle>, s2: State<Puzzle>): boolean;\n}\n\ninterface KSolvePuzzleState extends Transformation, State<KSolvePuzzle> {\n}\n\nexport class KSolvePuzzle extends Puzzle {\n  // don't work the underlying kdefinition/multiply so hard\n  public static fromID(id: string): KSolvePuzzle {\n    return new KSolvePuzzle(Puzzles[id]);\n  }\n  public moveStash: { [key: string]: Transformation } = {};\n  constructor(private definition: KPuzzleDefinition) {\n    super();\n  }\n\n  public startState(): KSolvePuzzleState {\n    return this.definition.startPieces;\n  }\n  public invert(state: KSolvePuzzleState): KSolvePuzzleState {\n    return Invert(this.definition, state);\n  }\n  public combine(s1: KSolvePuzzleState, s2: KSolvePuzzleState): KSolvePuzzleState {\n    return Combine(this.definition, s1, s2);\n  }\n  public stateFromMove(blockMove: BlockMove): KSolvePuzzleState {\n    const key = blockMoveToString(blockMove);\n    if (!this.moveStash[key]) {\n      this.moveStash[key] = stateForBlockMove(this.definition, blockMove);\n    }\n    return this.moveStash[key];\n  }\n  public identity(): KSolvePuzzleState {\n    return IdentityTransformation(this.definition);\n  }\n  public equivalent(s1: KSolvePuzzleState, s2: KSolvePuzzleState): boolean {\n    return EquivalentStates(this.definition, s1, s2);\n  }\n}\n\nclass QTMCounterState implements State<QTMCounterPuzzle> {\n  constructor(public value: number) { }\n}\n\nexport class QTMCounterPuzzle extends Puzzle {\n  public startState(): QTMCounterState {\n    return new QTMCounterState(0);\n  }\n  public invert(state: QTMCounterState): QTMCounterState {\n    return new QTMCounterState(-state.value);\n  }\n  public combine(s1: QTMCounterState, s2: QTMCounterState): QTMCounterState {\n    return new QTMCounterState(s1.value + s2.value);\n  }\n  public stateFromMove(blockMove: BlockMove): QTMCounterState {\n    return new QTMCounterState(Math.abs(blockMove.amount));\n  }\n  public identity(): QTMCounterState {\n    return new QTMCounterState(0);\n  }\n  public equivalent(s1: QTMCounterState, s2: QTMCounterState): boolean {\n    return s1.value === s2.value;\n  }\n}\n","import { BlockMove } from \"../../alg\";\nimport { experimentalBlockMoveQuantumName } from \"../../alg/traversal\";\nimport { Cursor } from \"../cursor\";\n\ninterface Event {\n  timeStamp: Cursor.Timestamp;\n  move: BlockMove;\n}\n\nexport interface TimelineEntry {\n  event: Event;\n  start: Cursor.Timestamp;\n  end: Cursor.Timestamp;\n}\n\ntype Timeline = TimelineEntry[];\n\nfunction isSameAxis(move1: BlockMove, move2: BlockMove): boolean {\n  const familyRoots = move1.family[0].toLowerCase() + move2.family[0].toLowerCase();\n  // console.log(familyRoots);\n  return [\"uu\", \"ud\", \"du\", \"dd\", \"ll\", \"lr\", \"rl\", \"rr\", \"ff\", \"fb\", \"bf\", \"bb\"].indexOf(familyRoots) !== -1;\n}\n\nexport function toAxes(events: Event[], diameterMs: Cursor.Duration): TimelineEntry[][] {\n  const axes: TimelineEntry[][] = [];\n  const axisMoveTracker = new Map();\n  let lastEntry: TimelineEntry | null = null;\n  for (const event of events) {\n    if (!lastEntry) {\n      lastEntry = {\n        event,\n        start: event.timeStamp - diameterMs / 2,\n        end: event.timeStamp + diameterMs / 2,\n      };\n      axes.push([lastEntry]);\n      axisMoveTracker.set(experimentalBlockMoveQuantumName(lastEntry.event.move), lastEntry);\n      continue;\n    }\n    const newEntry: TimelineEntry = {\n      event,\n      start: event.timeStamp - diameterMs / 2,\n      end: event.timeStamp + diameterMs / 2,\n    };\n    if (isSameAxis(lastEntry.event.move, event.move)) {\n      const quarterName = experimentalBlockMoveQuantumName(newEntry.event.move);\n      // console.log(quarterName);\n      const prev = axisMoveTracker.get(quarterName);\n      // console.log(\"prev\", prev);\n      if (prev && prev.end > newEntry.start && Math.sign(prev.event.move.amount) === Math.sign(newEntry.event.move.amount)) {\n        prev.event.move = new BlockMove(prev.event.move.outerLayer, prev.event.move.innerLayer, prev.event.move.family, prev.event.move.amount + newEntry.event.move.amount);\n      } else {\n        axes[axes.length - 1].push(newEntry);\n        axisMoveTracker.set(quarterName, newEntry);\n      }\n    } else {\n      // console.log(\"--\", algPartToStringForTesting(newEntry.event.move));\n      axes.push([newEntry]);\n      axisMoveTracker.clear();\n      axisMoveTracker.set(experimentalBlockMoveQuantumName(newEntry.event.move), newEntry);\n      if (newEntry.start < lastEntry.end) {\n        const midpoint = (newEntry.start + lastEntry.end) / 2;\n        newEntry.start = midpoint;\n        lastEntry.end = midpoint;\n      }\n    }\n    lastEntry = newEntry;\n  }\n  return axes;\n}\n\n// TODO: turn into an optional param\nconst defaultDiameterMs: Cursor.Duration = 200;\n\nexport function toTimeline(events: Event[], diameterMs: number = defaultDiameterMs): Timeline {\n  const axes: TimelineEntry[][] = toAxes(events, diameterMs);\n  // console.log(axes);\n  return axes.flat();\n}\n\n/*\n\nInput: list of {move: {base, amount}}, centerTime} events sorted by centerTime of halfway through \"quarter\" turns.\nOutput list of {move, centerTime, start, end}\nOptions:\n  - radius # milliseconds\n  - maxImbalance # maximum ratio of (centerTime - end)/(centerTime - start)\n\neventsToTimeline(events):\n  frontier = empty set # only needed for performance, not correctness\n  for e of events:\n    add event to timeline with range {start: e.centerTime - radius, end: e.centerTime + radius}\n    for each event d of the frontier:\n      if d.base == e.base && sign(d.amount) == sign(e.amount): # d and e have the same base move in the same direction:\n        coalesce(d, e)\n        continue outer loop\n      if d.end > e.start and conflicts(d, e):\n        d.end   = min(e.end, (d.centerTime + e.centerTime) / 2)\n        e.start = max(e.end, (d.centerTime + e.centerTime) / 2)\n        remove d from the frontier\n      if d.centerTime < e.centerTime - radius\n        drop d from the frontier # optimization: too old to overlap with future events\n    e.end = min(e.end, e.centerTime + maxImbalance * (e.centerTime - e.start))\n    add e to the frontier\n\ncoalesce(d, e):\n  {\n    start: d.start\n    centerTime: weighted_avg(\n      d.centerTime with weight abs(d.amount)\n      e.centerTime with weight abs(e.amount)\n    )\n    end: e.end\n  }\n\nconflicts(d, e):\n  if d.base == e.base && sign(d.amount) != sign(e.amount):\n    return true\n  # else, depends on the puzzle\n\nThoughts:\n- Alternative to max imbalance: animate first and second part separately?\n- Fingertrick mode: allow an optional overlap amount between any two conflicting moves (possibly depending on the moves)\n\nProperties:\n- An event's start time will never change after it is added.\n- An event might take up less time than it \"can\".\n  - i.e. its start and/or end time could be extended after the algorithm finishes, without overlapping with conflicting moves.\n  - This is an acceptable compromise for simplicity.\n- As written, moves are only removed from the frontier opportunistically. This shouldn't be a problem.\n\n*/\n","import { Cursor } from \"./cursor\";\nimport { Puzzle } from \"./puzzle\";\n\nexport interface CursorObserver {\n  animCursorChanged: (cursor: Cursor<Puzzle>) => void; // TODO cursor.position?\n}\n\nexport interface DirectionObserver {\n  animDirectionChanged: (direction: Cursor.Direction) => void;\n}\n\nexport interface JumpObserver {\n  // Called when the cursor jumps to a position rather than smoothly animating.\n  // Note: this may be called even if the cursor \"jumps\" to the same position.\n  animCursorJumped: () => void;\n}\n\n// export interface BoundsObserver {\n//   animBoundsChanged: (start: Timeline.Duration, end: Timeline.Duration) => void;\n// }\n\n// TODO: Use generics to unify handling the types of observers.\nexport class Dispatcher implements CursorObserver, DirectionObserver {\n  private cursorObservers: Set<CursorObserver> = new Set<CursorObserver>();\n  private directionObservers: Set<DirectionObserver> = new Set<DirectionObserver>();\n  private jumpObservers: Set<JumpObserver> = new Set<JumpObserver>();\n\n  public registerCursorObserver(observer: CursorObserver): void {\n    if (this.cursorObservers.has(observer)) {\n      throw new Error(\"Duplicate cursor observer added.\");\n    }\n    this.cursorObservers.add(observer);\n  }\n\n  public registerDirectionObserver(observer: DirectionObserver): void {\n    if (this.directionObservers.has(observer)) {\n      throw new Error(\"Duplicate direction observer added.\");\n    }\n    this.directionObservers.add(observer);\n  }\n\n  public registerJumpObserver(observer: JumpObserver): void {\n    if (this.jumpObservers.has(observer)) {\n      throw new Error(\"Duplicate direction observer added.\");\n    }\n    this.jumpObservers.add(observer);\n  }\n\n  public animCursorChanged(cursor: Cursor<Puzzle>): void {\n    // TODO: guard against nested changes and test.\n    for (const observer of this.cursorObservers) {\n      observer.animCursorChanged(cursor);\n    }\n  }\n\n  public animDirectionChanged(direction: Cursor.Direction): void {\n    // TODO: guard against nested changes and test.\n    for (const observer of this.directionObservers) {\n      observer.animDirectionChanged(direction);\n    }\n  }\n\n  public animCursorJumped(): void {\n    // TODO: guard against nested changes and test.\n    for (const observer of this.jumpObservers) {\n      observer.animCursorJumped();\n    }\n  }\n}\n\nexport class AnimModel {\n  public dispatcher: Dispatcher = new Dispatcher();\n  private lastCursorTime: Cursor.Timestamp = 0;\n  private direction: Cursor.Direction = Cursor.Direction.Paused;\n  private breakpointType: Cursor.BreakpointType = Cursor.BreakpointType.EntireMoveSequence;\n  private scheduler: FrameScheduler;\n  private tempo: number = 1.5; // TODO: Support setting tempo.\n  // TODO: cache breakpoints instead of re-querying the model constantly.\n  constructor(public cursor: Cursor<Puzzle>) {\n    this.scheduler = new FrameScheduler(this.frame.bind(this));\n  }\n\n  // public getCursor(): Timeline.Duration {\n  //   return this.cursor;\n  // }\n\n  public experimentalGetScheduler(): FrameScheduler {\n    return this.scheduler;\n  }\n\n  public getBounds(): Cursor.Duration[] {\n    return [\n      this.cursor.startOfAlg(),\n      this.cursor.endOfAlg(),\n    ];\n  }\n\n  public isPaused(): boolean {\n    return this.direction === Cursor.Direction.Paused;\n  }\n\n  public skipAndPauseTo(duration: Cursor.Duration): void {\n    this.pause();\n    this.cursor.setPositionToStart();\n    this.cursor.forward(duration, false); // TODO\n    this.scheduler.singleFrame();\n  }\n\n  public playForward(): void {\n    this.setBreakpointType(Cursor.BreakpointType.EntireMoveSequence);\n    this.animateDirection(Cursor.Direction.Forwards);\n  }\n\n  // A simple wrapper for animateDirection(Paused).\n  public pause(): void {\n    this.animateDirection(Cursor.Direction.Paused);\n  }\n\n  public playBackward(): void {\n    this.setBreakpointType(Cursor.BreakpointType.EntireMoveSequence);\n    this.animateDirection(Cursor.Direction.Backwards);\n  }\n\n  public skipToStart(): void {\n    this.skipAndPauseTo(this.cursor.startOfAlg());\n    // TODO: Wait for flash to finish before animating?\n    this.dispatcher.animCursorJumped();\n  }\n\n  public skipToEnd(): void {\n    this.skipAndPauseTo(this.cursor.endOfAlg());\n    // TODO: Wait for flash to finish before animating?\n    this.dispatcher.animCursorJumped();\n  }\n\n  public isAtEnd(): boolean {\n    return this.cursor.currentTimestamp() === this.cursor.endOfAlg();\n  }\n\n  public stepForward(): void {\n    this.cursor.forward(0.1, false); // TODO\n    this.setBreakpointType(Cursor.BreakpointType.Move);\n    this.animateDirection(Cursor.Direction.Forwards);\n  }\n\n  public stepBackward(): void {\n    this.cursor.backward(0.1, false); // TODO\n    this.setBreakpointType(Cursor.BreakpointType.Move);\n    this.animateDirection(Cursor.Direction.Backwards);\n  }\n\n  public togglePausePlayForward(): void {\n    if (this.isPaused()) {\n      this.playForward();\n    } else {\n      this.pause();\n    }\n  }\n\n  private timeScaling(): number {\n    return this.direction * this.tempo;\n  }\n\n  // Update the cursor based on the time since lastCursorTime, and reset\n  // lastCursorTime.\n  private updateCursor(timestamp: Cursor.Timestamp): void {\n    if (this.direction === Cursor.Direction.Paused) {\n      this.lastCursorTime = timestamp;\n      return;\n    }\n\n    // var previousCursor = this.cursor;\n\n    let elapsed = timestamp - this.lastCursorTime;\n    this.lastCursorTime = timestamp;\n    // Workaround for the first frame: https://twitter.com/lgarron/status/794846097445269504\n    if (elapsed < 0) {\n      elapsed = 0;\n    }\n    const reachedMoveBreakpoint = this.cursor.delta(elapsed * this.timeScaling(), this.breakpointType === Cursor.BreakpointType.Move);\n    if (reachedMoveBreakpoint) {\n      this.setDirection(Cursor.Direction.Paused);\n      this.scheduler.stop();\n    }\n  }\n\n  private setDirection(direction: Cursor.Direction): void {\n    // TODO: Handle in frame for debouncing?\n    // (Are there any use cases that need synchoronous observation?)\n    this.direction = direction;\n    this.dispatcher.animDirectionChanged(direction);\n  }\n\n  private frame(timestamp: Cursor.Timestamp): void {\n    this.updateCursor(timestamp);\n    this.dispatcher.animCursorChanged(this.cursor);\n  }\n\n  // TODO: Push this into timeline.\n  private setBreakpointType(breakpointType: Cursor.BreakpointType): void {\n    this.breakpointType = breakpointType;\n  }\n\n  // Animate or pause in the given direction.\n  // Idempotent.\n  private animateDirection(direction: Cursor.Direction): void {\n    if (this.direction === direction) {\n      return;\n    }\n\n    // Update cursor based on previous direction.\n    this.updateCursor(performance.now());\n\n    // Start the new direction.\n    this.setDirection(direction);\n    if (direction === Cursor.Direction.Paused) {\n      this.scheduler.stop();\n    } else {\n      this.scheduler.start();\n    }\n  }\n}\n\nclass FrameScheduler {\n  private animating: boolean = false;\n  private lastRenderTimestamp: Cursor.Timestamp = -1;\n  constructor(private callback: (timestamp: Cursor.Timestamp) => void) { }\n\n  public animFrame(timestamp: Cursor.Timestamp): void {\n    if (timestamp !== this.lastRenderTimestamp) {\n      this.lastRenderTimestamp = timestamp;\n      this.callback(timestamp);\n    }\n    if (this.animating) {\n      // TODO: use same bound frame instead of creating a new binding each frame.\n      requestAnimationFrame(this.animFrame.bind(this));\n    }\n  }\n\n  // Start scheduling frames if not already running.\n  // Idempotent.\n  public start(): void {\n    if (!this.animating) {\n      this.animating = true;\n      requestAnimationFrame(this.animFrame.bind(this));\n    }\n  }\n\n  // Stop scheduling frames (if not already stopped).\n  // Idempotent.\n  public stop(): void {\n    this.animating = false;\n  }\n\n  public singleFrame(): void {\n    // Instantaneously start and stop, since that schedules a single frame iff\n    // there is not already one scheduled.\n    this.start();\n    this.stop();\n  }\n}\n","import { Vector3 } from \"three\";\nimport { algToString, BlockMove, Sequence } from \"../alg\";\nimport { Combine, KPuzzleDefinition, stateForBlockMove, SVG, Transformation } from \"../kpuzzle\";\nimport { StickerDat } from \"../puzzle-geometry\";\nimport { Cube3D } from \"./3D/cube3D\";\nimport { PG3D } from \"./3D/pg3D\";\nimport { AnimModel, CursorObserver, DirectionObserver, JumpObserver } from \"./anim\";\nimport { Cursor } from \"./cursor\";\nimport { Puzzle } from \"./puzzle\";\n\nconst CAMERA_DISTANCE = 5.5;\n\nexport type VisualizationFormat = \"2D\" | \"3D\" | \"PG3D\";\n\ndeclare global {\n  interface Document {\n    mozCancelFullScreen: () => void;\n    msExitFullscreen: () => void;\n    mozFullScreenElement: HTMLElement;\n    msFullscreenElement: HTMLElement;\n    webkitFullscreenElement: HTMLElement;\n  }\n\n  interface Element {\n    mozRequestFullScreen: () => void;\n    msRequestFullscreen: () => void;\n  }\n}\n\nexport function currentFullscreenElement(): Element {\n  return document.fullscreenElement ||\n    document.webkitFullscreenElement ||\n    (document as any).mozFullScreenElement ||\n    (document as any).msFullscreenElement ||\n    document.webkitFullscreenElement;\n}\nexport function fullscreenRequest(element: HTMLElement): void {\n  const requestFullscreen = element.requestFullscreen ||\n    (element as any).mozRequestFullScreen ||\n    (element as any).msRequestFullscreen ||\n    (element as any).webkitRequestFullscreen;\n  requestFullscreen.call(element);\n}\nexport function fullscreenExit(): void {\n  const exitFullscreen = document.exitFullscreen ||\n    (document as any).mozCancelFullScreen ||\n    (document as any).msExitFullscreen ||\n    (document as any).webkitExitFullscreen;\n  exitFullscreen.call(document);\n}\n\n// TODO: Expose this as a config per instance.\nlet showJumpingFlash = true;\nexport function experimentalShowJumpingFlash(show: boolean): void {\n  showJumpingFlash = show;\n}\n\nexport abstract class Button {\n  public element: HTMLButtonElement;\n  constructor(title: string, initialClass: string) {\n    this.element = document.createElement(\"button\");\n    this.element.title = title;\n    // TODO: Handle updating image based on anim state.\n    this.element.classList.add(initialClass);\n    this.element.addEventListener(\"click\", this.onpress.bind(this));\n  }\n\n  public abstract onpress(): void;\n}\n\n// tslint:disable-next-line no-namespace // TODO: nested module?\nexport namespace Button {\n\n  export class Fullscreen extends Button {\n    constructor(private fullscreenElement: HTMLElement) {\n      super(\"Full Screen\", \"fullscreen\");\n    }\n\n    public onpress(): void {\n      if (currentFullscreenElement() === this.fullscreenElement) {\n        fullscreenExit();\n      } else {\n        fullscreenRequest(this.fullscreenElement);\n      }\n    }\n  }\n\n  export class SkipToStart extends Button {\n    constructor(private anim: AnimModel) {\n      super(\"Skip To Start\", \"skip-to-start\");\n    }\n    public onpress(): void { this.anim.skipToStart(); }\n  }\n  export class SkipToEnd extends Button {\n    constructor(private anim: AnimModel) {\n      super(\"Skip To End\", \"skip-to-end\");\n    }\n    public onpress(): void { this.anim.skipToEnd(); }\n  }\n  export class PlayPause extends Button implements DirectionObserver {\n    constructor(private anim: AnimModel) {\n      super(\"Play\", \"play\");\n      this.anim.dispatcher.registerDirectionObserver(this);\n    }\n    public onpress(): void {\n      if (this.anim.isPaused() && this.anim.isAtEnd()) {\n        this.anim.skipToStart();\n      }\n      this.anim.togglePausePlayForward();\n    }\n    public animDirectionChanged(direction: Cursor.Direction): void {\n      // TODO: Handle flash of pause button when pressed while the Twisty is already at the end.\n      const newClass = direction === Cursor.Direction.Paused ? \"play\" : \"pause\";\n      this.element.classList.remove(\"play\", \"pause\");\n      this.element.classList.add(newClass);\n\n      this.element.title = direction === Cursor.Direction.Paused ? \"Play\" : \"Pause\";\n    }\n  }\n  export class StepForward extends Button {\n    constructor(private anim: AnimModel) {\n      super(\"Step forward\", \"step-forward\");\n    }\n    public onpress(): void { this.anim.stepForward(); }\n  }\n  export class StepBackward extends Button {\n    constructor(private anim: AnimModel) {\n      super(\"Step backward\", \"step-backward\");\n    }\n    public onpress(): void { this.anim.stepBackward(); }\n  }\n}\n\nexport class ControlBar {\n  public element: HTMLElement;\n  constructor(anim: AnimModel, twistyElement: HTMLElement) {\n    this.element = document.createElement(\"twisty-control-bar\");\n\n    this.element.appendChild((new Button.Fullscreen(twistyElement)).element);\n    this.element.appendChild((new Button.SkipToStart(anim)).element);\n    this.element.appendChild((new Button.StepBackward(anim)).element);\n    this.element.appendChild((new Button.PlayPause(anim)).element);\n    this.element.appendChild((new Button.StepForward(anim)).element);\n    this.element.appendChild((new Button.SkipToEnd(anim)).element);\n  }\n}\n\nexport class Scrubber implements CursorObserver {\n  public readonly element: HTMLInputElement;\n  constructor(private anim: AnimModel) {\n    this.element = document.createElement(\"input\");\n    this.element.classList.add(\"scrubber\");\n    this.element.type = \"range\";\n\n    this.element.addEventListener(\"input\", this.oninput.bind(this));\n    this.updateFromAnim();\n    this.anim.dispatcher.registerCursorObserver(this);\n  }\n\n  public updateFromAnim(): void {\n    const bounds = this.anim.getBounds();\n    this.element.min = String(bounds[0]);\n    this.element.max = String(bounds[1]);\n    this.element.value = String(this.anim.cursor.currentTimestamp());\n  }\n\n  public animCursorChanged(cursor: Cursor<Puzzle>): void {\n    this.element.value = String(cursor.currentTimestamp());\n    this.updateBackground();\n  }\n\n  public animBoundsChanged(): void {\n    // TODO\n    this.updateBackground();\n  }\n\n  private updateBackground(): void {\n    // TODO: Figure out the most efficient way to do this.\n    // TODO: Pad by the thumb radius at each end.\n    const min = parseInt(this.element.min, 10);\n    const max = parseInt(this.element.max, 10);\n    const value = parseInt(this.element.value, 10);\n    const v = (value - min) / max * 100;\n    this.element.style.background = `linear-gradient(to right, \\\n      rgb(0, 63, 255) 0%, \\\n      rgb(0, 63, 255) ${v}%, \\\n      rgba(0, 0, 0, 0.25) ${v}%, \\\n      rgba(0, 0, 0, 0.25) 100%\\\n      )`;\n  }\n\n  private oninput(): void {\n    // TODO: Ideally, we should prevent this from firing back.\n    this.anim.skipAndPauseTo(parseInt(this.element.value, 10));\n    this.updateBackground();\n  }\n}\n\nexport class CursorTextView implements CursorObserver {\n  public readonly element: HTMLElement;\n  constructor(private anim: AnimModel) {\n    this.element = document.createElement(\"cursor-text-view\");\n    this.element.textContent = String(this.anim.cursor.currentTimestamp());\n    this.anim.dispatcher.registerCursorObserver(this);\n  }\n\n  public animCursorChanged(cursor: Cursor<Puzzle>): void {\n    this.element.textContent = String(Math.floor(cursor.currentTimestamp()));\n  }\n}\n\nexport class CursorTextMoveView implements CursorObserver {\n  public readonly element: HTMLElement;\n  constructor(private anim: AnimModel) {\n    this.element = document.createElement(\"cursor-text-view\");\n    this.anim.dispatcher.registerCursorObserver(this);\n\n    // var durFn = new Cursor.AlgDuration(Cursor.DefaultDurationForAmount); // TODO\n\n    this.animCursorChanged(anim.cursor);\n  }\n\n  public animCursorChanged(cursor: Cursor<Puzzle>): void {\n    const pos = cursor.currentPosition();\n    let s = \"\" + Math.floor(cursor.currentTimestamp());\n    if (pos.moves.length > 0) {\n      // TODO: cache the name.\n      // TODO: Don't wrap in Sequence if we can add toString() to AlgPart interface?\n      s += \" \" + algToString(new Sequence([pos.moves[0].move])) + \" \" + this.formatFraction(pos.moves[0].fraction);\n    }\n    this.element.textContent = s;\n  }\n\n  private formatFraction(k: number): string {\n    return (String(k) + (Math.floor(k) === k ? \".\" : \"\") + \"000000\").slice(0, 5);\n  }\n}\n\nexport class KSolveView implements CursorObserver, JumpObserver {\n  public readonly element: HTMLElement;\n  private svg: SVG;\n  constructor(private anim: AnimModel, private definition: KPuzzleDefinition) {\n    this.element = document.createElement(\"ksolve-svg-view\");\n    this.anim.dispatcher.registerCursorObserver(this);\n    this.anim.dispatcher.registerJumpObserver(this);\n\n    this.svg = new SVG(definition); // TODO: Dynamic puzzle\n    this.element.appendChild(this.svg.element);\n  }\n\n  public animCursorChanged(cursor: Cursor<Puzzle>): void {\n    const pos = cursor.currentPosition();\n    if (pos.moves.length > 0) {\n\n      const move = (pos.moves[0].move as BlockMove);\n\n      const def = this.definition;\n      const partialMove = new BlockMove(move.outerLayer, move.innerLayer, move.family, move.amount * pos.moves[0].direction);\n      const newState = Combine(\n        def,\n        pos.state as Transformation,\n        stateForBlockMove(def, partialMove),\n      );\n      this.svg.draw(this.definition, pos.state as Transformation, newState, pos.moves[0].fraction);\n    } else {\n      this.svg.draw(this.definition, pos.state as Transformation);\n    }\n  }\n\n  public animCursorJumped(): void {\n    if (showJumpingFlash) {\n      this.element.classList.add(\"flash\");\n      setTimeout(() => this.element.classList.remove(\"flash\"), 0);\n    }\n  }\n}\n\ninterface Cube3DViewConfig {\n  experimentalShowBackView?: boolean;\n}\n\nexport class Cube3DView implements CursorObserver, JumpObserver {\n  public readonly element: HTMLElement;\n  private cube3D: Cube3D;\n  constructor(private anim: AnimModel, definition: KPuzzleDefinition, private config: Cube3DViewConfig = {}) {\n    this.element = document.createElement(\"cube3d-view\");\n\n    this.element.tabIndex = 0; // TODO: Use this to capture keyboard input.\n    this.anim.dispatcher.registerCursorObserver(this);\n    this.anim.dispatcher.registerJumpObserver(this);\n\n    this.cube3D = new Cube3D(definition); // TODO: Dynamic puzzle\n\n    const wrapper = document.createElement(\"cube3d-wrapper\");\n    wrapper.classList.add(\"front\");\n    this.element.appendChild(wrapper);\n    setTimeout(() => {\n      this.cube3D.newVantage(wrapper);\n    }, 0);\n\n    if (this.config.experimentalShowBackView ?? false) {\n      this.createBackViewForTesting();\n    }\n  }\n\n  // TODO: Remove\n  public createBackViewForTesting(): void {\n    const wrapper = document.createElement(\"cube3d-wrapper\");\n    wrapper.classList.add(\"back\");\n    this.element.appendChild(wrapper);\n    setTimeout(() => {\n      this.cube3D.newVantage(wrapper, { position: new Vector3(-1.25, -2.5, -2.5) });\n    }, 0);\n  }\n\n  public animCursorChanged(cursor: Cursor<Puzzle>): void {\n    this.cube3D.draw(cursor.currentPosition());\n  }\n\n  public animCursorJumped(): void {\n    if (showJumpingFlash) {\n      this.element.classList.add(\"flash\");\n      setTimeout(() => this.element.classList.remove(\"flash\"), 0);\n    }\n  }\n\n  public experimentalGetCube3D(): Cube3D {\n    return this.cube3D;\n  }\n}\n\ninterface PG3DViewConfig {\n  stickerDat: StickerDat;\n  experimentalPolarVantages?: boolean;\n  sideBySide?: boolean;\n  showFoundation?: boolean;\n}\n\nexport class PG3DView implements CursorObserver, JumpObserver {\n  public readonly element: HTMLElement;\n  private pg3D: PG3D;\n  constructor(private anim: AnimModel, private definition: KPuzzleDefinition, private config: PG3DViewConfig) {\n    this.element = document.createElement(\"cube3d-view\");\n    if (this.config.sideBySide ?? false) {\n      this.element.classList.add(\"side-by-side\");\n    }\n    const wrapper = document.createElement(\"cube3d-wrapper\");\n    wrapper.classList.add(\"front\");\n    this.element.appendChild(wrapper);\n    this.anim.dispatcher.registerCursorObserver(this);\n    this.anim.dispatcher.registerJumpObserver(this);\n\n    this.pg3D = new PG3D(this.definition, this.config.stickerDat, this.config.showFoundation ?? false); // TODO: Dynamic puzzle\n\n    setTimeout(() => {\n      // TODO: Orient all puzzles so that the vertical axis matches the system coordinates.\n      // This config option is currently an alignment hack for Megaminx.\n      const position: Vector3 = this.config.experimentalPolarVantages ? new Vector3(0, 0, -CAMERA_DISTANCE) : new Vector3(0, -CAMERA_DISTANCE * 0.8, -CAMERA_DISTANCE * 0.8);\n      this.pg3D.newVantage(wrapper, { position, shift: this.config.sideBySide ? -1 : 0 });\n    }, 0);\n\n    this.createBackViewForTesting();\n  }\n\n  public animCursorChanged(cursor: Cursor<Puzzle>): void {\n    this.pg3D.draw(cursor.currentPosition());\n  }\n\n  public animCursorJumped(): void {\n    // console.log(\"jumped KSolve\");\n    if (showJumpingFlash) {\n      this.element.classList.add(\"flash\");\n      setTimeout(() => this.element.classList.remove(\"flash\"), 0);\n    }\n  }\n\n  public experimentalGetPG3D(): PG3D {\n    return this.pg3D;\n  }\n\n  // TODO: Remove\n  private createBackViewForTesting(): void {\n    const wrapper = document.createElement(\"cube3d-wrapper\");\n    wrapper.classList.add(\"back\");\n    this.element.appendChild(wrapper);\n    setTimeout(() => {\n      // TODO: Orient all puzzles so that the vertical axis matches the system coordinates.\n      // This config option is currently an alignment hack for Megaminx.\n      const position: Vector3 = this.config.experimentalPolarVantages ? new Vector3(0, 0, CAMERA_DISTANCE) : new Vector3(0, CAMERA_DISTANCE * 0.8, CAMERA_DISTANCE * 0.8);\n      this.pg3D.newVantage(wrapper, { position, shift: this.config.sideBySide ? 1 : 0 });\n    }, 0);\n  }\n}\n\nexport interface PlayerConfig {\n  visualizationFormat?: VisualizationFormat;\n  experimentalShowControls?: boolean;\n  experimentalCube3DViewConfig?: Cube3DViewConfig;\n  experimentalPG3DViewConfig?: PG3DViewConfig;\n}\n\nexport class Player {\n  public element: HTMLElement;\n  public cube3DView: Cube3DView; // TODO\n  public pg3DView: PG3DView; // TODO\n  private scrubber: Scrubber;\n  constructor(private anim: AnimModel, definition: KPuzzleDefinition, private config: PlayerConfig = {}) {\n    this.element = document.createElement(\"player\");\n\n    if (this.config.visualizationFormat === \"PG3D\") {\n      this.element.appendChild((this.pg3DView = new PG3DView(this.anim, definition, config.experimentalPG3DViewConfig!)).element);\n    } else if (this.config.visualizationFormat === \"3D\") {\n      if (definition.name === \"3x3x3\") {\n        this.element.appendChild((this.cube3DView = new Cube3DView(this.anim, definition, this.config.experimentalCube3DViewConfig)).element);\n      } else {\n        console.warn(`3D visualization specified for unsupported puzzle: ${definition.name}. Falling back to 2D.`);\n        this.element.appendChild((new KSolveView(this.anim, definition)).element);\n      }\n    } else {\n      if (!this.config.visualizationFormat && definition.name === \"3x3x3\") {\n        this.element.appendChild((this.cube3DView = new Cube3DView(this.anim, definition, this.config.experimentalCube3DViewConfig)).element);\n      } else {\n        this.element.appendChild((new KSolveView(this.anim, definition)).element);\n      }\n    }\n    this.scrubber = new Scrubber(this.anim);\n    if (this.config.experimentalShowControls ?? true) {\n      this.element.appendChild(this.scrubber.element);\n      this.element.appendChild((new ControlBar(this.anim, this.element)).element);\n      this.element.appendChild((new CursorTextMoveView(this.anim)).element);\n    }\n  }\n\n  public updateFromAnim(): void {\n    this.scrubber.updateFromAnim();\n  }\n}\n","import { BlockMove, Example, experimentalAppendBlockMove, parse, Sequence } from \"../alg\";\nimport { KPuzzleDefinition, Puzzles } from \"../kpuzzle\";\nimport { AnimModel } from \"./anim\";\nimport { Cursor } from \"./cursor\";\nimport { KSolvePuzzle, Puzzle } from \"./puzzle\";\nimport { Player, PlayerConfig } from \"./widget\";\n\nexport class TwistyParams {\n  public alg?: Sequence;\n  public puzzle?: KPuzzleDefinition;\n  public playerConfig?: PlayerConfig;\n}\n\n// TODO: Turn Twisty into a module and move Twisty.Twisty into Twisty proper.\nexport class Twisty {\n  private alg: Sequence;\n  private anim: AnimModel;\n  private cursor: Cursor<Puzzle>;\n  private puzzleDef: KPuzzleDefinition; // TODO: Replace this with a Puzzle instance.\n  private player: Player;\n  private coalesceModFunc: (mv: BlockMove) => number;\n  constructor(public element: Element, config: TwistyParams = {}) {\n    this.alg = config.alg || Example.Niklas;\n    this.puzzleDef = config.puzzle || Puzzles[\"3x3x3\"];\n    this.cursor = new Cursor(this.alg, new KSolvePuzzle(this.puzzleDef));\n    // this.timeline = new Timeline(Example.HeadlightSwaps);\n    this.anim = new AnimModel(this.cursor);\n\n    this.player = new Player(this.anim, this.puzzleDef, config.playerConfig);\n    this.element.appendChild((this.player).element);\n    this.coalesceModFunc = (mv) => 0;\n  }\n\n  // Set the callback function to get the modulo for coalescing from a BlockMove.\n  public setCoalesceModFunc(f: (mv: BlockMove) => number): void {\n    this.coalesceModFunc = f;\n  }\n\n  // Plays the full final move if there is one.\n  public experimentalSetAlg(alg: Sequence, allowAnimation: boolean = false): void {\n    this.cursor.experimentalSetMoves(alg);\n    this.anim.skipToStart();\n    this.alg = alg;\n    this.anim.skipToEnd();\n    this.player.updateFromAnim();\n    if (allowAnimation && this.anim.cursor.currentTimestamp() > 0) {\n      // TODO: This is a hack.\n      this.cursor.backward(0.01, false); // TODO: Give this API to `Cursor`/`AnimModel`.\n      this.cursor.backward(100000, true); // TODO: Give this API to `Cursor`/`AnimModel`.\n      this.anim.stepForward();\n    }\n  }\n  // We append a move as normal, except we animate *just* the last move *even* if\n  // the last move was merged with a previous one.\n  public experimentalSetAlgAnimateBlockMove(alg: Sequence, move: BlockMove): void {\n    this.anim.skipToStart();\n    this.alg = alg;\n    this.anim.skipToEnd();\n    this.cursor.experimentalUpdateAlgAnimate(alg, move);\n    this.player.updateFromAnim();\n    this.anim.stepForward();\n  }\n\n  public experimentalAddMove(move: BlockMove): void {\n    const coalesceMod = this.coalesceModFunc(move);\n    const newAlg = experimentalAppendBlockMove(this.alg, move, true, coalesceMod);\n    this.experimentalSetAlgAnimateBlockMove(newAlg, move);\n  }\n\n  public experimentalGetAnim(): AnimModel {\n    return this.anim;\n  }\n\n  public experimentalGetPlayer(): Player {\n    return this.player;\n  }\n\n  public experimentalGetCursor(): Cursor<Puzzle> {\n    return this.cursor;\n  }\n}\n\nfunction paramsFromTwistyElem(elem: Element): TwistyParams {\n  const params = new TwistyParams();\n\n  const puzzle = elem.getAttribute(\"puzzle\");\n  if (puzzle) {\n    params.puzzle = Puzzles[puzzle];\n  }\n\n  const algo = elem.getAttribute(\"alg\");\n  if (algo) {\n    params.alg = parse(algo); // TODO: parse\n  }\n\n  const visualization = elem.getAttribute(\"visualization\");\n  // TODO: Factor this code out for testing.\n  if (visualization) {\n    if (visualization === \"2D\" || visualization === \"3D\" || visualization === \"PG3D\") {\n      params.playerConfig = { visualizationFormat: visualization };\n    } else {\n      console.warn(`Invalid visualization: ${visualization}`);\n    }\n  }\n\n  return params;\n}\n\n// Initialize a Twisty for the given Element unless the element's\n// `initialization` attribute is set to `custom`.\nfunction autoInitialize(elem: Element): Twisty | null {\n  const ini = elem.getAttribute(\"initialization\");\n  const params = paramsFromTwistyElem(elem);\n  if (ini !== \"custom\") {\n    return new Twisty(elem, params);\n  }\n  return null;\n}\n\nfunction autoInitializePage(): void {\n  const elems = document.querySelectorAll(\"twisty\");\n  if (elems.length > 0) {\n    console.log(`Found ${elems.length} twisty elem${elems.length === 1 ? \"\" : \"s\"} on page.`);\n  }\n\n  elems.forEach(autoInitialize);\n}\n\nif (typeof window !== \"undefined\") {\n  window.addEventListener(\"load\", autoInitializePage);\n}\n"],"names":["smootherStep","x","TAU","Math","PI","useResizeObserver","window","Vantage","[object Object]","element","scene","options","this","camera","PerspectiveCamera","offsetWidth","offsetHeight","position","copy","defaultVantagePosition","lookAt","Vector3","renderer","WebGLRenderer","antialias","alpha","shift","resize","render","ResizeObserver","bind","observe","appendChild","domElement","rafID","requestAnimationFrame","scheduledResize","stats","begin","end","w","h","off","max","floor","yoff","excess","aspect","setViewOffset","updateProjectionMatrix","setPixelRatio","devicePixelRatio","setSize","Twisty3D","Scene","vantage","vantages","push","p","updateScene","AxisInfo","vector","fromZ","color","stickerMaterial","MeshBasicMaterial","side","DoubleSide","hintStickerMaterial","BackSide","axesInfo","Euler","face","U","L","F","R","B","D","familyToAxis","u","y","l","M","f","S","z","r","b","d","E","cubieDimensions","cube3DOptionsDefaults","showMainStickers","showHintStickers","showFoundation","blackMesh","opacity","transparent","CubieDef","orbit","stickerFaceNames","q","individualStickerFaceNames","split","stickerFaces","map","s","matrix","Matrix4","setPosition","firstPiecePosition","premultiply","makeRotationFromQuaternion","t","v","t4","Quaternion","setFromAxisAngle","O","EDGE","CORNER","CENTER","orientationRotation","i","makeRotationAxis","clone","normalize","cubieStickerOrder","pieceDefs","Cube3D","def","super","Group","key","name","Error","pieces","createCubie","cube","scale","set","add","foundation","experimentalFoundationMeshes","visible","hintSticker","experimentalHintStickerMeshes","reid333","state","length","j","permutation","multiply","orientation","moveProgress","moves","blockMove","move","turnNormal","family","moveMatrix","ease","fraction","direction","amount","Puzzles","edge","cubie","createCubieFoundation","createSticker","matrixAutoUpdate","box","BoxGeometry","Mesh","posAxisInfo","materialAxisInfo","isHint","geo","PlaneGeometry","stickerMesh","setRotationFromEuler","multiplyScalar","foundationMaterial","vertexColors","FaceColors","polyMaterial","StickerDef","stickerDat","origColor","Color","faceColor","Geometry","coords","vertind","coord","vertices","g","Face3","faces","computeFaceNormals","obj","setScalar","c","colorsNeedUpdate","HitPlaneDef","hitface","userData","axisDat","vec","axis","order","PG3D","definition","pgdat","axesDef","stickers","sticker","ord","ori","stickerdef","group","stickerTargets","children","hitfaces","facedef","controlTargets","pos","noRotation","pos2","orin","pieces2","rotation","nori","ni","setColor","kp","KPuzzle","simpleMove","modifiedBlockMove","unswizzled","unswizzle","baseMove","stateForBlockMove","ax","angle","bmv","rotateOnAxis","CountAnimatedMoves","TraversalUp","sequence","total","part","nestedUnits","traverse","traverseSequence","nestedSequence","commutator","A","conjugate","pause","newLine","commentShort","commentLong","AlgPartDecoration","puz","moveCount","duration","forward","backward","DecoratorConstructor","Cursor","AlgDuration","DefaultDurationForAmount","identity","dummyLeaf","child","apd","combine","invert","dec","mult","durationFn","stateFromMove","invertBlockMove","decA","decB","AB","ApBp","ABApBp","ABAp","n","absn","abs","st","WalkerDown","back","AlgWalker","TraversalDownUp","alg","dur","goali","goaldur","mv","undefined","moveDur","root","loc","dosearch","Infinity","wd","firstcheck","domult","keepgoing","base","full","min","ceil","mul","bm","BlockMove","outerLayer","innerLayer","TreeAlgorithmIndexer","puzzle","deccon","decoration","walker","index","moveByIndex","startState","timestamp","moveByDuration","countAnimatedMovesInstance","SingleAnimatedMove","priorState","moveDuration","algTimestamp","setMoves","setPositionToStart","indexer","stateAtIndex","numMoves","lastMoveData","endOfAlg","algDuration","lmpos","lmmove","lmmoveTS","Direction","Forwards","moveIdx","timestampToIndex","getMove","moveTS","indexToMoveStartTimestamp","stopAtMoveBoundary","doLastMoveDelta","unclampedNewTimestamp","currentMoveStartTimestamp","nextMoveStartTimestamp","stopAtEndOfMove","delta","stopAtStartOfMove","BreakpointType","durationForAmount","KSolvePuzzle","Puzzle","newState","id","startPieces","Invert","s1","s2","Combine","blockMoveToString","moveStash","IdentityTransformation","EquivalentStates","isSameAxis","move1","move2","familyRoots","toLowerCase","indexOf","toTimeline","events","diameterMs","axes","axisMoveTracker","Map","lastEntry","event","start","timeStamp","experimentalBlockMoveQuantumName","newEntry","quarterName","prev","get","sign","clear","midpoint","toAxes","flat","Dispatcher","Set","observer","cursorObservers","has","directionObservers","jumpObservers","cursor","animCursorChanged","animDirectionChanged","animCursorJumped","AnimModel","Paused","EntireMoveSequence","scheduler","FrameScheduler","frame","startOfAlg","singleFrame","setBreakpointType","animateDirection","Backwards","skipAndPauseTo","dispatcher","currentTimestamp","Move","isPaused","playForward","tempo","lastCursorTime","elapsed","timeScaling","breakpointType","setDirection","stop","updateCursor","performance","now","callback","lastRenderTimestamp","animating","animFrame","showJumpingFlash","experimentalShowJumpingFlash","show","Button","title","initialClass","document","createElement","classList","addEventListener","onpress","Fullscreen","fullscreenElement","webkitFullscreenElement","mozFullScreenElement","msFullscreenElement","exitFullscreen","mozCancelFullScreen","msExitFullscreen","webkitExitFullscreen","call","requestFullscreen","mozRequestFullScreen","msRequestFullscreen","webkitRequestFullscreen","SkipToStart","anim","skipToStart","SkipToEnd","skipToEnd","PlayPause","registerDirectionObserver","isAtEnd","togglePausePlayForward","newClass","remove","StepForward","stepForward","StepBackward","stepBackward","ControlBar","twistyElement","Scrubber","type","oninput","updateFromAnim","registerCursorObserver","bounds","getBounds","String","value","updateBackground","parseInt","style","background","CursorTextMoveView","currentPosition","algToString","Sequence","formatFraction","textContent","k","slice","KSolveView","registerJumpObserver","svg","SVG","partialMove","draw","setTimeout","Cube3DView","config","tabIndex","cube3D","wrapper","newVantage","experimentalShowBackView","createBackViewForTesting","PG3DView","sideBySide","pg3D","experimentalPolarVantages","CAMERA_DISTANCE","Player","visualizationFormat","pg3DView","experimentalPG3DViewConfig","cube3DView","experimentalCube3DViewConfig","console","warn","scrubber","experimentalShowControls","TwistyParams","Twisty","Example","Niklas","puzzleDef","player","playerConfig","coalesceModFunc","allowAnimation","experimentalSetMoves","experimentalUpdateAlgAnimate","coalesceMod","newAlg","experimentalAppendBlockMove","experimentalSetAlgAnimateBlockMove","autoInitialize","elem","ini","getAttribute","params","algo","parse","visualization","paramsFromTwistyElem","elems","querySelectorAll","log","forEach"],"mappings":"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"}