{"version":3,"file":"index-7c514c9b.js","sources":["../../src/puzzle-geometry/Perm.ts","../../src/puzzle-geometry/PermOriSet.ts","../../src/puzzle-geometry/Quat.ts","../../src/puzzle-geometry/PlatonicGenerator.ts","../../src/puzzle-geometry/Puzzles.ts","../../src/puzzle-geometry/PuzzleGeometry.ts","../../src/puzzle-geometry/SchreierSims.ts"],"sourcesContent":["export function zeros(n: number): number[] {\n  const c = Array(n);\n  for (let i = 0; i < n; i++) {\n    c[i] = 0;\n  }\n  return c;\n}\n\nexport function iota(n: number): number[] {\n  const c = Array(n);\n  for (let i = 0; i < n; i++) {\n    c[i] = i;\n  }\n  return c;\n}\n\nexport function identity(n: number): Perm {\n  return new Perm(iota(n));\n}\n\nexport function random(n: number): Perm { // random\n  const c = Array(n);\n  for (let i = 0; i < n; i++) {\n    c[i] = i;\n  }\n  for (let i = 0; i < n; i++) {\n    const j = i + Math.floor((n - i) * Math.random());\n    const t = c[i];\n    c[i] = c[j];\n    c[j] = t;\n  }\n  return new Perm(c);\n}\n\nexport function factorial(a: number): number {\n  let r = 1;\n  while (a > 1) {\n    r *= a;\n    a--;\n  }\n  return r;\n}\n\nfunction gcd(a: number, b: number): number {\n  if (a > b) {\n    const t = a;\n    a = b;\n    b = t;\n  }\n  while (a > 0) {\n    const m = b % a;\n    b = a;\n    a = m;\n  }\n  return b;\n}\n\nexport function lcm(a: number, b: number): number {\n  return a / gcd(a, b) * b;\n}\n\nexport class Perm {\n  public n: number;        // length\n  public p: number[]; // The permutation itself\n  constructor(a: number[]) {\n    this.n = a.length;\n    this.p = a;\n  }\n  public toString(): string { // stringify\n    return \"Perm[\" + this.p.join(\" \") + \"]\";\n  }\n  public mul(p2: Perm): Perm { // multiply\n    const c: number[] = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[i] = p2.p[this.p[i]];\n    }\n    return new Perm(c);\n  }\n  public rmul(p2: Perm): Perm { // multiply the other way\n    const c = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[i] = this.p[p2.p[i]];\n    }\n    return new Perm(c);\n  }\n  public inv(): Perm {\n    const c = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[this.p[i]] = i;\n    }\n    return new Perm(c);\n  }\n  public compareTo(p2: Perm): number { // comparison\n    for (let i = 0; i < this.n; i++) {\n      if (this.p[i] !== p2.p[i]) {\n        return this.p[i] - p2.p[i];\n      }\n    }\n    return 0;\n  }\n  public toGap(): string {\n    const cyc = new Array<string>();\n    const seen = new Array<boolean>(this.n);\n    for (let i = 0; i < this.p.length; i++) {\n      if (seen[i] || this.p[i] === i) {\n        continue;\n      }\n      const incyc = new Array<number>();\n      for (let j = i; !seen[j]; j = this.p[j]) {\n        incyc.push(1 + j);\n        seen[j] = true;\n      }\n      cyc.push(\"(\" + incyc.join(\",\") + \")\");\n    }\n    return cyc.join(\"\");\n  }\n  public order(): number {\n    let r = 1;\n    const seen = new Array<boolean>(this.n);\n    for (let i = 0; i < this.p.length; i++) {\n      if (seen[i] || this.p[i] === i) {\n        continue;\n      }\n      let cs = 0;\n      for (let j = i; !seen[j]; j = this.p[j]) {\n        cs++;\n        seen[j] = true;\n      }\n      r = lcm(r, cs);\n    }\n    return r;\n  }\n}\n","/* tslint:disable no-bitwise */\n/* tslint:disable prefer-for-of */ // TODO\n\nimport { factorial, iota, lcm, Perm, zeros } from \"./Perm\";\nexport class OrbitDef {\n  constructor(public size: number, public mod: number) { }\n  public reassemblySize(): number {\n    return factorial(this.size) * Math.pow(this.mod, this.size);\n  }\n}\nexport class OrbitsDef {\n  constructor(\n    public orbitnames: string[],\n    public orbitdefs: OrbitDef[],\n    public solved: VisibleState,\n    public movenames: string[],\n    public moveops: Transformation[]) { }\n  public toKsolve(name: string, forTwisty: boolean): string[] {\n    const result = [];\n    result.push(\"Name \" + name);\n    result.push(\"\");\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      result.push(\"Set \" + this.orbitnames[i] + \" \" +\n        this.orbitdefs[i].size + \" \" + this.orbitdefs[i].mod);\n    }\n    result.push(\"\");\n    result.push(\"Solved\");\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      result.push(this.orbitnames[i]);\n      const o = this.solved.orbits[i].toKsolveVS();\n      result.push(o[0]);\n      result.push(o[1]);\n    }\n    result.push(\"End\");\n    result.push(\"\");\n    for (let i = 0; i < this.movenames.length; i++) {\n      result.push(\"Move \" + this.movenames[i]);\n      for (let j = 0; j < this.orbitnames.length; j++) {\n        if (!forTwisty && this.moveops[i].orbits[j].isIdentity()) {\n          continue;\n        }\n        result.push(this.orbitnames[j]);\n        const o = this.moveops[i].orbits[j].toKsolve();\n        result.push(o[0]);\n        result.push(o[1]);\n      }\n      result.push(\"End\");\n      result.push(\"\");\n    }\n    // extra blank line on end lets us use join(\"\\n\") to terminate all\n    return result;\n  }\n  public toKpuzzle(): object {\n    const orbits: { [orbitName: string]: any } = {} ;\n    const start: { [orbitName: string]: any } = {} ;\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      orbits[this.orbitnames[i]] = { numPieces: this.orbitdefs[i].size,\n                        orientations: this.orbitdefs[i].mod } ;\n      start[this.orbitnames[i]] = this.solved.orbits[i].toKpuzzle() ;\n    }\n    const moves: { [moveName: string]: any } = {} ;\n    for (let i = 0; i < this.movenames.length; i++) {\n      const mp: { [orbitName: string]: any } = {} ;\n      for (let j = 0; j < this.orbitnames.length; j++) {\n        mp[this.orbitnames[j]] = this.moveops[i].orbits[j].toKpuzzle() ;\n      }\n      moves[this.movenames[i]] = mp ;\n    }\n    return { orbits, startPieces: start, moves } ;\n  }\n  public optimize(): OrbitsDef {\n    const neworbitnames: string[] = [];\n    const neworbitdefs: OrbitDef[] = [];\n    const newsolved: Orbit[] = [];\n    const newmoveops: Orbit[][] = [];\n    for (let j = 0; j < this.moveops.length; j++) {\n      newmoveops.push([]);\n    }\n    for (let i = 0; i < this.orbitdefs.length; i++) {\n      const om = this.orbitdefs[i].mod;\n      const n = this.orbitdefs[i].size;\n      const du = new DisjointUnion(n);\n      const changed = new Array<boolean>(this.orbitdefs[i].size);\n      for (let k = 0; k < n; k++) {\n        changed[k] = false;\n      }\n      for (let j = 0; j < this.moveops.length; j++) {\n        for (let k = 0; k < n; k++) {\n          if (this.moveops[j].orbits[i].perm[k] !== k ||\n            this.moveops[j].orbits[i].ori[k] !== 0) {\n            changed[k] = true;\n            du.union(k, this.moveops[j].orbits[i].perm[k]);\n          }\n        }\n      }\n      let keepori = true;\n      // right now we kill ori only if solved is unique and\n      // if we can kill it completely.  This is not all the optimization\n      // we can perform.\n      if (om > 1) {\n        keepori = false;\n        const duo = new DisjointUnion(this.orbitdefs[i].size * om);\n        for (let j = 0; j < this.moveops.length; j++) {\n          for (let k = 0; k < n; k++) {\n            if (this.moveops[j].orbits[i].perm[k] !== k ||\n              this.moveops[j].orbits[i].ori[k] !== 0) {\n              for (let o = 0; o < om; o++) {\n                duo.union(k * om + o, this.moveops[j].orbits[i].perm[k] * om +\n                  (o + this.moveops[j].orbits[i].ori[k]) % om);\n              }\n            }\n          }\n        }\n        for (let j = 0; !keepori && j < n; j++) {\n          for (let o = 1; o < om; o++) {\n            if (duo.find(j * om) === duo.find(j * om + o)) {\n              keepori = true;\n            }\n          }\n        }\n        for (let j = 0; !keepori && j < n; j++) {\n          for (let k = 0; k < j; k++) {\n            if (this.solved.orbits[i].perm[j] ===\n              this.solved.orbits[i].perm[k]) {\n              keepori = true;\n            }\n          }\n        }\n      }\n      // is there just one result set, or more than one?\n      let nontriv = -1;\n      let multiple = false;\n      for (let j = 0; j < this.orbitdefs[i].size; j++) {\n        if (changed[j]) {\n          const h = du.find(j);\n          if (nontriv < 0) {\n            nontriv = h;\n          } else if (nontriv !== h) {\n            multiple = true;\n          }\n        }\n      }\n      for (let j = 0; j < this.orbitdefs[i].size; j++) {\n        if (!changed[j]) {\n          continue;\n        }\n        const h = du.find(j);\n        if (h !== j) {\n          continue;\n        }\n        const no: number[] = [];\n        const on: number[] = [];\n        let nv = 0;\n        for (let k = 0; k < this.orbitdefs[i].size; k++) {\n          if (du.find(k) === j) {\n            no[nv] = k;\n            on[k] = nv;\n            nv++;\n          }\n        }\n        if (multiple) {\n          neworbitnames.push(this.orbitnames[i] + \"_p\" + j);\n        } else {\n          neworbitnames.push(this.orbitnames[i]);\n        }\n        if (keepori) {\n          neworbitdefs.push(new OrbitDef(nv, this.orbitdefs[i].mod));\n          newsolved.push(this.solved.orbits[i].remapVS(no, nv));\n          for (let k = 0; k < this.moveops.length; k++) {\n            newmoveops[k].push(this.moveops[k].orbits[i].remap(no, on, nv));\n          }\n        } else {\n          neworbitdefs.push(new OrbitDef(nv, 1));\n          newsolved.push(this.solved.orbits[i].remapVS(no, nv).killOri());\n          for (let k = 0; k < this.moveops.length; k++) {\n            newmoveops[k].push(this.moveops[k].orbits[i].\n              remap(no, on, nv).killOri());\n          }\n        }\n      }\n    }\n    return new OrbitsDef(neworbitnames, neworbitdefs,\n      new VisibleState(newsolved), this.movenames,\n      newmoveops.map((_) => new Transformation(_)));\n  }\n  // generate a new \"solved\" position based on scrambling\n  // we use an algorithm that should be faster for large puzzles than\n  // just picking random moves.\n  public scramble(n: number): void {\n    const pool: Transformation[] = [];\n    for (let i = 0; i < this.moveops.length; i++) {\n      pool[i] = this.moveops[i];\n    }\n    for (let i = 0; i < pool.length; i++) {\n      const j = Math.floor(Math.random() * pool.length);\n      const t = pool[i];\n      pool[i] = pool[j];\n      pool[j] = t;\n    }\n    if (n < pool.length) {\n      n = pool.length;\n    }\n    for (let i = 0; i < n; i++) {\n      const ri = Math.floor(Math.random() * pool.length);\n      const rj = Math.floor(Math.random() * pool.length);\n      const rm = Math.floor(Math.random() * this.moveops.length);\n      pool[ri] = pool[ri].mul(pool[rj]).mul(this.moveops[rm]);\n      if (Math.random() < 0.1) { // break up parity\n        pool[ri] = pool[ri].mul(this.moveops[rm]);\n      }\n    }\n    let s = pool[0];\n    for (let i = 1; i < pool.length; i++) {\n      s = s.mul(pool[i]);\n    }\n    this.solved = this.solved.mul(s);\n  }\n  public reassemblySize(): number {\n    let n = 1;\n    for (let i = 0; i < this.orbitdefs.length; i++) {\n      n *= this.orbitdefs[i].reassemblySize();\n    }\n    return n;\n  }\n}\nexport class Orbit {\n  public static e(n: number, mod: number): Orbit {\n    return new Orbit(iota(n), zeros(n), mod);\n  }\n  constructor(\n    public perm: number[],\n    public ori: number[],\n    public orimod: number) { }\n  public mul(b: Orbit): Orbit {\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n);\n    const newOri = new Array<number>(n);\n    for (let i = 0; i < n; i++) {\n      newPerm[i] = this.perm[b.perm[i]];\n      newOri[i] = (this.ori[b.perm[i]] + b.ori[i]) % this.orimod;\n    }\n    return new Orbit(newPerm, newOri, this.orimod);\n  }\n  public inv(): Orbit {\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n);\n    const newOri = new Array<number>(n);\n    for (let i = 0; i < n; i++) {\n      newPerm[this.perm[i]] = i;\n      newOri[this.perm[i]] = (this.orimod - this.ori[i]) % this.orimod;\n    }\n    return new Orbit(newPerm, newOri, this.orimod);\n  }\n  public equal(b: Orbit): boolean {\n    const n = this.perm.length;\n    for (let i = 0; i < n; i++) {\n      if (this.perm[i] !== b.perm[i] || this.ori[i] !== b.ori[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  // in-place mutator\n  public killOri(): this {\n    const n = this.perm.length;\n    for (let i = 0; i < n; i++) {\n      this.ori[i] = 0;\n    }\n    this.orimod = 1;\n    return this;\n  }\n  public toPerm(): Perm {\n    const o = this.orimod;\n    if (o === 1) {\n      return new Perm(this.perm);\n    }\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n * o);\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < o; j++) {\n        newPerm[i * o + j] = o * this.perm[i] + (this.ori[i] + j) % o;\n      }\n    }\n    return new Perm(newPerm);\n  }\n  // returns tuple of sets of identical pieces in this orbit\n  public identicalPieces(): number[][] {\n    const done: boolean[] = [];\n    const n = this.perm.length;\n    const r: number[][] = [];\n    for (let i = 0; i < n; i++) {\n      const v = this.perm[i];\n      if (done[v] === undefined) {\n        const s: number[] = [i];\n        done[v] = true;\n        for (let j = i + 1; j < n; j++) {\n          if (this.perm[j] === v) {\n            s.push(j);\n          }\n        }\n        r.push(s);\n      }\n    }\n    return r;\n  }\n  public order(): number { // can be made more efficient\n    return this.toPerm().order();\n  }\n  public isIdentity(): boolean {\n    const n = this.perm.length;\n    for (let i = 0; i < n; i++) {\n      if (this.perm[i] !== i || this.ori[i] !== 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n  public remap(no: number[], on: number[], nv: number): Orbit {\n    const newPerm = new Array<number>(nv);\n    const newOri = new Array<number>(nv);\n    for (let i = 0; i < nv; i++) {\n      newPerm[i] = on[this.perm[no[i]]];\n      newOri[i] = this.ori[no[i]];\n    }\n    return new Orbit(newPerm, newOri, this.orimod);\n  }\n  public remapVS(no: number[], nv: number): Orbit {\n    const newPerm = new Array<number>(nv);\n    const newOri = new Array<number>(nv);\n    let nextNew = 0;\n    const reassign = [];\n    for (let i = 0; i < nv; i++) {\n      const ov = this.perm[no[i]];\n      if (reassign[ov] === undefined) {\n        reassign[ov] = nextNew++;\n      }\n      newPerm[i] = reassign[ov];\n      newOri[i] = this.ori[no[i]];\n    }\n    return new Orbit(newPerm, newOri, this.orimod);\n  }\n  public toKsolveVS(): string[] {\n    return [this.perm.map((_: number) => _ + 1).join(\" \"), this.ori.join(\" \")];\n  }\n  public toKsolve(): string[] {\n    const newori = new Array<number>(this.ori.length);\n    for (let i = 0; i < newori.length; i++) {\n      newori[this.perm[i]] = this.ori[i];\n    }\n    return [this.perm.map((_: number) => _ + 1).join(\" \"), newori.join(\" \")];\n  }\n  public toKpuzzle(): object {\n    return { permutation: this.perm, orientation: this.ori } ;\n  }\n}\nexport class TransformationBase {\n  constructor(public orbits: Orbit[]) { }\n  public internalMul(b: TransformationBase): Orbit[] {\n    const newOrbits: Orbit[] = [];\n    for (let i = 0; i < this.orbits.length; i++) {\n      newOrbits.push(this.orbits[i].mul(b.orbits[i]));\n    }\n    return newOrbits;\n  }\n  public internalInv(): Orbit[] {\n    const newOrbits: Orbit[] = [];\n    for (let i = 0; i < this.orbits.length; i++) {\n      newOrbits.push(this.orbits[i].inv());\n    }\n    return newOrbits;\n  }\n  public equal(b: TransformationBase): boolean {\n    for (let i = 0; i < this.orbits.length; i++) {\n      if (!this.orbits[i].equal(b.orbits[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  public killOri(): this {\n    for (let i = 0; i < this.orbits.length; i++) {\n      this.orbits[i].killOri();\n    }\n    return this;\n  }\n  public toPerm(): Perm {\n    const perms = new Array<Perm>();\n    let n = 0;\n    for (let i = 0; i < this.orbits.length; i++) {\n      const p = this.orbits[i].toPerm();\n      perms.push(p);\n      n += p.n;\n    }\n    const newPerm = new Array<number>(n);\n    n = 0;\n    for (let i = 0; i < this.orbits.length; i++) {\n      const p = perms[i];\n      for (let j = 0; j < p.n; j++) {\n        newPerm[n + j] = n + p.p[j];\n      }\n      n += p.n;\n    }\n    return new Perm(newPerm);\n  }\n  public identicalPieces(): number[][] {\n    const r: number[][] = [];\n    let n = 0;\n    for (let i = 0; i < this.orbits.length; i++) {\n      const o = this.orbits[i].orimod;\n      const s = this.orbits[i].identicalPieces();\n      for (let j = 0; j < s.length; j++) {\n        r.push(s[j].map((_) => _ * o + n));\n      }\n      n += o * this.orbits[i].perm.length;\n    }\n    return r;\n  }\n  public order(): number {\n    let r = 1;\n    for (let i = 0; i < this.orbits.length; i++) {\n      r = lcm(r, this.orbits[i].order());\n    }\n    return r;\n  }\n}\nexport class Transformation extends TransformationBase {\n  constructor(orbits: Orbit[]) {\n    super(orbits);\n  }\n  public mul(b: Transformation): Transformation {\n    return new Transformation(this.internalMul(b));\n  }\n  public mulScalar(n: number): Transformation {\n    if (n === 0) {\n      return this.e();\n    }\n    let t: Transformation = this;\n    if (n < 0) {\n      t = t.inv();\n      n = - n;\n    }\n    while ((n & 1) === 0) {\n      t = t.mul(t);\n      n >>= 1;\n    }\n    if (n === 1) {\n      return t;\n    }\n    let s = t;\n    let r = this.e();\n    while (n > 0) {\n      if (n & 1) {\n        r = r.mul(s);\n      }\n      if (n > 1) {\n        s = s.mul(s);\n      }\n      n >>= 1;\n    }\n    return r;\n  }\n  public inv(): Transformation {\n    return new Transformation(this.internalInv());\n  }\n  public e(): Transformation {\n    return new Transformation(this.orbits.map(\n      (_: Orbit) => Orbit.e(_.perm.length, _.orimod)));\n  }\n}\nexport class VisibleState extends TransformationBase {\n  constructor(orbits: Orbit[]) {\n    super(orbits);\n  }\n  public mul(b: Transformation): VisibleState {\n    return new VisibleState(this.internalMul(b));\n  }\n}\n//  Disjoint set union implementation.\nclass DisjointUnion {\n  public heads: number[];\n  constructor(public n: number) {\n    this.heads = new Array<number>(n);\n    for (let i = 0; i < n; i++) {\n      this.heads[i] = i;\n    }\n  }\n  public find(v: number): number {\n    let h = this.heads[v];\n    if (this.heads[h] === h) {\n      return h;\n    }\n    h = this.find(this.heads[h]);\n    this.heads[v] = h;\n    return h;\n  }\n  public union(a: number, b: number): void {\n    const ah = this.find(a);\n    const bh = this.find(b);\n    if (ah < bh) {\n      this.heads[bh] = ah;\n    } else if (ah > bh) {\n      this.heads[ah] = bh;\n    }\n  }\n}\nexport function showcanon(g: OrbitsDef, disp: (s: string) => void): void {\n  // show information for canonical move derivation\n  const n = g.moveops.length;\n  if (n > 30) {\n    throw new Error(\"Canon info too big for bitmask\");\n  }\n  const orders = [];\n  const commutes = [];\n  for (let i = 0; i < n; i++) {\n    const permA = g.moveops[i];\n    orders.push(permA.order());\n    let bits = 0;\n    for (let j = 0; j < n; j++) {\n      if (j === i) {\n        continue;\n      }\n      const permB = g.moveops[j];\n      if (permA.mul(permB).equal(permB.mul(permA))) {\n        bits |= 1 << j;\n      }\n    }\n    commutes.push(bits);\n  }\n  let curlev: any = {};\n  curlev[0] = 1;\n  for (let d = 0; d < 100; d++) {\n    let sum = 0;\n    const nextlev: any = {};\n    let uniq = 0;\n    for (const sti in curlev) {\n      const st = +sti; // string to number\n      const cnt = curlev[st];\n      sum += cnt;\n      uniq++;\n      for (let mv = 0; mv < orders.length; mv++) {\n        if (((st >> mv) & 1) === 0 &&\n          (st & commutes[mv] & ((1 << mv) - 1)) === 0) {\n          const nst = (st & commutes[mv]) | (1 << mv);\n          if (nextlev[nst] === undefined) {\n            nextlev[nst] = 0;\n          }\n          nextlev[nst] += (orders[mv] - 1) * cnt;\n        }\n      }\n    }\n    disp(\"\" + d + \": canonseq \" + sum + \" states \" + uniq);\n    curlev = nextlev;\n  }\n}\n// This is a less effective canonicalization (that happens to work fine\n// for the 3x3x3).  We include this only for comparison.\nexport function showcanon0(g: OrbitsDef, disp: (s: string) => void): void {\n  // show information for canonical move derivation\n  const n = g.moveops.length;\n  if (n > 30) {\n    throw new Error(\"Canon info too big for bitmask\");\n  }\n  const orders = [];\n  const commutes = [];\n  for (let i = 0; i < n; i++) {\n    const permA = g.moveops[i];\n    orders.push(permA.order());\n    let bits = 0;\n    for (let j = 0; j < n; j++) {\n      if (j === i) {\n        continue;\n      }\n      const permB = g.moveops[j];\n      if (permA.mul(permB).equal(permB.mul(permA))) {\n        bits |= 1 << j;\n      }\n    }\n    commutes.push(bits);\n  }\n  let curlev: any = {};\n  disp(\"\" + 0 + \": canonseq \" + 1);\n  for (let x = 0; x < orders.length; x++) {\n    curlev[x] = orders[x] - 1;\n  }\n  for (let d = 1; d < 100; d++) {\n    let sum = 0;\n    const nextlev: any = {};\n    let uniq = 0;\n    for (const sti in curlev) {\n      const st = +sti; // string to number\n      const cnt = curlev[st];\n      sum += cnt;\n      uniq++;\n      for (let mv = 0; mv < orders.length; mv++) {\n        if (mv === st || ((commutes[mv] & (1 << st)) && mv < st)) {\n          continue;\n        }\n        if (nextlev[mv] === undefined) {\n          nextlev[mv] = 0;\n        }\n        nextlev[mv] += (orders[mv] - 1) * cnt;\n      }\n    }\n    disp(\"\" + d + \": canonseq \" + sum + \" states \" + uniq);\n    curlev = nextlev;\n  }\n}\n","/* tslint:disable no-bitwise */\n/* tslint:disable prefer-for-of */ // TODO\n\n// We need a quaternion class.  We use this to represent rotations,\n// planes, and points.\n\nconst eps = 1e-9; // TODO: Deduplicate with `PuzzleGeometry`?\n\nexport function expandfaces(rots: Quat[], faces: Quat[][]): Quat[][] {\n  // given a set of faces, expand by rotation set\n  const nfaces = [];\n  for (let i = 0; i < rots.length; i++) {\n    for (let k = 0; k < faces.length; k++) {\n      const face = faces[k];\n      const nface = [];\n      for (let j = 0; j < face.length; j++) {\n        nface.push(face[j].rotateplane(rots[i]));\n      }\n      nfaces.push(nface);\n    }\n  }\n  return nfaces;\n}\n\nexport function centermassface(face: Quat[]): Quat {\n  // calculate a center of a face by averaging points\n  let s = new Quat(0, 0, 0, 0);\n  for (let i = 0; i < face.length; i++) {\n    s = s.sum(face[i]);\n  }\n  return s.smul(1.0 / face.length);\n}\n\nexport function random(): Quat { // generate a random quat\n  const q = new Quat(Math.random() * 2 - 1, Math.random() * 2 - 1,\n    Math.random() * 2 - 1, Math.random() * 2 - 1);\n  return q.smul(1 / q.len());\n}\n\nexport function solvethreeplanes(p1: number, p2: number, p3: number, planes: Quat[]): any {\n  // find intersection of three planes but only if interior\n  // Takes three indices into a plane array, and returns the point at the\n  // intersection of all three, but only if it is internal to all planes.\n  const p = planes[p1].intersect3(planes[p2], planes[p3]);\n  if (!p) {\n    return p;\n  }\n  for (let i = 0; i < planes.length; i++) {\n    if (i !== p1 && i !== p2 && i !== p3) {\n      const dt = planes[i].b * p.b + planes[i].c * p.c + planes[i].d * p.d;\n      if ((planes[i].a > 0 && dt > planes[i].a) ||\n        (planes[i].a < 0 && dt < planes[i].a)) {\n        return false;\n      }\n    }\n  }\n  return p;\n}\n\nexport class Quat {\n  constructor(public a: number, public b: number, public c: number, public d: number) {\n  }\n  public mul(q: Quat): Quat { // Quaternion multiplication\n    return new Quat(\n      this.a * q.a - this.b * q.b - this.c * q.c - this.d * q.d,\n      this.a * q.b + this.b * q.a + this.c * q.d - this.d * q.c,\n      this.a * q.c - this.b * q.d + this.c * q.a + this.d * q.b,\n      this.a * q.d + this.b * q.c - this.c * q.b + this.d * q.a);\n  }\n  public toString(): string {\n    return \"Q[\" + this.a + \",\" + this.b + \",\" + this.c + \",\" + this.d + \"]\";\n  }\n  public dist(q: Quat): number { // Euclidean distance\n    return Math.hypot(this.a - q.a, this.b - q.b, this.c - q.c, this.d - q.d);\n  }\n  public len(): number { // Euclidean length\n    return Math.hypot(this.a, this.b, this.c, this.d);\n  }\n  public cross(q: Quat): Quat { // cross product\n    return new Quat(0, this.c * q.d - this.d * q.c,\n      this.d * q.b - this.b * q.d, this.b * q.c - this.c * q.b);\n  }\n  public dot(q: Quat): number { // dot product of two quaternions\n    return this.b * q.b + this.c * q.c + this.d * q.d;\n  }\n  public normalize(): Quat { // make the magnitude be 1\n    const d = Math.sqrt(this.dot(this));\n    return new Quat(this.a / d, this.b / d, this.c / d, this.d / d);\n  }\n  public makenormal(): Quat { // make a normal vector from a plane or quat or point\n    return new Quat(0, this.b, this.c, this.d).normalize();\n  }\n  public normalizeplane(): Quat { // normalize a plane\n    const d = Math.hypot(this.b, this.c, this.d);\n    return new Quat(this.a / d, this.b / d, this.c / d, this.d / d);\n  }\n  public smul(m: number): Quat { // scalar multiplication\n    return new Quat(this.a * m, this.b * m, this.c * m, this.d * m);\n  }\n  public sum(q: Quat): Quat { // quaternion sum\n    return new Quat(this.a + q.a, this.b + q.b, this.c + q.c, this.d + q.d);\n  }\n  public sub(q: Quat): Quat { // difference\n    return new Quat(this.a - q.a, this.b - q.b, this.c - q.c, this.d - q.d);\n  }\n  public angle(): number { // quaternion angle\n    return 2 * Math.acos(this.a);\n  }\n  public invrot(): Quat { // quaternion inverse rotation\n    return new Quat(this.a, -this.b, -this.c, -this.d);\n  }\n  public det3x3(\n    a00: number, a01: number, a02: number,\n    a10: number, a11: number, a12: number,\n    a20: number, a21: number, a22: number): number {\n    // 3x3 determinant\n    return a00 * (a11 * a22 - a12 * a21) +\n      a01 * (a12 * a20 - a10 * a22) +\n      a02 * (a10 * a21 - a11 * a20);\n  }\n  public rotateplane(q: Quat): Quat { // rotate a plane using a quaternion\n    const t = q.mul(new Quat(0, this.b, this.c, this.d)).mul(q.invrot());\n    t.a = this.a;\n    return t;\n  }\n  public rotatepoint(q: Quat): Quat { // rotate a point\n    return q.mul(this).mul(q.invrot());\n  }\n  public rotateface(face: Quat[]): Quat[] { // rotate a face by this Q.\n    const that = this;\n    return face.map((_: Quat) => _.rotatepoint(that));\n  }\n  public rotatecubie(cubie: Quat[][]): Quat[][] { // rotate a cubie by this Q.\n    const that = this;\n    return cubie.map((_: Quat[]) => that.rotateface(_));\n  }\n  public intersect3(p2: Quat, p3: Quat): Quat | false { // intersect three planes if there is one\n    const det = this.det3x3(this.b, this.c, this.d,\n      p2.b, p2.c, p2.d,\n      p3.b, p3.c, p3.d);\n    if (Math.abs(det) < eps) {\n      return false; // TODO: Change to `null` or `undefined`?\n    }\n    return new Quat(0,\n      this.det3x3(this.a, this.c, this.d,\n        p2.a, p2.c, p2.d, p3.a, p3.c, p3.d) / det,\n      this.det3x3(this.b, this.a, this.d,\n        p2.b, p2.a, p2.d, p3.b, p3.a, p3.d) / det,\n      this.det3x3(this.b, this.c, this.a,\n        p2.b, p2.c, p2.a, p3.b, p3.c, p3.a) / det);\n  }\n  public side(x: number): number {\n    // is this point close to the origin, or on one or the other side?\n    if (x > eps) {\n      return 1;\n    }\n    if (x < -eps) {\n      return -1;\n    }\n    return 0;\n  }\n  public cutfaces(faces: Quat[][]): Quat[][] {\n    // Cut a set of faces by a plane and return new set\n    const that = this; // welcome to Javascript\n    const d = this.a;\n    const nfaces = [];\n    for (let j = 0; j < faces.length; j++) {\n      const face = faces[j];\n      const inout = face.map((_: Quat) => that.side(_.dot(that) - d));\n      let seen = 0;\n      for (let i = 0; i < inout.length; i++) {\n        seen |= 1 << (inout[i] + 1);\n      }\n      if ((seen & 5) === 5) { // saw both sides\n        for (let s = -1; s <= 1; s += 2) {\n          const nface = [];\n          for (let k = 0; k < face.length; k++) {\n            if (inout[k] === s || inout[k] === 0) {\n              nface.push(face[k]);\n            }\n            const kk = (k + 1) % face.length;\n            if (inout[k] + inout[kk] === 0 && inout[k] !== 0) {\n              const vk = face[k].dot(this) - d;\n              const vkk = face[kk].dot(this) - d;\n              const r = vk / (vk - vkk);\n              const pt = face[k].smul(1 - r).sum(face[kk].smul(r));\n              nface.push(pt);\n            }\n          }\n          nfaces.push(nface);\n        }\n      } else { // no split\n        nfaces.push(face);\n      }\n    }\n    return nfaces;\n  }\n  public faceside(face: Quat[]): number { // which side of a plane is a face on?\n    const d = this.a;\n    for (let i = 0; i < face.length; i++) {\n      const s = this.side(face[i].dot(this) - d);\n      if (s !== 0) {\n        return s;\n      }\n    }\n    throw new Error(\"Could not determine side of plane in faceside\");\n  }\n  public sameplane(p: Quat): boolean { // are two planes the same?\n    const a = this.normalize();\n    const b = p.normalize();\n    return a.dist(b) < eps || a.dist(b.smul(-1)) < eps;\n  }\n  public makecut(r: number): Quat { // make a cut from a normal vector\n    return new Quat(r, this.b, this.c, this.d);\n  }\n}\n","/* tslint:disable prefer-for-of */ // TODO\n\nimport { Quat, solvethreeplanes } from \"./Quat\";\n\n// Next we define a class that yields quaternion generators for each of\n// the five platonic solids.  The quaternion generators chosen are\n// chosen specifically so that the first quaternion doubles as a plane\n// description that yields the given Platonic solid (so for instance, the\n// cubical group and octahedral group are identical in math, but we\n// give distinct representations choosing the first quaternion so that\n// we get the desired figure.)  Our convention is one vertex of the\n// shape points precisely down.\n\n// This class is static.\n\nconst eps = 1e-9; // TODO: Deduplicate with `PuzzleGeometry`?\n\nexport function cube(): Quat[] {\n  const s5 = Math.sqrt(0.5);\n  return [new Quat(s5, s5, 0, 0), new Quat(s5, 0, s5, 0)];\n}\n\nexport function tetrahedron(): Quat[] {\n  return [new Quat(0.5, 0.5, 0.5, 0.5), new Quat(0.5, 0.5, 0.5, -0.5)];\n}\n\nexport function dodecahedron(): Quat[] {\n  const d36 = 2 * Math.PI / 10;\n  let dx = 0.5 + 0.3 * Math.sqrt(5);\n  let dy = 0.5 + 0.1 * Math.sqrt(5);\n  const dd = Math.sqrt(dx * dx + dy * dy);\n  dx /= dd;\n  dy /= dd;\n  return [new Quat(Math.cos(d36), dx * Math.sin(d36), dy * Math.sin(d36), 0),\n  new Quat(0.5, 0.5, 0.5, 0.5)];\n}\n\nexport function icosahedron(): Quat[] {\n  let dx = 1 / 6 + Math.sqrt(5) / 6;\n  let dy = 2 / 3 + Math.sqrt(5) / 3;\n  const dd = Math.sqrt(dx * dx + dy * dy);\n  dx /= dd;\n  dy /= dd;\n  const ang = 2 * Math.PI / 6;\n  return [new Quat(Math.cos(ang), dx * Math.sin(ang), dy * Math.sin(ang), 0),\n  new Quat(Math.cos(ang), -dx * Math.sin(ang), dy * Math.sin(ang), 0)];\n}\n\nexport function octahedron(): Quat[] {\n  const s5 = Math.sqrt(0.5);\n  return [new Quat(0.5, 0.5, 0.5, 0.5), new Quat(s5, 0, 0, s5)];\n}\n\nexport function closure(g: Quat[]): Quat[] {\n  // compute the closure of a set of generators\n  // This is quadratic in the result size.  Also, it has no protection\n  // against you providing a bogus set of generators that would generate\n  // an infinite group.\n  const q = [new Quat(1, 0, 0, 0)];\n  for (let i = 0; i < q.length; i++) {\n    for (let j = 0; j < g.length; j++) {\n      const ns = g[j].mul(q[i]);\n      const negns = ns.smul(-1);\n      let wasseen = false;\n      for (let k = 0; k < q.length; k++) {\n        if (ns.dist(q[k]) < eps ||\n          negns.dist(q[k]) < eps) {\n          wasseen = true;\n          break;\n        }\n      }\n      if (!wasseen) {\n        q.push(ns);\n      }\n    }\n  }\n  return q;\n}\n\nexport function uniqueplanes(p: Quat, g: Quat[]): Quat[] {\n  // compute unique plane rotations\n  // given a rotation group and a plane, find the rotations that\n  // generate unique planes.  This is quadratic in the return size.\n  const planes = [];\n  const planerot = [];\n  for (let i = 0; i < g.length; i++) {\n    const p2 = p.rotateplane(g[i]);\n    let wasseen = false;\n    for (let j = 0; j < planes.length; j++) {\n      if (p2.dist(planes[j]) < eps) {\n        wasseen = true;\n        break;\n      }\n    }\n    if (!wasseen) {\n      planes.push(p2);\n      planerot.push(g[i]);\n    }\n  }\n  return planerot;\n}\n\nexport function getface(planes: Quat[]): Quat[] {\n  // compute a face given a set of planes\n  // The face returned will be a set of points that lie in the first plane\n  // in the given array, that are on the surface of the polytope defined\n  // by all the planes, and will be returned in clockwise order.\n  // This is O(planes^2 * return size + return_size^2).\n  const face = [];\n  for (let i = 1; i < planes.length; i++) {\n    for (let j = i + 1; j < planes.length; j++) {\n      const p = solvethreeplanes(0, i, j, planes);\n      if (p) {\n        let wasseen = false;\n        for (let k = 0; k < face.length; k++) {\n          if (p.dist(face[k]) < eps) {\n            wasseen = true;\n            break;\n          }\n        }\n        if (!wasseen) {\n          face.push(p);\n        }\n      }\n    }\n  }\n  while (true) {\n    let changed = false;\n    for (let i = 0; i < face.length; i++) {\n      const j: number = (i + 1) % face.length;\n      if (planes[0].dot(face[i].cross(face[j])) < 0) {\n        const t: Quat = face[i];\n        face[i] = face[j];\n        face[j] = t;\n        changed = true;\n      }\n    }\n    if (!changed) {\n      break;\n    }\n  }\n  return face;\n}\n","export type PuzzleDescriptionString = string;\n\nexport const Puzzles: { [name: string]: PuzzleDescriptionString } = {\n  \"2x2x2\": \"c f 0\",\n  \"3x3x3\": \"c f 0.333333333333333\",\n  \"4x4x4\": \"c f 0.5 f 0\",\n  \"5x5x5\": \"c f 0.6 f 0.2\",\n  \"6x6x6\": \"c f 0.666666666666667 f 0.333333333333333 f 0\",\n  \"7x7x7\": \"c f 0.714285714285714 f 0.428571428571429 f 0.142857142857143\",\n  \"8x8x8\": \"c f 0.75 f 0.5 f 0.25 f 0\",\n  \"9x9x9\": \"c f 0.777777777777778 f 0.555555555555556 f 0.333333333333333 f 0.111111111111111\",\n  \"10x10x10\": \"c f 0.8 f 0.6 f 0.4 f 0.2 f 0\",\n  \"11x11x11\": \"c f 0.818181818181818 f 0.636363636363636 f 0.454545454545455 f 0.272727272727273 f 0.0909090909090909\",\n  \"12x12x12\": \"c f 0.833333333333333 f 0.666666666666667 f 0.5 f 0.333333333333333 f 0.166666666666667 f 0\",\n  \"13x13x13\": \"c f 0.846153846153846 f 0.692307692307692 f 0.538461538461538 f 0.384615384615385 f 0.230769230769231 f 0.0769230769230769\",\n  \"20x20x20\": \"c f 0 f .1 f .2 f .3 f .4 f .5 f .6 f .7 f .8 f .9\",\n  \"30x30x30\": \"c f 0 f .066667 f .133333 f .2 f .266667 f .333333 f .4 f .466667 f .533333 f .6 f .666667 f .733333 f .8 f .866667 f .933333\",\n  \"skewb\": \"c v 0\",\n  \"master skewb\": \"c v 0.275\",\n  \"professor skewb\": \"c v 0 v 0.38\",\n  \"compy cube\": \"c v 0.915641442663986\",\n  \"helicopter\": \"c e 0.707106781186547\",\n  \"dino\": \"c v 0.577350269189626\",\n  \"little chop\": \"c e 0\",\n  \"pyramorphix\": \"t e 0\",\n  \"mastermorphix\": \"t e 0.346184634065199\",\n  \"pyraminx\": \"t v 0.333333333333333 v 1.66666666666667\",\n  \"Jing pyraminx\": \"t f 0\",\n  \"master paramorphix\": \"t e 0.866025403784437\",\n  \"megaminx\": \"d f 0.7\",\n  \"gigaminx\": \"d f 0.64 f 0.82\",\n  \"pentultimate\": \"d f 0\",\n  \"starminx\": \"d v 0.93796236956\",\n  \"starminx 2\": \"d f 0.23606797749979\",\n  \"pyraminx crystal\": \"d f 0.447213595499989\",\n  \"chopasaurus\": \"d v 0\",\n  \"big chop\": \"d e 0\",\n  \"skewb diamond\": \"o f 0\",\n  \"FTO\": \"o f 0.333333333333333\",\n  \"Christopher's jewel\": \"o v 0.577350269189626\",\n  \"octastar\": \"o e 0\",\n  \"Trajber's octahedron\": \"o v 0.433012701892219\",\n  \"radio chop\": \"i f 0\",\n  \"icosamate\": \"i v 0\",\n  \"icosahedron 2\": \"i v 0.18759247376021\",\n  \"icosahedron 3\": \"i v 0.18759247376021 e 0\",\n  \"icosahedron static faces\": \"i v 0.84\",\n  \"icosahedron moving faces\": \"i v 0.73\",\n  \"Eitan's star\": \"i f 0.61803398874989\",\n  \"2x2x2 + dino\": \"c f 0 v 0.577350269189626\",\n  \"2x2x2 + little chop\": \"c f 0 e 0\",\n  \"dino + little chop\": \"c v 0.577350269189626 e 0\",\n  \"2x2x2 + dino + little chop\": \"c f 0 v 0.577350269189626 e 0\",\n  \"megaminx + chopasaurus\": \"d f 0.61803398875 v 0\",\n  \"starminx combo\": \"d f 0.23606797749979 v 0.93796236956\",\n};\n\nexport type PuzzleName = keyof typeof Puzzles;\n","/* tslint:disable no-bitwise */\n/* tslint:disable prefer-for-of */ // TODO\n/* tslint:disable only-arrow-functions */ // TODO\n/* tslint:disable typedef */ // TODO\n\nimport { Perm } from \"./Perm\";\nimport { Orbit, OrbitDef, OrbitsDef, showcanon, Transformation, VisibleState } from \"./PermOriSet\";\nimport { closure, cube, dodecahedron, getface, icosahedron, octahedron, tetrahedron, uniqueplanes } from \"./PlatonicGenerator\";\nimport { PuzzleDescriptionString, Puzzles } from \"./Puzzles\";\nimport { centermassface, expandfaces, Quat } from \"./Quat\";\n\nexport interface StickerDatSticker {\n  coords: number[][];\n  color: string;\n  orbit: string;\n  ord: number;\n  ori: number;\n}\n\nexport interface StickerDatFace {\n  coords: number[][];\n  name: string;\n}\n\nexport type StickerDatAxis = [number[], string, number];\n\nexport interface StickerDat {\n  stickers: StickerDatSticker[];\n  faces: StickerDatFace[];\n  axis: StickerDatAxis[];\n}\n\n//  Now we have a geometry class that does the 3D goemetry to calculate\n//  individual sticker information from a Platonic solid and a set of\n//  cuts.  The cuts must have the same symmetry as the Platonic solid;\n//  we even restrict them further to be either vertex-normal,\n//  edge-normal, or face-parallel cuts.  Right now our constructor takes\n//  a character solid indicator (one of c(ube), o(ctahedron), i(cosahedron),\n//  t(etradron), or d(odecahedron), followed by an array of cuts.\n//  Each cut is a character normal indicator that is either f(ace),\n//  e(dge), or v(ertex), followed by a floating point value that gives\n//  the depth of the cut where 0 is the center and 1 is the outside\n//  border of the shape in that direction.\n\n//  This is a heavyweight class with lots of members and construction\n//  is slow.  Be gentle.\n\n//  Everything except a very few methods should be considered private.\n\nconst eps: number = 1e-9;\nconst copyright = \"PuzzleGeometry 0.1 Copyright 2018 Tomas Rokicki.\";\n\n// This is a description of the nets and the external names we give each\n// face.  The names should be a set of prefix-free upper-case alphabetics\n// so\n// we can easily also name and distinguish vertices and edges, but we\n// may change this in the future.  The nets consist of a list of lists.\n// Each list gives the name of a face, and then the names of the\n// faces connected to that face (in the net) in clockwise order.\n// The length of each list should be one more than the number of\n// edges in the regular polygon for that face.  All polygons must\n// have the same number of edges.\n// The first two faces in the first list must describe a horizontal edge\n// that is at the bottom of a regular polygon.  The first two faces in\n// every subsequent list for a given polytope must describe a edge that\n// is directly connected in the net and has already been described (this\n// sets the location and orientation of the polygon for that face.\n// Any edge that is not directly connected in the net should be given\n// the empty string as the other face.  All faces do not need to have\n// a list starting with that face; just enough to describe the full\n// connectivity of the net.\n//\nconst defaultnets: any = {\n  4: // four faces: tetrahedron\n    [\n      [\"F\", \"D\", \"L\", \"R\"],\n    ],\n  6: // six faces: cube\n    [\n      [\"F\", \"D\", \"L\", \"U\", \"R\"],\n      [\"R\", \"F\", \"\", \"B\", \"\"],\n    ],\n  8: // eight faces: octahedron\n    [\n      [\"F\", \"D\", \"L\", \"R\"],\n      [\"D\", \"F\", \"N\", \"\"],\n      [\"N\", \"D\", \"\", \"B\"],\n      [\"B\", \"N\", \"U\", \"M\"],\n    ],\n  12: // twelve faces:  dodecahedron; U/F/R/F/BL/BR from megaminx\n    [\n      [\"U\", \"F\", \"\", \"\", \"\", \"\"],\n      [\"F\", \"U\", \"R\", \"C\", \"A\", \"L\"],\n      [\"R\", \"F\", \"\", \"\", \"E\", \"\"],\n      [\"E\", \"R\", \"\", \"BF\", \"\", \"\"],\n      [\"BF\", \"E\", \"BR\", \"BL\", \"I\", \"D\"],\n    ],\n  20: // twenty faces: icosahedron\n    [\n      [\"R\", \"C\", \"F\", \"E\"],\n      [\"F\", \"R\", \"L\", \"U\"],\n      [\"L\", \"F\", \"A\", \"\"],\n      [\"E\", \"R\", \"G\", \"I\"],\n      [\"I\", \"E\", \"S\", \"H\"],\n      [\"S\", \"I\", \"J\", \"B\"],\n      [\"B\", \"S\", \"K\", \"D\"],\n      [\"K\", \"B\", \"M\", \"O\"],\n      [\"O\", \"K\", \"P\", \"N\"],\n      [\"P\", \"O\", \"Q\", \"\"],\n    ],\n};\n\nconst defaultcolors: any = {\n  // the colors should use the same naming convention as the nets, above.\n  4: { F: \"#00ff00\", D: \"#ffff00\", L: \"#ff0000\", R: \"#0000ff\" },\n  6: {\n    U: \"#ffffff\", F: \"#00ff00\", R: \"#ff0000\",\n    D: \"#ffff00\", B: \"#0000ff\", L: \"#ff8000\",\n  },\n  8: {\n    U: \"#e085b9\", F: \"#080d99\", R: \"#c1e35c\", D: \"#22955e\",\n    B: \"#9121ab\", L: \"#b27814\", M: \"#0d35ad\", N: \"#eb126b\",\n  },\n  12: {\n    U: \"#ffffff\", F: \"#006633\", R: \"#ff0000\", C: \"#ffffd0\",\n    A: \"#3399ff\", L: \"#660099\", E: \"#ff66cc\", BF: \"#99ff00\",\n    BR: \"#0000ff\", BL: \"#ffff00\", I: \"#ff6633\", D: \"#999999\",\n  },\n  20: {\n    R: \"#db69f0\", C: \"#178fde\", F: \"#23238b\", E: \"#9cc726\",\n    L: \"#2c212d\", U: \"#177fa7\", A: \"#e0de7f\", G: \"#2b57c0\",\n    I: \"#41126b\", S: \"#4b8c28\", H: \"#7c098d\", J: \"#7fe7b4\",\n    B: \"#85fb74\", K: \"#3f4bc3\", D: \"#0ff555\", M: \"#f1c2c8\",\n    O: \"#58d340\", P: \"#c514f2\", N: \"#14494e\", Q: \"#8b1be1\",\n  },\n};\n\n// the default precedence of the faces is given here.  This permits\n// the orientations to be reasonably predictable.  There are tradeoffs;\n// some face precedence orders do better things to the edge orientations\n// than the corner orientations and some are the opposite.\nconst defaultfaceorders: any = {\n  4: [\"F\", \"D\", \"L\", \"R\"],\n  6: [\"U\", \"D\", \"F\", \"B\", \"L\", \"R\"],\n  8: [\"F\", \"B\", \"D\", \"U\", \"N\", \"L\", \"R\", \"M\"],\n  12: [\"L\", \"E\", \"F\", \"BF\", \"R\", \"I\",\n    \"U\", \"D\", \"BR\", \"A\", \"BL\", \"C\"],\n  20: [\"L\", \"S\", \"E\", \"O\", \"F\", \"B\", \"I\", \"P\", \"R\", \"K\",\n    \"U\", \"D\", \"J\", \"A\", \"Q\", \"H\", \"G\", \"N\", \"M\", \"C\"],\n};\n\nfunction findelement(a: any[], p: Quat): number {\n  // find something in facenames, vertexnames, edgenames\n  for (let i = 0; i < a.length; i++) {\n    if (a[i][0].dist(p) < eps) {\n      return i;\n    }\n  }\n  throw new Error(\"Element not found\");\n}\n\nexport function getpuzzles(): { [s: string]: PuzzleDescriptionString } {\n  // get some simple definitions of basic puzzles\n  return Puzzles;\n}\n\nexport function getpuzzle(puzzleName: PuzzleName): PuzzleDescriptionString {\n  // get some simple definitions of basic puzzles\n  return Puzzles[puzzleName];\n}\n\nexport function parsedesc(s: string): any { // parse a text description\n  const a = s.split(/ /).filter(Boolean);\n  if (a.length % 2 === 0) {\n    return false;\n  }\n  if (a[0] !== \"o\" && a[0] !== \"c\" && a[0] !== \"i\" && a[0] !== \"d\" && a[0] !== \"t\") {\n    return false;\n  }\n  const r = [];\n  for (let i = 1; i < a.length; i += 2) {\n    if (a[i] !== \"f\" && a[i] !== \"v\" && a[i] !== \"e\") {\n      return false;\n    }\n    r.push([a[i], a[i + 1]]);\n  }\n  return [a[0], r];\n}\n\n// TODO: Automatically associate this with the source list.\ntype PuzzleName = \"2x2x2\" | \"3x3x3\" | \"4x4x4\" | \"5x5x5\" | \"6x6x6\" | \"7x7x7\" | \"8x8x8\" | \"9x9x9\" | \"10x10x10\" | \"11x11x11\" | \"12x12x12\" | \"13x13x13\" | \"20x20x20\" | \"skewb\" | \"master skewb\" | \"professor skewb\" | \"compy cube\" | \"helicopter\" | \"dino\" | \"little chop\" | \"pyramorphix\" | \"mastermorphix\" | \"pyraminx\" | \"Jing pyraminx\" | \"master paramorphix\" | \"megaminx\" | \"gigaminx\" | \"pentultimate\" | \"starminx\" | \"starminx 2\" | \"pyraminx crystal\" | \"chopasaurus\" | \"big chop\" | \"skewb diamond\" | \"FTO\" | \"Christopher's jewel\" | \"octastar\" | \"Trajber's octahedron\" | \"radio chop\" | \"icosamate\" | \"icosahedron 2\" | \"icosahedron 3\" | \"icosahedron static faces\" | \"icosahedron moving faces\" | \"Eita\";\n\nexport function getPuzzleGeometryByDesc(desc: string, options: string[] = []): PuzzleGeometry {\n  const [shape, cuts] = parsedesc(desc);\n  const pg = new PuzzleGeometry(shape, cuts, [\"allmoves\", \"true\"].concat(options));\n  pg.allstickers();\n  pg.genperms();\n  return pg;\n}\n\nexport function getPuzzleGeometryByName(puzzleName: PuzzleName, options: string[] = []): PuzzleGeometry {\n  return getPuzzleGeometryByDesc(Puzzles[puzzleName], options);\n}\n\nfunction getmovename(geo: any, bits: number, slices: number): any {\n  // generate a move name based on bits, slice, and geo\n  // if the move name is from the opposite face, say so.\n  // find the face that's turned.\n  let nbits = 0;\n  let inverted = false;\n  for (let i = 0; i <= slices; i++) {\n    if ((bits >> i) & 1) {\n      nbits |= 1 << (slices - i);\n    }\n  }\n  if (nbits < bits) { // flip if most of the move is on the other side\n    geo = [geo[2], geo[3], geo[0], geo[1]];\n    bits = nbits;\n    inverted = true;\n  }\n  let movenameFamily = geo[0];\n  let movenamePrefix = \"\";\n  let hibit = 0;\n  while (bits >> (1 + hibit)) {\n    hibit++;\n  }\n  if (bits === (2 << slices) - 1) {\n    movenameFamily = movenameFamily + \"v\";\n  } else if (bits === (1 << hibit)) {\n    if (hibit > 0) {\n      movenamePrefix = String(hibit + 1);\n    }\n  } else if (bits === ((2 << hibit) - 1)) {\n    movenameFamily = movenameFamily.toLowerCase();\n    if (hibit > 1) {\n      movenamePrefix = String(hibit + 1);\n    }\n  } else {\n    movenamePrefix = \"_\" + bits + \"_\";\n    //       throw \"We only support slice and outer block moves right now. \" + bits ;\n  }\n  return [movenamePrefix + movenameFamily, inverted];\n}\n\n// split a geometrical element into face names.  The facenames must\n// be prefix-free.\nfunction splitByFaceNames(s: string, facenames: any[]): string[] {\n  const r: string[] = [];\n  let at = 0;\n  while (at < s.length) {\n    let found = false;\n    for (let i = 0; i < facenames.length; i++) {\n      if (s.substr(at).startsWith(facenames[i][1])) {\n        r.push(facenames[i][1]);\n        at += facenames[i][1].length;\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      throw new Error((\"Could not split \" + s + \" into face names.\"));\n    }\n  }\n  return r;\n}\n\nfunction toCoords(q: Quat, maxdist: number): number[] {\n  return [- q.b / maxdist, - q.c / maxdist, - q.d / maxdist];\n}\n\nfunction toFaceCoords(q: Quat[], maxdist: number): number[][] {\n  const r = [];\n  const n = q.length;\n  for (let i = 0; i < n; i++) {\n    r[n - i - 1] = toCoords(q[i], maxdist);\n  }\n  return r;\n}\n\nfunction trimEdges(face: Quat[], tr: number): Quat[] {\n  const r: Quat[] = [];\n  for (let iter = 1; iter < 10; iter++) {\n    for (let i = 0; i < face.length; i++) {\n      const pi = (i + face.length - 1) % face.length;\n      const ni = (i + 1) % face.length;\n      const A = face[pi].sub(face[i]).normalize();\n      const B = face[ni].sub(face[i]).normalize();\n      const d = A.dot(B);\n      const m = tr / Math.sqrt(1 - d * d);\n      r[i] = face[i].sum(A.sum(B).smul(m));\n    }\n    let good = true;\n    for (let i = 0; good && i < r.length; i++) {\n      const pi = (i + face.length - 1) % face.length;\n      const ni = (i + 1) % face.length;\n      if (r[pi].sub(r[i]).cross(r[ni].sub(r[i])).dot(r[i]) >= 0) {\n        good = false;\n      }\n    }\n    if (good) {\n      return r;\n    }\n    tr /= 2;\n  }\n  return face;\n}\n\nexport class PuzzleGeometry {\n  public args: string = \"\";\n  public rotations: Quat[];    // all members of the rotation group\n  public baseplanerot: Quat[]; // unique rotations of the baseplane\n  public baseplanes: Quat[];   // planes, corresponding to faces\n  public facenames: any[];     // face names\n  public faceplanes: any;           // face planes\n  public edgenames: any[];     // edge names\n  public vertexnames: any[];   // vertexnames\n  public geonormals: any[];    // all geometric directions, with names and types\n  public moveplanes: Quat[];   // the planes that split moves\n  public moveplanesets: any[]; // the move planes, in parallel sets\n  public movesetorders: any[]; // the order of rotations for each move set\n  public movesetgeos: any[];   // geometric feature information for move sets\n  public basefaces: Quat[][];  // polytope faces before cuts\n  public faces: Quat[][];      // all the stickers\n  public basefacecount: number;      // number of base faces\n  public stickersperface: number;    // number of stickers per face\n  public cornerfaces: number;        // number of faces that meet at a corner\n  public cubies: any[];        // the cubies\n  public shortedge: number;         // shortest edge\n  public vertexdistance: number;    // vertex distance\n  public edgedistance: number;      // edge distance\n  public orbits: number;            // count of cubie orbits\n  public facetocubies: any[];  // map a face to a cubie index and offset\n  public moverotations: Quat[][]; // move rotations\n  public cubiekey: any;             // cubie locator\n  public cubiekeys: string[];  // cubie keys\n  public facelisthash: any;         // face list by key\n  public cubiesetnames: any[]; // cubie set names\n  public cubieords: number[];  // the size of each orbit\n  public cubiesetnums: number[];\n  public cubieordnums: number[];\n  public orbitoris: number[];  // the orientation size of each orbit\n  public cubievaluemap: number[]; // the map for identical cubies\n  public cubiesetcubies: number[][]; // cubies in each cubie set\n  public movesbyslice: any[];  // move as perms by slice\n  public cmovesbyslice: any[] = []; // cmoves as perms by slice\n  // options\n  public verbose: number = 0;         // verbosity (console.log)\n  public allmoves: boolean = false; // generate all slice moves in ksolve\n  public outerblockmoves: boolean;  // generate outer block moves\n  public vertexmoves: boolean;      // generate vertex moves\n  public addrotations: boolean;     // add symmetry information to ksolve output\n  public movelist: any;             // move list to generate\n  public parsedmovelist: any;       // parsed move list\n  public cornersets: boolean = true; // include corner sets\n  public centersets: boolean = true; // include center sets\n  public edgesets: boolean = true;   // include edge sets\n  public graycorners: boolean = false; // make corner sets gray\n  public graycenters: boolean = false; // make center sets gray\n  public grayedges: boolean = false;   // make edge sets gray\n  public killorientation: boolean = false; // eliminate any orientations\n  public optimize: boolean = false;  // optimize PermOri\n  public scramble: number = 0;       // scramble?\n  public ksolvemovenames: string[]; // move names from ksolve\n  public fixPiece: string = \"\";      // fix a piece?\n  public orientCenters: boolean = false; // orient centers?\n  public duplicatedFaces: number[] = []; // which faces are duplicated\n  public duplicatedCubies: number[] = []; // which cubies are duplicated\n  public fixedCubie: number = -1;    // fixed cubie, if any\n  public svggrips: any[];       // grips from svg generation by svg coordinate\n  public net: any = [];\n  public colors: any = [];\n  public faceorder: any = [];\n  public faceprecedence: number[] = [];\n  constructor(shape: string, cuts: string[][], optionlist: any[] | undefined) {\n    if (optionlist !== undefined) {\n      if (optionlist.length % 2 !== 0) {\n        throw new Error(\"Odd length in option list?\");\n      }\n      for (let i = 0; i < optionlist.length; i += 2) {\n        if (optionlist[i] === \"verbose\") {\n          this.verbose++;\n        } else if (optionlist[i] === \"quiet\") {\n          this.verbose = 0;\n        } else if (optionlist[i] === \"allmoves\") {\n          this.allmoves = optionlist[i + 1];\n        } else if (optionlist[i] === \"outerblockmoves\") {\n          this.outerblockmoves = optionlist[i + 1];\n        } else if (optionlist[i] === \"vertexmoves\") {\n          this.vertexmoves = optionlist[i + 1];\n        } else if (optionlist[i] === \"rotations\") {\n          this.addrotations = optionlist[i + 1];\n        } else if (optionlist[i] === \"cornersets\") {\n          this.cornersets = optionlist[i + 1];\n        } else if (optionlist[i] === \"centersets\") {\n          this.centersets = optionlist[i + 1];\n        } else if (optionlist[i] === \"edgesets\") {\n          this.edgesets = optionlist[i + 1];\n        } else if (optionlist[i] === \"graycorners\") {\n          this.graycorners = optionlist[i + 1];\n        } else if (optionlist[i] === \"graycenters\") {\n          this.graycenters = optionlist[i + 1];\n        } else if (optionlist[i] === \"grayedges\") {\n          this.grayedges = optionlist[i + 1];\n        } else if (optionlist[i] === \"movelist\") {\n          this.movelist = optionlist[i + 1];\n        } else if (optionlist[i] === \"killorientation\") {\n          this.killorientation = optionlist[i + 1];\n        } else if (optionlist[i] === \"optimize\") {\n          this.optimize = optionlist[i + 1];\n        } else if (optionlist[i] === \"scramble\") {\n          this.scramble = optionlist[i + 1];\n        } else if (optionlist[i] === \"fix\") {\n          this.fixPiece = optionlist[i + 1];\n        } else if (optionlist[i] === \"orientcenters\") {\n          this.orientCenters = optionlist[i + 1];\n        } else {\n          throw new Error(\"Bad option while processing option list \" + optionlist[i]);\n        }\n      }\n    }\n    this.args = shape + \" \" + (cuts.map((_) => _.join(\" \")).join(\" \"));\n    if (optionlist) {\n      this.args += \" \" + optionlist.join(\" \");\n    }\n    if (this.verbose > 0) {\n      console.log(this.header(\"# \"));\n    }\n    this.create(shape, cuts);\n  }\n\n  public create(shape: string, cuts: any[]): void {\n    // create the shape, doing all the essential geometry\n    // create only goes far enough to figure out how many stickers per\n    // face, and what the short edge is.  If the short edge is too short,\n    // we probably don't want to display or manipulate this one.  How\n    // short is too short is hard to say.\n    // var that = this ; // TODO\n    this.moveplanes = [];\n    this.faces = [];\n    this.cubies = [];\n    let g = null;\n    switch (shape) {\n      case \"c\": g = cube(); break;\n      case \"o\": g = octahedron(); break;\n      case \"i\": g = icosahedron(); break;\n      case \"t\": g = tetrahedron(); break;\n      case \"d\": g = dodecahedron(); break;\n      default: throw new Error(\"Bad shape argument: \" + shape);\n    }\n    this.rotations = closure(g);\n    if (this.verbose) { console.log(\"# Rotations: \" + this.rotations.length); }\n    const baseplane = g[0];\n    this.baseplanerot = uniqueplanes(baseplane, this.rotations);\n    const baseplanes = this.baseplanerot.map((_) => baseplane.rotateplane(_));\n    this.baseplanes = baseplanes;\n    this.basefacecount = baseplanes.length;\n    const net = defaultnets[baseplanes.length];\n    this.net = net;\n    this.colors = defaultcolors[baseplanes.length];\n    this.faceorder = defaultfaceorders[baseplanes.length];\n    if (this.verbose) { console.log(\"# Base planes: \" + baseplanes.length); }\n    const baseface = getface(baseplanes);\n    if (this.verbose) { console.log(\"# Face vertices: \" + baseface.length); }\n    const facenormal = baseplanes[0].makenormal();\n    const edgenormal = baseface[0].sum(baseface[1]).makenormal();\n    const vertexnormal = baseface[0].makenormal();\n    const cutplanes = [];\n    for (let i = 0; i < cuts.length; i++) {\n      let normal = null;\n      switch (cuts[i][0]) {\n        case \"f\": normal = facenormal; break;\n        case \"v\": normal = vertexnormal; break;\n        case \"e\": normal = edgenormal; break;\n        default: throw new Error(\"Bad cut argument: \" + cuts[i][0]);\n      }\n      cutplanes.push(normal.makecut(cuts[i][1]));\n    }\n    const boundary = new Quat(1, facenormal.b, facenormal.c, facenormal.d);\n    if (this.verbose) { console.log(\"# Boundary is \" + boundary); }\n    const planerot = uniqueplanes(boundary, this.rotations);\n    const planes = planerot.map((_) => boundary.rotateplane(_));\n    let faces = [getface(planes)];\n    this.basefaces = [];\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(faces[0]);\n      this.basefaces.push(face);\n    }\n    //\n    //   Determine names for edges, vertices, and planes.  Planes are defined\n    //   by the plane normal/distance; edges are defined by the midpoint;\n    //   vertices are defined by actual point.  In each case we define a name.\n    //   Note that edges have two potential names, and corners have n where\n    //   n planes meet at a vertex.  We arbitrarily choose the one that is\n    //   alphabetically first (and we will probably want to change this).\n    //\n    const facenames: any[] = [];\n    const faceplanes = [];\n    const vertexnames: any[] = [];\n    const edgenames: any[] = [];\n    const edgesperface = faces[0].length;\n    function searchaddelement(a: any[], p: Quat, name: any) {\n      for (let i = 0; i < a.length; i++) {\n        if (a[i][0].dist(p) < eps) {\n          a[i].push(name);\n          return;\n        }\n      }\n      a.push([p, name]);\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(faces[0]);\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        searchaddelement(edgenames, midpoint, i);\n      }\n    }\n    const otherfaces = [];\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(faces[0]);\n      const facelist = [];\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        const el = edgenames[findelement(edgenames, midpoint)];\n        if (i === el[1]) {\n          facelist.push(el[2]);\n        } else if (i === el[2]) {\n          facelist.push(el[1]);\n        } else {\n          throw new Error(\"Could not find edge\");\n        }\n      }\n      otherfaces.push(facelist);\n    }\n    const facenametoindex: any = {};\n    const faceindextoname: any = [];\n    faceindextoname.push(net[0][0]);\n    facenametoindex[net[0][0]] = 0;\n    faceindextoname[otherfaces[0][0]] = net[0][1];\n    facenametoindex[net[0][1]] = otherfaces[0][0];\n    for (let i = 0; i < net.length; i++) {\n      const f0 = net[i][0];\n      const fi = facenametoindex[f0];\n      if (fi === undefined) {\n        throw new Error(\"Bad edge description; first edge not connected\");\n      }\n      let ii = -1;\n      for (let j = 0; j < otherfaces[fi].length; j++) {\n        const fn2 = faceindextoname[otherfaces[fi][j]];\n        if (fn2 !== undefined && fn2 === net[i][1]) {\n          ii = j;\n          break;\n        }\n      }\n      if (ii < 0) {\n        throw new Error(\"First element of a net not known\");\n      }\n      for (let j = 2; j < net[i].length; j++) {\n        if (net[i][j] === \"\") {\n          continue;\n        }\n        const of = otherfaces[fi][(j + ii - 1) % edgesperface];\n        const fn2 = faceindextoname[of];\n        if (fn2 !== undefined && fn2 !== net[i][j]) {\n          throw new Error(\"Face mismatch in net\");\n        }\n        faceindextoname[of] = net[i][j];\n        facenametoindex[net[i][j]] = of;\n      }\n    }\n    for (let i = 0; i < faceindextoname.length; i++) {\n      let found = false;\n      for (let j = 0; j < this.faceorder.length; j++) {\n        if (faceindextoname[i] === this.faceorder[j]) {\n          this.faceprecedence[i] = j;\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        throw new Error(\"Could not find face \" + faceindextoname[i] +\n          \" in face order list \" + this.faceorder);\n      }\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(faces[0]);\n      const faceplane = boundary.rotateplane(this.baseplanerot[i]);\n      const facename = faceindextoname[i];\n      facenames.push([face, facename]);\n      faceplanes.push([faceplane, facename]);\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(faces[0]);\n      const facename = faceindextoname[i];\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        const jjj = (j + 2) % face.length;\n        const midpoint2 = face[jj].sum(face[jjj]).smul(0.5);\n        const e1 = findelement(edgenames, midpoint);\n        const e2 = findelement(edgenames, midpoint2);\n        searchaddelement(vertexnames, face[jj], [facename, e2, e1]);\n      }\n    }\n    // fix the edge names; use face precedence order\n    for (let i = 0; i < edgenames.length; i++) {\n      if (edgenames[i].length !== 3) {\n        throw new Error(\"Bad length in edge names \" + edgenames[i]);\n      }\n      let c1 = faceindextoname[edgenames[i][1]];\n      const c2 = faceindextoname[edgenames[i][2]];\n      if (this.faceprecedence[edgenames[i][1]] <\n        this.faceprecedence[edgenames[i][2]]) {\n        c1 = c1 + c2;\n      } else {\n        c1 = c2 + c1;\n      }\n      edgenames[i] = [edgenames[i][0], c1];\n    }\n    // fix the vertex names; clockwise rotations; low face first.\n    this.cornerfaces = vertexnames[0].length - 1;\n    for (let i = 0; i < vertexnames.length; i++) {\n      if (vertexnames[i].length < 4) {\n        throw new Error(\"Bad length in vertex names\");\n      }\n      let st = 1;\n      for (let j = 2; j < vertexnames[i].length; j++) {\n        if (this.faceprecedence[facenametoindex[vertexnames[i][j][0]]] <\n          this.faceprecedence[facenametoindex[vertexnames[i][st][0]]]) {\n          st = j;\n        }\n      }\n      let r = \"\";\n      for (let j = 1; j < vertexnames[i].length; j++) {\n        r = r + vertexnames[i][st][0];\n        for (let k = 1; k < vertexnames[i].length; k++) {\n          if (vertexnames[i][st][2] === vertexnames[i][k][1]) {\n            st = k;\n            break;\n          }\n        }\n      }\n      vertexnames[i] = [vertexnames[i][0], r];\n    }\n    if (this.verbose > 1) {\n      console.log(\"Face precedence list: \" + this.faceorder.join(\" \"));\n      console.log(\"Face names: \" + facenames.map((_: any) => _[1]).join(\" \"));\n      console.log(\"Edge names: \" + edgenames.map((_: any) => _[1]).join(\" \"));\n      console.log(\"Vertex names: \" + vertexnames.map((_: any) => _[1]).join(\" \"));\n    }\n    const geonormals = [];\n    for (let i = 0; i < faceplanes.length; i++) {\n      geonormals.push(\n        [faceplanes[i][0].makenormal(), faceplanes[i][1], \"f\"]);\n    }\n    for (let i = 0; i < edgenames.length; i++) {\n      geonormals.push([edgenames[i][0].makenormal(), edgenames[i][1], \"e\"]);\n    }\n    for (let i = 0; i < vertexnames.length; i++) {\n      geonormals.push(\n        [vertexnames[i][0].makenormal(), vertexnames[i][1], \"v\"]);\n    }\n    this.facenames = facenames;\n    this.faceplanes = faceplanes;\n    this.edgenames = edgenames;\n    this.vertexnames = vertexnames;\n    this.geonormals = geonormals;\n    const zero = new Quat(0, 0, 0, 0);\n    this.edgedistance = faces[0][0].sum(faces[0][1]).smul(0.5).dist(zero);\n    this.vertexdistance = faces[0][0].dist(zero);\n    if (this.verbose) {\n      console.log(\"# Distances: face \" + 1 + \" edge \" + this.edgedistance +\n        \" vertex \" + this.vertexdistance);\n    }\n    // expand cutplanes by rotations.  We only work with one face here.\n    for (let c = 0; c < cutplanes.length; c++) {\n      for (let i = 0; i < this.rotations.length; i++) {\n        const q = cutplanes[c].rotateplane(this.rotations[i]);\n        let wasseen = false;\n        for (let j = 0; j < this.moveplanes.length; j++) {\n          if (q.sameplane(this.moveplanes[j])) {\n            wasseen = true;\n            break;\n          }\n        }\n        if (!wasseen) {\n          this.moveplanes.push(q);\n          faces = q.cutfaces(faces);\n        }\n      }\n    }\n    this.faces = faces;\n    if (this.verbose) { console.log(\"# Faces is now \" + faces.length); }\n    this.stickersperface = faces.length;\n    //  Find and report the shortest edge in any of the faces.  If this\n    //  is small the puzzle is probably not practical or displayable.\n    let shortedge = 1e99;\n    for (let i = 0; i < faces.length; i++) {\n      for (let j = 0; j < faces[i].length; j++) {\n        const k = (j + 1) % faces[i].length;\n        const t = faces[i][j].dist(faces[i][k]);\n        if (t < shortedge) {\n          shortedge = t;\n        }\n      }\n    }\n    this.shortedge = shortedge;\n    if (this.verbose) { console.log(\"# Short edge is \" + shortedge); }\n  }\n\n  public keyface(face: Quat[]): string {\n    // take a face and figure out the sides of each move plane\n    let s = \"\";\n    for (let i = 0; i < this.moveplanesets.length; i++) {\n      let t = 0;\n      for (let j = 0; j < this.moveplanesets[i].length; j++) {\n        if (this.moveplanesets[i][j].faceside(face) > 0) {\n          t++;\n        }\n      }\n      s = s + \" \" + t;\n    }\n    return s;\n  }\n\n  public findcubie(face: Quat[]): number {\n    return this.facetocubies[this.findface(face)][0];\n  }\n\n  public findface(face: Quat[]): number {\n    const cm = centermassface(face);\n    const key = this.keyface(face);\n    for (let i = 0; i < this.facelisthash[key].length; i++) {\n      const face2 = this.facelisthash[key][i];\n      if (Math.abs(cm.dist(\n        centermassface(this.faces[face2]))) < eps) {\n        return face2;\n      }\n    }\n    throw new Error(\"Could not find face.\");\n  }\n\n  public project2d(facen: number, edgen: number, targvec: Quat[]): any {\n    // calculate geometry to map a particular edge of a particular\n    //  face to a given 2D vector.  The face is given as an index into the\n    //  facenames/baseplane arrays, and the edge is given as an offset into\n    //  the vertices.\n    const face = this.facenames[facen][0];\n    const edgen2 = (edgen + 1) % face.length;\n    const plane = this.baseplanes[facen];\n    let x0 = face[edgen2].sub(face[edgen]);\n    const olen = x0.len();\n    x0 = x0.normalize();\n    const y0 = x0.cross(plane).normalize();\n    let delta = targvec[1].sub(targvec[0]);\n    const len = delta.len() / olen;\n    delta = delta.normalize();\n    const cosr = delta.b;\n    const sinr = delta.c;\n    const x1 = x0.smul(cosr).sub(y0.smul(sinr)).smul(len);\n    const y1 = y0.smul(cosr).sum(x0.smul(sinr)).smul(len);\n    const off = new Quat(0, targvec[0].b - x1.dot(face[edgen]),\n      targvec[0].c - y1.dot(face[edgen]), 0);\n    return [x1, y1, off];\n  }\n\n  public allstickers(): void {\n    // next step is to calculate all the stickers and orbits\n    // We do enough work here to display the cube on the screen.\n    // take our newly split base face and expand it by the rotation matrix.\n    // this generates our full set of \"stickers\".\n    this.faces = expandfaces(this.baseplanerot, this.faces);\n    if (this.verbose) { console.log(\"# Total stickers is now \" + this.faces.length); }\n    // Split moveplanes into a list of parallel planes.\n    const moveplanesets = [];\n    for (let i = 0; i < this.moveplanes.length; i++) {\n      let wasseen = false;\n      const q = this.moveplanes[i];\n      const qnormal = q.makenormal();\n      for (let j = 0; j < moveplanesets.length; j++) {\n        if (qnormal.sameplane(moveplanesets[j][0].makenormal())) {\n          moveplanesets[j].push(q);\n          wasseen = true;\n          break;\n        }\n      }\n      if (!wasseen) {\n        moveplanesets.push([q]);\n      }\n    }\n    // make the normals all face the same way in each set.\n    for (let i = 0; i < moveplanesets.length; i++) {\n      const q: Quat[] = moveplanesets[i].map((_) => _.normalizeplane());\n      const goodnormal = q[0].makenormal();\n      for (let j = 0; j < q.length; j++) {\n        if (q[j].makenormal().dist(goodnormal) > eps) {\n          q[j] = q[j].smul(-1);\n        }\n      }\n      q.sort((a, b) => a.a - b.a);\n      moveplanesets[i] = q;\n    }\n    this.moveplanesets = moveplanesets;\n    const sizes = moveplanesets.map((_) => _.length);\n    if (this.verbose) { console.log(\"# Move plane sets: \" + sizes); }\n    // for each of the move planes, find the rotations that are relevant\n    const moverotations: Quat[][] = [];\n    for (let i = 0; i < moveplanesets.length; i++) {\n      moverotations.push([]);\n    }\n    for (let i = 0; i < this.rotations.length; i++) {\n      const q: Quat = this.rotations[i];\n      if (Math.abs(Math.abs(q.a) - 1) < eps) {\n        continue;\n      }\n      const qnormal = q.makenormal();\n      for (let j = 0; j < moveplanesets.length; j++) {\n        if (qnormal.sameplane(moveplanesets[j][0].makenormal())) {\n          moverotations[j].push(q);\n          break;\n        }\n      }\n    }\n    this.moverotations = moverotations;\n    //  Sort the rotations by the angle of rotation.  A bit tricky because\n    //  while the norms should be the same, they need not be.  So we start\n    //  by making the norms the same, and then sorting.\n    for (let i = 0; i < moverotations.length; i++) {\n      const r = moverotations[i];\n      const goodnormal = r[0].makenormal();\n      for (let j = 0; j < r.length; j++) {\n        if (goodnormal.dist(r[j].makenormal()) > eps) {\n          r[j] = r[j].smul(-1);\n        }\n      }\n      r.sort((a, b) => a.angle() - b.angle());\n      if (moverotations[i][0].dot(moveplanesets[i][0]) < 0) {\n        r.reverse();\n      }\n    }\n    const sizes2 = moverotations.map((_) => 1 + _.length);\n    this.movesetorders = sizes2;\n    const movesetgeos = [];\n    for (let i = 0; i < moveplanesets.length; i++) {\n      const p0 = moveplanesets[i][0].makenormal();\n      let neg = null;\n      let pos = null;\n      for (let j = 0; j < this.geonormals.length; j++) {\n        const d = p0.dot(this.geonormals[j][0]);\n        if (Math.abs(d - 1) < eps) {\n          pos = [this.geonormals[j][1], this.geonormals[j][2]];\n        } else if (Math.abs(d + 1) < eps) {\n          neg = [this.geonormals[j][1], this.geonormals[j][2]];\n        }\n      }\n      if (pos === null || neg === null) {\n        throw new Error(\"Saw positive or negative sides as null\");\n      }\n      movesetgeos.push([pos[0], pos[1], neg[0], neg[1],\n      1 + moveplanesets[i].length]);\n    }\n    this.movesetgeos = movesetgeos;\n    //  Cubies are split by move plane sets.  For each cubie we can\n    //  average its points to find a point on the interior of that\n    //  cubie.  We can then check that point against all the move\n    //  planes and from that derive a coordinate for the cubie.\n    //  This also works for faces; no face should ever lie on a move\n    //  plane.  This allows us to take a set of stickers and break\n    //  them up into cubie sets.\n    const cubiehash: any = {};\n    const facelisthash: any = {};\n    const cubiekey: any = {};\n    const cubiekeys = [];\n    const cubies: Quat[][][] = [];\n    const faces = this.faces;\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      const s = this.keyface(face);\n      if (!cubiehash[s]) {\n        cubiekey[s] = cubies.length;\n        cubiekeys.push(s);\n        cubiehash[s] = [];\n        facelisthash[s] = [];\n        cubies.push(cubiehash[s]);\n      }\n      facelisthash[s].push(i);\n      cubiehash[s].push(face);\n      //  If we find a core cubie, split it up into multiple cubies,\n      //  because ksolve doesn't handle orientations that are not\n      //  cyclic, and the rotation group of the core is not cyclic.\n      if (facelisthash[s].length === this.basefacecount) {\n        if (this.verbose) { console.log(\"# Splitting core.\"); }\n        for (let suff = 0; suff < this.basefacecount; suff++) {\n          const s2 = s + \" \" + suff;\n          facelisthash[s2] = [facelisthash[s][suff]];\n          cubiehash[s2] = [cubiehash[s][suff]];\n          cubiekeys.push(s2);\n          cubiekey[s2] = cubies.length;\n          cubies.push(cubiehash[s2]);\n        }\n        cubiehash[s] = [];\n        cubies[cubiekey[s]] = [];\n      }\n    }\n    this.cubiekey = cubiekey;\n    this.facelisthash = facelisthash;\n    this.cubiekeys = cubiekeys;\n    if (this.verbose) { console.log(\"# Cubies: \" + Object.keys(cubiehash).length); }\n    const that = this;\n    function getfaceindex(facenum: number): number {\n      const divid = that.stickersperface;\n      return Math.floor(facenum / divid);\n    }\n    //  Sort the faces around each corner so they are clockwise.  Only\n    //  relevant for cubies that actually are corners (three or more\n    //  faces).  In general cubies might have many faces; for icosohedrons\n    //  there are five faces on the corner cubies.\n    this.cubies = cubies;\n    for (let k = 0; k < cubies.length; k++) {\n      const cubie = cubies[k];\n      if (cubie.length < 2) {\n        continue;\n      }\n      if (cubie.length === this.basefacecount) { // looks like core?  don't sort\n        continue;\n      }\n      if (cubie.length > 5) {\n        throw new Error(\"Bad math; too many faces on this cubie \" + cubie.length);\n      }\n      const s = this.keyface(cubie[0]);\n      const facelist = facelisthash[s];\n      const cm = cubie.map((_) => centermassface(_));\n      const cmall = centermassface(cm);\n      for (let looplimit = 0; cubie.length > 2; looplimit++) {\n        let changed = false;\n        for (let i = 0; i < cubie.length; i++) {\n          const j = (i + 1) % cubie.length;\n          // var ttt = cmall.dot(cm[i].cross(cm[j])) ; // TODO\n          if (cmall.dot(cm[i].cross(cm[j])) < 0) {\n            const t = cubie[i];\n            cubie[i] = cubie[j];\n            cubie[j] = t;\n            const u = cm[i];\n            cm[i] = cm[j];\n            cm[j] = u;\n            const v = facelist[i];\n            facelist[i] = facelist[j];\n            facelist[j] = v;\n            changed = true;\n          }\n        }\n        if (!changed) {\n          break;\n        }\n        if (looplimit > 1000) {\n          throw new Error((\"Bad epsilon math; too close to border\"));\n        }\n      }\n      let mini = 0;\n      let minf = this.findface(cubie[mini]);\n      for (let i = 1; i < cubie.length; i++) {\n        const temp = this.findface(cubie[i]);\n        if (this.faceprecedence[getfaceindex(temp)] <\n          this.faceprecedence[getfaceindex(minf)]) {\n          mini = i;\n          minf = temp;\n        }\n      }\n      if (mini !== 0) {\n        const ocubie = cubie.slice();\n        const ofacelist = facelist.slice();\n        for (let i = 0; i < cubie.length; i++) {\n          cubie[i] = ocubie[(mini + i) % cubie.length];\n          facelist[i] = ofacelist[(mini + i) % cubie.length];\n        }\n      }\n    }\n    //  Build an array that takes each face to a cubie ordinal and a\n    //  face number.\n    const facetocubies = [];\n    for (let i = 0; i < cubies.length; i++) {\n      const facelist = facelisthash[cubiekeys[i]];\n      for (let j = 0; j < facelist.length; j++) {\n        facetocubies[facelist[j]] = [i, j];\n      }\n    }\n    this.facetocubies = facetocubies;\n    //  Calculate the orbits of each cubie.  Assumes we do all moves.\n    //  Also calculates which cubies are identical.\n    const typenames = [\"?\", \"CENTER\", \"EDGE\", \"CORNER\", \"C4RNER\", \"C5RNER\"];\n    const cubiesetnames = [];\n    const cubietypecounts = [0, 0, 0, 0, 0, 0];\n    const orbitoris = [];\n    const seen = [];\n    let cubiesetnum = 0;\n    const cubiesetnums = [];\n    const cubieordnums = [];\n    const cubieords = [];\n    // var cubiesetnumhash = {} ; // TODO\n    const cubievaluemap = [];\n    // Later we will make this smarter to use a get color for face function\n    // so we support puzzles with multiple faces the same color\n    function getcolorkey(cubienum: number): string {\n      return cubies[cubienum].map(\n        (_) => getfaceindex(that.findface(_))).join(\" \");\n    }\n    const cubiesetcubies: any = [];\n    for (let i = 0; i < cubies.length; i++) {\n      if (seen[i]) {\n        continue;\n      }\n      const cubie = cubies[i];\n      if (cubie.length === 0) {\n        continue;\n      }\n      const cubiekeymap: any = {};\n      let cubievalueid = 0;\n      cubieords.push(0);\n      cubiesetcubies.push([]);\n      const facecnt = cubie.length;\n      const typectr = cubietypecounts[facecnt]++;\n      let typename = typenames[facecnt];\n      if (typename === undefined || facecnt === this.basefacecount) {\n        typename = \"CORE\";\n      }\n      typename = typename + (typectr === 0 ? \"\" : (typectr + 1));\n      cubiesetnames[cubiesetnum] = typename;\n      orbitoris[cubiesetnum] = facecnt;\n      const queue = [i];\n      let qg = 0;\n      seen[i] = true;\n      while (qg < queue.length) {\n        const cind = queue[qg++];\n        const cubiecolorkey = getcolorkey(cind);\n        if (cubie.length > 1 || cubiekeymap[cubiecolorkey] === undefined) {\n          cubiekeymap[cubiecolorkey] = cubievalueid++;\n        }\n        cubievaluemap[cind] = cubiekeymap[cubiecolorkey];\n        cubiesetnums[cind] = cubiesetnum;\n        cubiesetcubies[cubiesetnum].push(cind);\n        cubieordnums[cind] = cubieords[cubiesetnum]++;\n        for (let j = 0; j < moverotations.length; j++) {\n          const tq = this.findcubie(moverotations[j][0].rotateface(cubies[cind][0]));\n          if (!seen[tq]) {\n            queue.push(tq);\n            seen[tq] = true;\n          }\n        }\n      }\n      cubiesetnum++;\n    }\n    this.orbits = cubieords.length;\n    this.cubiesetnums = cubiesetnums;\n    this.cubieordnums = cubieordnums;\n    this.cubiesetnames = cubiesetnames;\n    this.cubieords = cubieords;\n    this.orbitoris = orbitoris;\n    this.cubievaluemap = cubievaluemap;\n    this.cubiesetcubies = cubiesetcubies;\n    // if we fix a cubie, find a cubie to fix\n    if (this.fixPiece !== \"\") {\n      for (let i = 0; i < cubies.length; i++) {\n        if ((this.fixPiece === \"v\" && cubies[i].length > 2) ||\n          (this.fixPiece === \"e\" && cubies[i].length === 2) ||\n          (this.fixPiece === \"f\" && cubies[i].length === 1)) {\n          this.fixedCubie = i;\n          break;\n        }\n      }\n      if (this.fixedCubie < 0) {\n        throw new Error(\"Could not find a cubie of type \" + this.fixPiece + \" to fix.\");\n      }\n    }\n    // show the orbits\n    if (this.verbose) { console.log(\"# Cubie orbit sizes \" + cubieords); }\n  }\n\n  public spinmatch(a: string, b: string): boolean {\n    // are these the same rotationally?\n    if (a === b) {\n      return true;\n    }\n    if (a.length !== b.length) {\n      return false;\n    }\n    try {\n      const e1 = splitByFaceNames(a, this.facenames);\n      const e2 = splitByFaceNames(b, this.facenames);\n      if (e1.length !== e2.length) {\n        return false;\n      }\n      for (let i = 0; i < e1.length; i++) {\n        if (e1[i] === e2[0]) {\n          for (let j = 0; j < e2.length; j++) {\n            if (e1[(i + j) % e1.length] !== e2[j]) {\n              return false;\n            }\n          }\n          return true;\n        }\n      }\n      return false;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  public parsemove(mv: string): any { // parse a move from the command line\n    const re = RegExp(\"^(([0-9]+)-)?([0-9]+)?([A-Za-z]+)([-'0-9]+)?$\");\n    const p = mv.match(re);\n    if (p === null) {\n      throw new Error(\"Bad move passed \" + mv);\n    }\n    let grip = p[4];\n    let fullrotation = false;\n    if (grip.endsWith(\"v\") && grip[0] <= \"Z\") {\n      if (p[2] !== undefined || p[3] !== undefined) {\n        throw new Error(\"Cannot use a prefix with full cube rotations\");\n      }\n      grip = grip.slice(0, -1);\n      fullrotation = true;\n    }\n    let geo;\n    let msi = -1;\n    const upperCaseGrip = grip.toUpperCase();\n    let firstgrip = false;\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const g = this.movesetgeos[i];\n      if (this.spinmatch(g[0], upperCaseGrip)) {\n        firstgrip = true;\n        geo = g;\n        msi = i;\n      }\n      if (this.spinmatch(g[2], upperCaseGrip)) {\n        firstgrip = false;\n        geo = g;\n        msi = i;\n      }\n    }\n    let loslice = 1;\n    let hislice = 1;\n    if (upperCaseGrip !== grip) {\n      hislice = 2;\n    }\n    if (geo === undefined) {\n      throw new Error(\"Bad grip in move \" + mv);\n    }\n    if (p[2] !== undefined) {\n      if (p[3] === undefined) {\n        throw new Error(\"Missing second number in range\");\n      }\n      loslice = parseInt(p[2], 10);\n    }\n    if (p[3] !== undefined) {\n      if (p[2] === undefined) {\n        hislice = parseInt(p[3], 10);\n        if (upperCaseGrip === grip) {\n          loslice = hislice;\n        } else {\n          loslice = 1;\n        }\n      } else {\n        hislice = parseInt(p[3], 10);\n      }\n    }\n    loslice--;\n    hislice--;\n    if (fullrotation) {\n      loslice = 0;\n      hislice = this.moveplanesets[msi].length;\n    }\n    if (loslice < 0 || loslice > this.moveplanesets[msi].length ||\n      hislice < 0 || hislice > this.moveplanesets[msi].length) {\n      throw new Error(\"Bad slice spec \" + loslice + \" \" + hislice);\n    }\n    let amountstr = \"1\";\n    let amount = 1;\n    if (p[5] !== undefined) {\n      amountstr = p[5];\n      if (amountstr[0] === \"'\") {\n        amountstr = \"-\" + amountstr.substring(1);\n      }\n      if (amountstr[0] === \"+\") {\n        amountstr = amountstr.substring(1);\n      } else if (amountstr[0] === \"-\") {\n        if (amountstr === \"-\") {\n          amountstr = \"-1\";\n        }\n      }\n      amount = parseInt(amountstr, 10);\n    }\n    const r = [mv, msi, loslice, hislice, firstgrip, amount];\n    return r;\n  }\n\n  public genperms(): void { // generate permutations for moves\n    if (this.cmovesbyslice.length > 0) { // did this already?\n      return;\n    }\n    const movesbyslice = [];\n    const cmovesbyslice = [];\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveplaneset = this.moveplanesets[k];\n      const slicenum = [];\n      const slicecnts = [];\n      for (let i = 0; i < this.faces.length; i++) {\n        const face = this.faces[i];\n        let t = 0;\n        for (let j = 0; j < moveplaneset.length; j++) {\n          if (moveplaneset[j].faceside(face) < 0) {\n            t++;\n          }\n        }\n        slicenum.push(t);\n        while (slicecnts.length <= t) {\n          slicecnts.push(0);\n        }\n        slicecnts[t]++;\n      }\n      const axismoves = [];\n      const axiscmoves = [];\n      for (let sc = 0; sc < slicecnts.length; sc++) {\n        const slicemoves = [];\n        const slicecmoves = [];\n        const cubiedone = [];\n        for (let i = 0; i < this.faces.length; i++) {\n          if (slicenum[i] !== sc) {\n            continue;\n          }\n          const a = [i];\n          const b = this.facetocubies[i].slice();\n          let face = this.faces[i];\n          let fi2 = i;\n          while (true) {\n            slicenum[fi2] = -1;\n            const face2 = this.moverotations[k][0].rotateface(face);\n            fi2 = this.findface(face2);\n            if (slicenum[fi2] < 0) {\n              break;\n            }\n            if (slicenum[fi2] !== sc) {\n              throw new Error(\"Bad movement?\");\n            }\n            a.push(fi2);\n            const c = this.facetocubies[fi2];\n            b.push(c[0], c[1]);\n            face = face2;\n          }\n          if (a.length === 1 && this.orientCenters) {\n            for (let ii = 1; ii < this.movesetorders[k]; ii++) {\n              a.push(a[0]);\n              b.push(b[0], ii);\n              // <><>\n              this.cubies[b[0]].push(this.cubies[b[0]][0]);\n            }\n            this.duplicatedFaces[a[0]] = this.movesetorders[k];\n            this.duplicatedCubies[b[0]] = this.movesetorders[k];\n            this.orbitoris[this.cubiesetnums[b[0]]] = this.movesetorders[k];\n          }\n          if (a.length > 1) {\n            slicemoves.push(a);\n          }\n          if (b.length > 2 && !cubiedone[b[0]]) {\n            slicecmoves.push(b);\n          }\n          for (let j = 0; j < b.length; j += 2) {\n            cubiedone[b[j]] = true;\n          }\n        }\n        axismoves.push(slicemoves);\n        axiscmoves.push(slicecmoves);\n      }\n      movesbyslice.push(axismoves);\n      cmovesbyslice.push(axiscmoves);\n    }\n    this.movesbyslice = movesbyslice;\n    this.cmovesbyslice = cmovesbyslice;\n    if (this.movelist !== undefined) {\n      const parsedmovelist: any[] = [];\n      // make sure the movelist makes sense based on the geos.\n      for (let i = 0; i < this.movelist.length; i++) {\n        parsedmovelist.push(this.parsemove(this.movelist[i]));\n      }\n      this.parsedmovelist = parsedmovelist;\n    }\n  }\n\n  public getfaces(): number[][][] { // get the faces for 3d.\n    return this.faces.map((_) => {\n      return _.map((__) => [__.b, __.c, __.d]);\n    });\n  }\n\n  public getboundarygeometry(): any { // get the boundary geometry\n    return {\n      baseplanes: this.baseplanes,\n      facenames: this.facenames,\n      faceplanes: this.faceplanes,\n      vertexnames: this.vertexnames,\n      edgenames: this.edgenames,\n      geonormals: this.geonormals,\n    };\n  }\n\n  public getmovesets(k: number): any {\n    // get the move sets we support based on slices\n    // for even values we omit the middle \"slice\".  This isn't perfect\n    // but it is what we do for now.\n    // if there was a move list specified, pull values from that\n    const slices = this.moveplanesets[k].length;\n    if (slices > 30) {\n      throw new Error(\"Too many slices for getmovesets bitmasks\");\n    }\n    let r = [];\n    if (this.parsedmovelist !== undefined) {\n      for (let i = 0; i < this.parsedmovelist.length; i++) {\n        const parsedmove = this.parsedmovelist[i];\n        if (parsedmove[1] !== k) {\n          continue;\n        }\n        if (parsedmove[4]) {\n          r.push((2 << parsedmove[3]) - (1 << parsedmove[2]));\n        } else {\n          r.push((2 << (slices - parsedmove[2])) - (1 << (slices - parsedmove[3])));\n        }\n        r.push(parsedmove[5]);\n      }\n    } else if (this.vertexmoves && !this.allmoves) {\n      const msg = this.movesetgeos[k];\n      if (msg[1] !== msg[3]) {\n        for (let i = 0; i < slices; i++) {\n          if (msg[1] !== \"v\") {\n            if (this.outerblockmoves) {\n              r.push((2 << slices) - (2 << i));\n            } else {\n              r.push(2 << i);\n            }\n            r.push(1);\n          } else {\n            if (this.outerblockmoves) {\n              r.push((2 << i) - 1);\n            } else {\n              r.push(1 << i);\n            }\n            r.push(1);\n          }\n        }\n      }\n    } else {\n      for (let i = 0; i <= slices; i++) {\n        if (!this.allmoves && i + i === slices) {\n          continue;\n        }\n        if (this.outerblockmoves) {\n          if (i + i > slices) {\n            r.push((2 << slices) - (1 << i));\n          } else {\n            r.push((2 << i) - 1);\n          }\n        } else {\n          r.push(1 << i);\n        }\n        r.push(1);\n      }\n    }\n    if (this.fixedCubie >= 0) {\n      const dep = 1 << +this.cubiekeys[this.fixedCubie].trim().split(\" \")[k];\n      const newr = [];\n      for (let i = 0; i < r.length; i += 2) {\n        let o = r[i];\n        if (o & dep) {\n          o = (2 << slices) - 1 - o;\n        }\n        let found = false;\n        for (let j = 0; j < newr.length; j += 2) {\n          if (newr[j] === o && newr[j + 1] === r[i + 1]) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          newr.push(o);\n          newr.push(r[i + 1]);\n        }\n      }\n      r = newr;\n    }\n    if (this.addrotations) {\n      r.push((2 << slices) - 1);\n      r.push(1);\n    }\n    return r;\n  }\n\n  public graybyori(cubie: number): boolean {\n    let ori = this.cubies[cubie].length;\n    if (this.duplicatedCubies[cubie]) {\n      ori = 1;\n    }\n    return ((ori === 1 && (this.graycenters || !this.centersets)) ||\n      (ori === 2 && (this.grayedges || !this.edgesets)) ||\n      (ori > 2 && (this.graycorners || !this.cornersets)));\n  }\n\n  public skipbyori(cubie: number): boolean {\n    let ori = this.cubies[cubie].length;\n    if (this.duplicatedCubies[cubie]) {\n      ori = 1;\n    }\n    return ((ori === 1 && !this.centersets) ||\n      (ori === 2 && !this.edgesets) ||\n      (ori > 2 && !this.cornersets));\n  }\n\n  public skipcubie(set: number[]): boolean {\n    if (set.length === 0) {\n      return true;\n    }\n    const fi = set[0];\n    return this.skipbyori(fi);\n  }\n\n  public skipset(set: number[]): boolean {\n    if (set.length === 0) {\n      return true;\n    }\n    const fi = set[0];\n    return this.skipbyori(this.facetocubies[fi][0]);\n  }\n\n  public header(comment: string): string {\n    return comment + copyright + \"\\n\" +\n      comment + this.args + \"\\n\";\n  }\n\n  public writegap(): string { // write out a gap set of generators\n    const os = this.getOrbitsDef(false);\n    const r = [];\n    const mvs = [];\n    for (let i = 0; i < os.moveops.length; i++) {\n      const movename = \"M_\" + os.movenames[i];\n      // gap doesn't like angle brackets in IDs\n      mvs.push(movename);\n      r.push(movename + \":=\" + os.moveops[i].toPerm().toGap() + \";\");\n    }\n    r.push(\"Gen:=[\");\n    r.push(mvs.join(\",\"));\n    r.push(\"];\");\n    const ip = os.solved.identicalPieces();\n    r.push(\"ip:=[\" + ip.map((_) => \"[\" + _.map((__) => __ + 1).join(\",\") + \"]\").\n      join(\",\") + \"];\");\n    r.push(\"\");\n    return this.header(\"# \") + r.join(\"\\n\");\n  }\n\n  public writeksolve(name: string = \"PuzzleGeometryPuzzle\", fortwisty: boolean = false): string {\n    const od = this.getOrbitsDef(fortwisty);\n    if (fortwisty) {\n      return od.toKsolve(name, fortwisty).join(\"\\n\");\n    } else {\n      return this.header(\"# \") + od.toKsolve(name, fortwisty).join(\"\\n\");\n    }\n  }\n  public writekpuzzle(): any {\n    return this.getOrbitsDef(true).toKpuzzle();\n  }\n\n  public getOrbitsDef(fortwisty: boolean): OrbitsDef {\n    // generate a representation of the puzzle\n    const setmoves = [];\n    const setnames: string[] = [];\n    const setdefs: OrbitDef[] = [];\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveset = this.getmovesets(k);\n      // check there's no redundancy in moveset.\n      for (let i = 0; i < moveset.length; i += 2) {\n        for (let j = 0; j < i; j += 2) {\n          if (moveset[i] === moveset[j] && moveset[i + 1] === moveset[j + 1]) {\n            throw new Error(\"Redundant moves in moveset.\");\n          }\n        }\n      }\n      let allbits = 0;\n      for (let i = 0; i < moveset.length; i += 2) {\n        allbits |= moveset[i];\n      }\n      const axiscmoves = this.cmovesbyslice[k];\n      for (let i = 0; i < axiscmoves.length; i++) {\n        if (((allbits >> i) & 1) === 0) {\n          continue;\n        }\n        const slicecmoves = axiscmoves[i];\n        for (let j = 0; j < slicecmoves.length; j++) {\n          if (this.skipcubie(slicecmoves[j])) {\n            continue;\n          }\n          const ind = this.cubiesetnums[slicecmoves[j][0]];\n          setmoves[ind] = 1;\n        }\n      }\n    }\n    for (let i = 0; i < this.cubiesetnames.length; i++) {\n      if (!setmoves[i]) {\n        continue;\n      }\n      setnames.push(this.cubiesetnames[i]);\n      setdefs.push(new OrbitDef(this.cubieords[i],\n        this.killorientation ? 1 : this.orbitoris[i]));\n    }\n    const solved: Orbit[] = [];\n    for (let i = 0; i < this.cubiesetnames.length; i++) {\n      if (!setmoves[i]) {\n        continue;\n      }\n      const p = [];\n      const o = [];\n      for (let j = 0; j < this.cubieords[i]; j++) {\n        if (fortwisty) {\n          p.push(j);\n        } else {\n          const cubie = this.cubiesetcubies[i][j];\n          p.push(this.cubievaluemap[cubie]);\n        }\n        o.push(0);\n      }\n      solved.push(new Orbit(p, o,\n        this.killorientation ? 1 : this.orbitoris[i]));\n    }\n    const movenames: string[] = [];\n    const moves: Transformation[] = [];\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveplaneset = this.moveplanesets[k];\n      const slices = moveplaneset.length;\n      const moveset = this.getmovesets(k);\n      const movesetgeo = this.movesetgeos[k];\n      for (let i = 0; i < moveset.length; i += 2) {\n        const movebits = moveset[i];\n        const mna = getmovename(movesetgeo, movebits, slices);\n        const movename = mna[0];\n        const inverted = mna[1];\n        movenames.push(movename);\n        const moveorbits: Orbit[] = [];\n        const perms = [];\n        const oris = [];\n        for (let ii = 0; ii < this.cubiesetnames.length; ii++) {\n          const p = [];\n          for (let kk = 0; kk < this.cubieords[ii]; kk++) {\n            p.push(kk);\n          }\n          perms.push(p);\n          const o = [];\n          for (let kk = 0; kk < this.cubieords[ii]; kk++) {\n            o.push(0);\n          }\n          oris.push(o);\n        }\n        const axiscmoves = this.cmovesbyslice[k];\n        for (let m = 0; m < axiscmoves.length; m++) {\n          if (((movebits >> m) & 1) === 0) {\n            continue;\n          }\n          const slicecmoves = axiscmoves[m];\n          for (let j = 0; j < slicecmoves.length; j++) {\n            const mperm = slicecmoves[j].slice();\n            const setnum = this.cubiesetnums[mperm[0]];\n            for (let ii = 0; ii < mperm.length; ii += 2) {\n              mperm[ii] = this.cubieordnums[mperm[ii]];\n            }\n            let inc = 2;\n            let oinc = 3;\n            if (inverted) {\n              inc = mperm.length - 2;\n              oinc = mperm.length - 1;\n            }\n            for (let ii = 0; ii < mperm.length; ii += 2) {\n              perms[setnum][mperm[(ii + inc) % mperm.length]] = mperm[ii];\n              if (this.killorientation) {\n                oris[setnum][mperm[ii]] = 0;\n              } else {\n                oris[setnum][mperm[ii]] =\n                  (mperm[(ii + oinc) % mperm.length] -\n                    mperm[(ii + 1) % mperm.length] +\n                    this.orbitoris[setnum]) % this.orbitoris[setnum];\n              }\n            }\n          }\n        }\n        for (let ii = 0; ii < this.cubiesetnames.length; ii++) {\n          if (!setmoves[ii]) {\n            continue;\n          }\n          const no = new Array<number>(oris[ii].length);\n          // convert ksolve oris to our internal ori rep\n          for (let jj = 0; jj < perms[ii].length; jj++) {\n            no[jj] = oris[ii][perms[ii][jj]];\n          }\n          moveorbits.push(new Orbit(perms[ii], no,\n            this.killorientation ? 1 : this.orbitoris[ii]));\n        }\n        let mv = new Transformation(moveorbits);\n        if (moveset[i + 1] !== 1) {\n          mv = mv.mulScalar(moveset[i + 1]);\n        }\n        moves.push(mv);\n      }\n    }\n    this.ksolvemovenames = movenames; // hack!\n    let r = new OrbitsDef(setnames, setdefs, new VisibleState(solved),\n      movenames, moves);\n    if (this.optimize) {\n      r = r.optimize();\n    }\n    if (this.scramble !== 0) {\n      r.scramble(this.scramble);\n    }\n    return r;\n  }\n\n  public getMovesAsPerms(): Perm[] {\n    return this.getOrbitsDef(false).moveops.\n      map((_: Transformation) => _.toPerm());\n  }\n\n  public showcanon(disp: (s: string) => void): void {\n    // show information for canonical move derivation\n    showcanon(this.getOrbitsDef(false), disp);\n  }\n\n  public getsolved(): Perm { // get a solved position\n    const r = [];\n    for (let i = 0; i < this.basefacecount; i++) {\n      for (let j = 0; j < this.stickersperface; j++) {\n        r.push(i);\n      }\n    }\n    return new Perm(r);\n  }\n\n  public getInitial3DRotation() {\n    const basefacecount = this.basefacecount;\n    if (basefacecount === 4) {\n      return new Quat(0.7043069543230507, 0.0617237605829268,\n        0.4546068756768417, 0.5417328493446099);\n    } else if (basefacecount === 6) {\n      return new Quat(0.3419476009844782, 0.17612448544695208,\n        -0.42284908551877964, 0.8205185279339757);\n    } else if (basefacecount === 8) {\n      return new Quat(-0.6523285484575103, 0.2707374015470506,\n        0.6537994145576647, 0.27150515611112014);\n    } else if (basefacecount === 12) {\n      return new Quat(-0.5856747836703331, 0.02634133605619232,\n        0.7075560342412421, 0.39453217891103587);\n    } else if (basefacecount === 20) {\n      return new Quat(0.7052782621769977, 0.6377976252204238,\n        0.30390357803973855, 0.05864620549043545);\n    } else {\n      throw new Error(\"Wrong base face count\");\n    }\n  }\n\n  public generatesvg(w: number = 800, h: number = 500, trim: number = 10, threed: boolean = false): string {\n    // generate svg to interoperate with Lucas twistysim\n    w -= 2 * trim;\n    h -= 2 * trim;\n    function extendedges(a: number[][], n: number): void {\n      let dx = a[1][0] - a[0][0];\n      let dy = a[1][1] - a[0][1];\n      const ang = 2 * Math.PI / n;\n      const cosa = Math.cos(ang);\n      const sina = Math.sin(ang);\n      for (let i = 2; i < n; i++) {\n        const ndx = dx * cosa + dy * sina;\n        dy = dy * cosa - dx * sina;\n        dx = ndx;\n        a.push([a[i - 1][0] + dx, a[i - 1][1] + dy]);\n      }\n    }\n    // if we don't add this noise to coordinate values, then Safari\n    // doesn't render our polygons correctly.  What a hack.\n    function noise(c: number): number {\n      return c + 0 * (Math.random() - 0.5);\n    }\n    function drawedges(id: string, pts: number[][], color: string)\n      : string {\n      return \"<polygon id=\\\"\" + id + \"\\\" class=\\\"sticker\\\" style=\\\"fill: \" + color +\n        \"\\\" points=\\\"\" +\n        pts.map((p) => noise(p[0]) + \" \" + noise(p[1])).join(\" \") +\n        \"\\\"/>\\n\";\n    }\n    // What grips do we need?  if rotations, add all grips.\n    let needvertexgrips = this.addrotations;\n    let neededgegrips = this.addrotations;\n    let needfacegrips = this.addrotations;\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const msg = this.movesetgeos[i];\n      for (let j = 1; j <= 3; j += 2) {\n        if (msg[j] === \"v\") {\n          needvertexgrips = true;\n        }\n        if (msg[j] === \"f\") {\n          needfacegrips = true;\n        }\n        if (msg[j] === \"e\") {\n          neededgegrips = true;\n        }\n      }\n    }\n    // Find a net from a given face count.  Walk it, assuming we locate\n    // the first edge from (0,0) to (1,1) and compute the minimum and\n    // maximum vertex locations from this.  Then do a second walk, and\n    // assign the actual geometry.\n    this.genperms();\n    const boundarygeo = this.getboundarygeometry();\n    const face0 = boundarygeo.facenames[0][0];\n    const polyn = face0.length; // number of vertices; 3, 4, or 5\n    const net = this.net;\n    if (net === null) {\n      throw new Error(\"No net?\");\n    }\n    const edges: any = {};\n    let minx = 0;\n    let miny = 0;\n    let maxx = 1;\n    let maxy = 0;\n    edges[net[0][0]] = [[1, 0], [0, 0]];\n    extendedges(edges[net[0][0]], polyn);\n    for (let i = 0; i < net.length; i++) {\n      const f0 = net[i][0];\n      if (!edges[f0]) {\n        throw new Error(\"Bad edge description; first edge not connected.\");\n      }\n      for (let j = 1; j < net[i].length; j++) {\n        const f1 = net[i][j];\n        if (f1 === \"\" || edges[f1]) {\n          continue;\n        }\n        edges[f1] = [edges[f0][j % polyn], edges[f0][(j + polyn - 1) % polyn]];\n        extendedges(edges[f1], polyn);\n      }\n    }\n    for (const f in edges) {\n      const es = edges[f];\n      for (let i = 0; i < es.length; i++) {\n        minx = Math.min(minx, es[i][0]);\n        maxx = Math.max(maxx, es[i][0]);\n        miny = Math.min(miny, es[i][1]);\n        maxy = Math.max(maxy, es[i][1]);\n      }\n    }\n    const sc = Math.min(w / (maxx - minx), h / (maxy - miny));\n    const xoff = 0.5 * (w - sc * (maxx + minx));\n    const yoff = 0.5 * (h - sc * (maxy + miny));\n    const geos: any = {};\n    const bg = this.getboundarygeometry();\n    const edges2: any = {};\n    const initv = [[sc + xoff, yoff], [xoff, yoff]];\n    edges2[net[0][0]] = initv;\n    extendedges(edges2[net[0][0]], polyn);\n    geos[this.facenames[0][1]] = this.project2d(0, 0,\n      [new Quat(0, initv[0][0], initv[0][1], 0),\n      new Quat(0, initv[1][0], initv[1][1], 0)]);\n    const connectat = [];\n    connectat[0] = 0;\n    for (let i = 0; i < net.length; i++) {\n      const f0 = net[i][0];\n      if (!edges2[f0]) {\n        throw new Error(\"Bad edge description; first edge not connected.\");\n      }\n      let gfi = -1;\n      for (let j = 0; j < bg.facenames.length; j++) {\n        if (f0 === bg.facenames[j][1]) {\n          gfi = j;\n          break;\n        }\n      }\n      if (gfi < 0) {\n        throw new Error(\"Could not find first face name \" + f0);\n      }\n      const thisface = bg.facenames[gfi][0];\n      for (let j = 1; j < net[i].length; j++) {\n        const f1 = net[i][j];\n        if (f1 === \"\" || edges2[f1]) {\n          continue;\n        }\n        edges2[f1] = [edges2[f0][j % polyn], edges2[f0][(j + polyn - 1) % polyn]];\n        extendedges(edges2[f1], polyn);\n        // what edge are we at?\n        const caf0 = connectat[gfi];\n        const mp = thisface[(caf0 + j) % polyn].sum(thisface[(caf0 + j + polyn - 1) % polyn]).smul(0.5);\n        const epi = findelement(bg.edgenames, mp);\n        const edgename = bg.edgenames[epi][1];\n        const el = splitByFaceNames(edgename, this.facenames);\n        const gf1 = el[(f0 === el[0]) ? 1 : 0];\n        let gf1i = -1;\n        for (let k = 0; k < bg.facenames.length; k++) {\n          if (gf1 === bg.facenames[k][1]) {\n            gf1i = k;\n            break;\n          }\n        }\n        if (gf1i < 0) {\n          throw new Error(\"Could not find second face name\");\n        }\n        const otherface = bg.facenames[gf1i][0];\n        for (let k = 0; k < otherface.length; k++) {\n          const mp2 = otherface[k].sum(otherface[(k + 1) % polyn]).smul(0.5);\n          if (mp2.dist(mp) <= eps) {\n            const p1 = edges2[f0][(j + polyn - 1) % polyn];\n            const p2 = edges2[f0][j % polyn];\n            connectat[gf1i] = k;\n            geos[gf1] = this.project2d(gf1i, k,\n              [new Quat(0, p2[0], p2[1], 0), new Quat(0, p1[0], p1[1], 0)]);\n            break;\n          }\n        }\n      }\n    }\n    // Let's build arrays for faster rendering.  We want to map from geo\n    // base face number to color, and we want to map from geo face number\n    // to 2D geometry.  These can be reused as long as the puzzle overall\n    // orientation and canvas size remains unchanged.\n    const pos = this.getsolved();\n    const colormap = [];\n    const facegeo = [];\n    for (let i = 0; i < this.basefacecount; i++) {\n      colormap[i] = this.colors[this.facenames[i][1]];\n    }\n    let hix = 0;\n    let hiy = 0;\n    const rot = this.getInitial3DRotation();\n    for (let i = 0; i < this.faces.length; i++) {\n      let face = this.faces[i];\n      face = rot.rotateface(face);\n      for (let j = 0; j < face.length; j++) {\n        hix = Math.max(hix, Math.abs(face[j].b));\n        hiy = Math.max(hiy, Math.abs(face[j].c));\n      }\n    }\n    const sc2 = Math.min(h / hiy / 2, (w - trim) / hix / 4);\n    const that = this;\n    function mappt2d(fn: number, q: Quat): number[] {\n      if (threed) {\n        const xoff2 = 0.5 * trim + 0.25 * w;\n        const xmul = (that.baseplanes[fn].rotateplane(rot).d < 0 ? 1 : -1);\n        return [trim + w * 0.5 + xmul * (xoff2 - q.b * sc2), trim + h * 0.5 + q.c * sc2];\n      } else {\n        const g = geos[that.facenames[fn][1]];\n        return [trim + q.dot(g[0]) + g[2].b, trim + h - q.dot(g[1]) - g[2].c];\n      }\n    }\n    for (let i = 0; i < this.faces.length; i++) {\n      let face = that.faces[i];\n      const facenum = Math.floor(i / that.stickersperface);\n      if (threed) {\n        face = rot.rotateface(face);\n      }\n      facegeo.push(face.map((_: Quat) => mappt2d(facenum, _)));\n    }\n    const svg = [];\n    // group each base face so we can add a hover element\n    for (let j = 0; j < this.basefacecount; j++) {\n      svg.push(\"<g>\");\n      svg.push(\"<title>\" + this.facenames[j][1] + \"</title>\\n\");\n      for (let ii = 0; ii < this.stickersperface; ii++) {\n        const i = j * this.stickersperface + ii;\n        const cubie = this.facetocubies[i][0];\n        const cubieori = this.facetocubies[i][1];\n        const cubiesetnum = this.cubiesetnums[cubie];\n        const cubieord = this.cubieordnums[cubie];\n        const color = this.graybyori(cubie) ? \"#808080\" : colormap[pos.p[i]];\n        let id = this.cubiesetnames[cubiesetnum] +\n          \"-l\" + cubieord + \"-o\" + cubieori;\n        svg.push(drawedges(id, facegeo[i], color));\n        if (this.duplicatedFaces[i]) {\n          for (let jj = 1; jj < this.duplicatedFaces[i]; jj++) {\n            id = this.cubiesetnames[cubiesetnum] +\n              \"-l\" + cubieord + \"-o\" + jj;\n            svg.push(drawedges(id, facegeo[i], color));\n          }\n        }\n      }\n      svg.push(\"</g>\");\n    }\n    const svggrips: any[] = [];\n    function addgrip(onface: number, name: string, pt: Quat, order: number): void {\n      const pt2 = mappt2d(onface, pt);\n      for (let i = 0; i < svggrips.length; i++) {\n        if (Math.hypot(pt2[0] - svggrips[i][0], pt2[1] - svggrips[i][1]) < eps) {\n          return;\n        }\n      }\n      svggrips.push([pt2[0], pt2[1], name, order]);\n    }\n    for (let i = 0; i < this.faceplanes.length; i++) {\n      const baseface = this.facenames[i][0];\n      let facecoords = baseface;\n      if (threed) {\n        facecoords = rot.rotateface(facecoords);\n      }\n      if (needfacegrips) {\n        let pt = this.faceplanes[i][0];\n        if (threed) {\n          pt = pt.rotatepoint(rot);\n        }\n        addgrip(i, this.faceplanes[i][1], pt, polyn);\n      }\n      for (let j = 0; j < baseface.length; j++) {\n        if (neededgegrips) {\n          const mp = baseface[j].sum(\n            baseface[(j + 1) % baseface.length]).smul(0.5);\n          const ep = findelement(this.edgenames, mp);\n          const mpc = facecoords[j].sum(\n            facecoords[(j + 1) % baseface.length]).smul(0.5);\n          addgrip(i, this.edgenames[ep][1], mpc, 2);\n        }\n        if (needvertexgrips) {\n          const vp = findelement(\n            this.vertexnames, baseface[j]);\n          addgrip(i, this.vertexnames[vp][1], facecoords[j],\n            this.cornerfaces);\n        }\n      }\n    }\n    const html = '<svg id=\"svg\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 800 500\">\\n' +\n      '<style type=\"text/css\"><![CDATA[' +\n      \".sticker { stroke: #000000; stroke-width: 1px; }\" +\n      \"]]></style>\\n\" +\n      svg.join(\"\") + \"</svg>\";\n    this.svggrips = svggrips;\n    return html;\n  }\n\n  public get3d(trim?: number): StickerDat {\n    const stickers: any = [];\n    const rot = this.getInitial3DRotation();\n    const faces: any = [];\n    const maxdist: number = 0.52 * this.basefaces[0][0].len();\n    for (let i = 0; i < this.basefaces.length; i++) {\n      const coords = rot.rotateface(this.basefaces[i]);\n      const name = this.facenames[i][1];\n      faces.push({ coords: toFaceCoords(coords, maxdist), name });\n    }\n    for (let i = 0; i < this.faces.length; i++) {\n      const facenum = Math.floor(i / this.stickersperface);\n      const cubie = this.facetocubies[i][0];\n      const cubieori = this.facetocubies[i][1];\n      const cubiesetnum = this.cubiesetnums[cubie];\n      const cubieord = this.cubieordnums[cubie];\n      const color = this.graybyori(cubie) ? \"#808080\" :\n        this.colors[this.facenames[facenum][1]];\n      let coords = rot.rotateface(this.faces[i]);\n      if (trim && trim > 0) {\n        coords = trimEdges(coords, trim);\n      }\n      stickers.push({\n        coords: toFaceCoords(coords, maxdist),\n        color, orbit: this.cubiesetnames[cubiesetnum],\n        ord: cubieord, ori: cubieori,\n      });\n      if (this.duplicatedFaces[i]) {\n        for (let jj = 1; jj < this.duplicatedFaces[i]; jj++) {\n          stickers.push({\n            coords: toFaceCoords(coords, maxdist),\n            color, orbit: this.cubiesetnames[cubiesetnum],\n            ord: cubieord, ori: jj,\n          });\n        }\n      }\n    }\n    const grips: StickerDatAxis[] = [];\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const msg = this.movesetgeos[i];\n      const order = this.movesetorders[i];\n      for (let j = 0; j < this.geonormals.length; j++) {\n        const gn = this.geonormals[j];\n        if (msg[0] === gn[1] && msg[1] === gn[2]) {\n          grips.push([toCoords(gn[0].rotatepoint(rot), 1),\n          msg[0], order]);\n          grips.push([toCoords(gn[0].rotatepoint(rot).smul(-1), 1),\n          msg[2], order]);\n        }\n      }\n    }\n    return { stickers, faces, axis: grips };\n  }\n}\n","import { identity, Perm } from \"./Perm\";\n\nclass FactoredNumber {\n  public mult: number[];\n  constructor() {\n    this.mult = [];\n  }\n\n  public multiply(n: number): void {\n    for (let f = 2; f * f <= n; f++) {\n      while (n % f === 0) {\n        if (undefined !== this.mult[f]) {\n          this.mult[f]++;\n        } else {\n          this.mult[f] = 1;\n        }\n        n /= f;\n      }\n    }\n    if (n > 1) {\n      if (undefined !== this.mult[n]) {\n        this.mult[n]++;\n      } else {\n        this.mult[n] = 1;\n      }\n    }\n  }\n\n  public toString(): string {\n    let r = \"\";\n    for (let i = 0; i < this.mult.length; i++) {\n      if (undefined !== this.mult[i]) {\n        if (r !== \"\") {\n          r += \"*\";\n        }\n        r += i;\n        if (this.mult[i] > 1) {\n          r += \"^\" + this.mult[i];\n        }\n      }\n    }\n    return r;\n  }\n}\n\nexport function schreierSims(g: Perm[], disp: (s: string) => void): number {\n  const n = g[0].p.length;\n  const e = identity(n);\n  let sgs: Perm[][] = [];\n  let sgsi: Perm[][] = [];\n  let sgslen: number[][] = [];\n  let Tk: Perm[][] = [];\n  let Tklen: number[][] = [];\n  function resolve(p: Perm): boolean {\n    for (let i = p.p.length - 1; i >= 0; i--) {\n      const j = p.p[i];\n      if (j !== i) {\n        if (!sgs[i][j]) {\n          return false;\n        }\n        p = p.mul(sgsi[i][j]);\n      }\n    }\n    return true;\n  }\n  function knutha(k: number, p: Perm, len: number): void {\n    Tk[k].push(p);\n    Tklen[k].push(len);\n    for (let i = 0; i < sgs[k].length; i++) {\n      if (sgs[k][i]) {\n        knuthb(k, sgs[k][i].mul(p), len + sgslen[k][i]);\n      }\n    }\n  }\n  function knuthb(k: number, p: Perm, len: number): void {\n    const j = p.p[k];\n    if (!sgs[k][j]) {\n      sgs[k][j] = p;\n      sgsi[k][j] = p.inv();\n      sgslen[k][j] = len;\n      for (let i = 0; i < Tk[k].length; i++) {\n        knuthb(k, p.mul(Tk[k][i]), len + Tklen[k][i]);\n      }\n      return;\n    }\n    const p2 = p.mul(sgsi[k][j]);\n    if (!resolve(p2)) {\n      knutha(k - 1, p2, len + sgslen[k][j]);\n    }\n  }\n  function getsgs(): number {\n    sgs = [];\n    sgsi = [];\n    Tk = [];\n    sgslen = [];\n    Tklen = [];\n    for (let i = 0; i < n; i++) {\n      sgs.push([]);\n      sgsi.push([]);\n      sgslen.push([]);\n      Tk.push([]);\n      Tklen.push([]);\n      sgs[i][i] = e;\n      sgsi[i][i] = e;\n      sgslen[i][i] = 0;\n    }\n    let none = 0;\n    let sz = 1;\n    for (let i = 0; i < g.length; i++) {\n      knutha(n - 1, g[i], 1);\n      sz = 1;\n      let tks = 0;\n      let sollen = 0;\n      const avgs = [];\n      const mults = new FactoredNumber();\n      for (let j = 0; j < n; j++) {\n        let cnt = 0;\n        let lensum = 0;\n        for (let k = 0; k < n; k++) {\n          if (sgs[j][k]) {\n            cnt++;\n            lensum += sgslen[j][k];\n            if (j !== k) {\n              none++;\n            }\n          }\n        }\n        tks += Tk[j].length;\n        sz *= cnt;\n        if (cnt > 1) {\n          mults.multiply(cnt);\n        }\n        const avg = lensum / cnt;\n        avgs.push(avg);\n        sollen += avg;\n      }\n      disp(\"\" + i + \": sz \" + sz + \" T \" + tks + \" sol \" + sollen + \" none \" + none + \" mults \" + mults);\n    }\n    return sz;\n  }\n  return getsgs();\n}\n"],"names":["iota","n","c","Array","i","lcm","a","b","t","m","gcd","Perm","[object Object]","this","length","p","join","p2","cyc","seen","incyc","j","push","r","cs","OrbitDef","size","mod","factorial","Math","pow","OrbitsDef","orbitnames","orbitdefs","solved","movenames","moveops","name","forTwisty","result","o","orbits","toKsolveVS","isIdentity","toKsolve","start","numPieces","orientations","toKpuzzle","moves","mp","startPieces","neworbitnames","neworbitdefs","newsolved","newmoveops","om","du","DisjointUnion","changed","k","perm","ori","union","keepori","duo","find","nontriv","multiple","h","no","on","nv","remapVS","remap","killOri","VisibleState","map","_","Transformation","pool","floor","random","ri","rj","rm","mul","s","reassemblySize","Orbit","orimod","zeros","newPerm","newOri","done","v","undefined","toPerm","order","nextNew","reassign","ov","newori","permutation","orientation","TransformationBase","newOrbits","inv","equal","perms","identicalPieces","super","internalMul","e","internalInv","heads","ah","bh","centermassface","face","Quat","sum","smul","solvethreeplanes","p1","p3","planes","intersect3","dt","d","q","hypot","sqrt","dot","normalize","acos","a00","a01","a02","a10","a11","a12","a20","a21","a22","invrot","that","rotatepoint","cubie","rotateface","det","det3x3","abs","x","faces","nfaces","inout","side","nface","kk","vk","pt","Error","dist","uniqueplanes","g","planerot","rotateplane","wasseen","getface","cross","Puzzles","2x2x2","3x3x3","4x4x4","5x5x5","6x6x6","7x7x7","8x8x8","9x9x9","10x10x10","11x11x11","12x12x12","13x13x13","20x20x20","30x30x30","skewb","master skewb","professor skewb","compy cube","helicopter","dino","little chop","pyramorphix","mastermorphix","pyraminx","Jing pyraminx","master paramorphix","megaminx","gigaminx","pentultimate","starminx","starminx 2","pyraminx crystal","chopasaurus","big chop","skewb diamond","FTO","Christopher's jewel","octastar","Trajber's octahedron","radio chop","icosamate","icosahedron 2","icosahedron 3","icosahedron static faces","icosahedron moving faces","Eitan's star","2x2x2 + dino","2x2x2 + little chop","dino + little chop","2x2x2 + dino + little chop","megaminx + chopasaurus","starminx combo","defaultnets","4","6","8","12","20","defaultcolors","F","D","L","R","U","B","M","N","C","A","E","BF","BR","BL","I","G","S","H","J","K","O","P","Q","defaultfaceorders","findelement","getpuzzles","getpuzzle","puzzleName","parsedesc","split","filter","Boolean","getPuzzleGeometryByDesc","desc","options","shape","cuts","pg","PuzzleGeometry","concat","allstickers","genperms","getPuzzleGeometryByName","getmovename","geo","bits","slices","nbits","inverted","movenameFamily","movenamePrefix","hibit","String","toLowerCase","splitByFaceNames","facenames","at","found","substr","startsWith","toCoords","maxdist","toFaceCoords","trimEdges","tr","iter","pi","ni","sub","good","optionlist","verbose","allmoves","outerblockmoves","vertexmoves","addrotations","cornersets","centersets","edgesets","graycorners","graycenters","grayedges","movelist","killorientation","optimize","scramble","fixPiece","orientCenters","args","console","log","header","create","moveplanes","cubies","s5","cube","octahedron","dx","dy","dd","ang","PI","cos","sin","icosahedron","d36","dodecahedron","rotations","ns","negns","closure","baseplane","baseplanerot","baseplanes","basefacecount","net","colors","faceorder","baseface","facenormal","makenormal","edgenormal","vertexnormal","cutplanes","normal","makecut","boundary","basefaces","faceplanes","vertexnames","edgenames","edgesperface","searchaddelement","jj","otherfaces","facelist","el","facenametoindex","faceindextoname","fi","ii","fn2","of","faceprecedence","faceplane","facename","midpoint","jjj","midpoint2","e1","e2","c1","c2","cornerfaces","st","geonormals","zero","edgedistance","vertexdistance","sameplane","cutfaces","stickersperface","shortedge","moveplanesets","faceside","facetocubies","findface","cm","key","keyface","facelisthash","face2","facen","edgen","targvec","edgen2","plane","x0","olen","len","y0","delta","cosr","sinr","x1","y1","off","rots","expandfaces","qnormal","normalizeplane","goodnormal","sort","sizes","moverotations","angle","reverse","sizes2","movesetorders","movesetgeos","p0","neg","pos","cubiehash","cubiekey","cubiekeys","suff","s2","Object","keys","getfaceindex","facenum","divid","cmall","looplimit","u","mini","minf","temp","ocubie","slice","ofacelist","typenames","cubiesetnames","cubietypecounts","orbitoris","cubiesetnum","cubiesetnums","cubieordnums","cubieords","cubievaluemap","cubiesetcubies","cubiekeymap","cubievalueid","facecnt","typectr","typename","queue","qg","cind","cubiecolorkey","tq","findcubie","fixedCubie","mv","re","RegExp","match","grip","fullrotation","endsWith","msi","upperCaseGrip","toUpperCase","firstgrip","spinmatch","loslice","hislice","parseInt","amountstr","amount","substring","cmovesbyslice","movesbyslice","moveplaneset","slicenum","slicecnts","axismoves","axiscmoves","sc","slicemoves","slicecmoves","cubiedone","fi2","duplicatedFaces","duplicatedCubies","parsedmovelist","parsemove","__","parsedmove","msg","dep","trim","newr","set","skipbyori","comment","os","getOrbitsDef","mvs","movename","toGap","ip","fortwisty","od","setmoves","setnames","setdefs","moveset","getmovesets","allbits","skipcubie","movesetgeo","movebits","mna","moveorbits","oris","mperm","setnum","inc","oinc","mulScalar","ksolvemovenames","disp","orders","commutes","permA","permB","curlev","0","nextlev","uniq","sti","cnt","nst","showcanon","w","threed","extendedges","cosa","sina","ndx","noise","drawedges","id","pts","color","needvertexgrips","neededgegrips","needfacegrips","polyn","getboundarygeometry","edges","minx","miny","maxx","maxy","f0","f1","f","es","min","max","xoff","yoff","geos","bg","edges2","initv","project2d","connectat","gfi","thisface","caf0","epi","gf1","gf1i","otherface","getsolved","colormap","facegeo","hix","hiy","rot","getInitial3DRotation","sc2","mappt2d","fn","xoff2","xmul","svg","cubieori","cubieord","graybyori","svggrips","addgrip","onface","pt2","facecoords","ep","mpc","vp","html","stickers","coords","orbit","ord","grips","gn","axis","FactoredNumber","mult","schreierSims","identity","sgs","sgsi","sgslen","Tk","Tklen","knutha","knuthb","resolve","none","sz","tks","sollen","mults","lensum","multiply","getsgs"],"mappings":"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"}