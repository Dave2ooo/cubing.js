{
  "version": 3,
  "sources": ["../../src/kpuzzle/transformations.ts", "../../src/kpuzzle/canonicalize.ts"],
  "sourcesContent": ["import { KPuzzleDefinition, Transformation } from \"./definition_types\";\n\nexport function Combine(\n  def: KPuzzleDefinition,\n  t1: Transformation,\n  t2: Transformation,\n): Transformation {\n  const newTrans: Transformation = {} as Transformation;\n  for (const orbitName in def.orbits) {\n    const oDef = def.orbits[orbitName];\n    const o1 = t1[orbitName];\n    const o2 = t2[orbitName];\n    const newPerm = new Array(oDef.numPieces);\n    const newOri = new Array(oDef.numPieces);\n    for (let idx = 0; idx < oDef.numPieces; idx++) {\n      newOri[idx] =\n        (o1.orientation[o2.permutation[idx]] + o2.orientation[idx]) %\n        oDef.orientations;\n      newPerm[idx] = o1.permutation[o2.permutation[idx]];\n    }\n    newTrans[orbitName] = { permutation: newPerm, orientation: newOri };\n  }\n  return newTrans;\n}\n\nexport function Multiply(\n  def: KPuzzleDefinition,\n  t: Transformation,\n  amount: number,\n): Transformation {\n  if (amount < 0) {\n    return Multiply(def, Invert(def, t), -amount);\n  }\n  if (amount === 0) {\n    return IdentityTransformation(def);\n  }\n  if (amount === 1) {\n    return t;\n  }\n  const halfish = Multiply(def, t, Math.floor(amount / 2));\n  const twiceHalfish = Combine(def, halfish, halfish);\n  if (amount % 2 === 0) {\n    return twiceHalfish;\n  } else {\n    return Combine(def, t, twiceHalfish);\n  }\n}\nexport function IdentityTransformation(\n  definition: KPuzzleDefinition,\n): Transformation {\n  const transformation = {} as Transformation;\n  for (const orbitName in definition.orbits) {\n    const orbitDefinition = definition.orbits[orbitName];\n    const newPermutation = new Array(orbitDefinition.numPieces);\n    const newOrientation = new Array(orbitDefinition.numPieces);\n    for (let i = 0; i < orbitDefinition.numPieces; i++) {\n      newPermutation[i] = i;\n      newOrientation[i] = 0;\n    }\n    const orbitTransformation = {\n      permutation: newPermutation,\n      orientation: newOrientation,\n    };\n    transformation[orbitName] = orbitTransformation;\n  }\n  return transformation;\n}\n\nexport function Invert(\n  def: KPuzzleDefinition,\n  t: Transformation,\n): Transformation {\n  const newTrans: Transformation = {} as Transformation;\n  for (const orbitName in def.orbits) {\n    const oDef = def.orbits[orbitName];\n    const o = t[orbitName];\n    const newPerm = new Array(oDef.numPieces);\n    const newOri = new Array(oDef.numPieces);\n    for (let idx = 0; idx < oDef.numPieces; idx++) {\n      const fromIdx = o.permutation[idx] as number;\n      newPerm[fromIdx] = idx;\n      newOri[fromIdx] =\n        (oDef.orientations - o.orientation[idx] + oDef.orientations) %\n        oDef.orientations;\n    }\n    newTrans[orbitName] = { permutation: newPerm, orientation: newOri };\n  }\n  return newTrans;\n}\n\nfunction gcd(a: number, b: number): number {\n  if (b) {\n    return gcd(b, a % b);\n  }\n  return a;\n}\n/* calculate the order of a particular transformation. */\nexport function Order(def: KPuzzleDefinition, t: Transformation): number {\n  let r: number = 1;\n  for (const orbitName in def.orbits) {\n    const oDef = def.orbits[orbitName];\n    const o = t[orbitName];\n    const d = new Array(oDef.numPieces);\n    for (let idx = 0; idx < oDef.numPieces; idx++) {\n      if (!d[idx]) {\n        let w = idx;\n        let om = 0;\n        let pm = 0;\n        for (;;) {\n          d[w] = true;\n          om = om + o.orientation[w];\n          pm = pm + 1;\n          w = o.permutation[w];\n          if (w === idx) {\n            break;\n          }\n        }\n        if (om !== 0) {\n          pm = (pm * oDef.orientations) / gcd(oDef.orientations, om);\n        }\n        r = (r * pm) / gcd(r, pm);\n      }\n    }\n  }\n  return r;\n}\n\nexport function EquivalentTransformations(\n  def: KPuzzleDefinition,\n  t1: Transformation,\n  t2: Transformation,\n): boolean {\n  for (const orbitName in def.orbits) {\n    const oDef = def.orbits[orbitName];\n    const o1 = t1[orbitName];\n    const o2 = t2[orbitName];\n    for (let idx = 0; idx < oDef.numPieces; idx++) {\n      if (o1.orientation[idx] !== o2.orientation[idx]) {\n        return false;\n      }\n      if (o1.permutation[idx] !== o2.permutation[idx]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nexport function EquivalentStates(\n  def: KPuzzleDefinition,\n  t1: Transformation,\n  t2: Transformation,\n): boolean {\n  // Turn transformations into states.\n  // This accounts for indistinguishable pieces.\n  return EquivalentTransformations(\n    def,\n    Combine(def, def.startPieces, t1),\n    Combine(def, def.startPieces, t2),\n  );\n}\n", "/**\n *  This module manages canonical sequences.  You can merge sequences\n *  combining moves (fully respecting commuting moves), and you can\n *  generate canonical sequences efficiently.\n */\nimport { KPuzzleDefinition, Transformation } from \"./definition_types\";\nimport {\n  EquivalentTransformations,\n  Combine,\n  IdentityTransformation,\n} from \"./transformations\";\nimport {\n  modifiedBlockMove,\n  blockMoveToString,\n  BlockMove,\n  Sequence,\n} from \"../alg\";\n\nclass InternalMove {\n  constructor(public base: number, public twist: number) {}\n  public getTransformation(canon: Canonicalize): Transformation {\n    return canon.transforms[this.base][this.twist];\n  }\n\n  public asString(canon: Canonicalize): string {\n    const mod = canon.moveorder[this.base];\n    let tw = this.twist % mod;\n    while (tw + tw > mod) {\n      tw -= mod;\n    }\n    while (tw + tw <= -mod) {\n      tw += mod;\n    }\n    const nam = canon.movenames[this.base];\n    if (tw === 1) {\n      return nam;\n    } else if (tw === -1) {\n      return nam + \"'\";\n    } else if (tw > 0) {\n      return nam + tw;\n    } else if (tw < 0) {\n      return nam + -tw + \"'\";\n    } else {\n      throw new Error(\"Stringifying null move?\");\n    }\n  }\n}\n\n// represents puzzle move data and its commuting structure\nexport class Canonicalize {\n  public commutes: boolean[][] = [];\n  public moveorder: number[] = [];\n  public movenames: string[] = [];\n  public transforms: Transformation[][] = [];\n  public moveindex: { [key: string]: number } = {};\n  public baseMoveCount: number;\n  constructor(public def: KPuzzleDefinition) {\n    const basemoves = def.moves;\n    const id = IdentityTransformation(def);\n    for (const mv1 in basemoves) {\n      this.moveindex[mv1] = this.movenames.length;\n      this.movenames.push(mv1);\n      this.transforms.push([id, basemoves[mv1]]);\n    }\n    this.baseMoveCount = this.movenames.length;\n    for (let i = 0; i < this.baseMoveCount; i++) {\n      this.commutes.push([]);\n      const t1 = this.transforms[i][1];\n      for (let j = 0; j < this.baseMoveCount; j++) {\n        const t2 = this.transforms[j][1];\n        const ab = Combine(def, t1, t2);\n        const ba = Combine(def, t2, t1);\n        this.commutes[i][j] = EquivalentTransformations(def, ab, ba);\n      }\n    }\n    for (let i = 0; i < this.baseMoveCount; i++) {\n      const t1 = this.transforms[i][1];\n      let ct = t1;\n      let order = 1;\n      for (let mult = 2; !EquivalentTransformations(def, id, ct); mult++) {\n        order++;\n        ct = Combine(def, ct, t1);\n        this.transforms[i].push(ct);\n      }\n      this.moveorder[i] = order;\n    }\n  }\n\n  public blockMoveToInternalMove(mv: BlockMove): InternalMove {\n    const basemove = modifiedBlockMove(mv, { amount: 1 });\n    const s = blockMoveToString(basemove);\n    if (!(s in this.def.moves)) {\n      throw new Error(\"! move \" + s + \" not in def.\");\n    }\n    const ind = this.moveindex[s];\n    const mod = this.moveorder[ind];\n    let tw = mv.amount % mod;\n    if (tw < 0) {\n      tw = (tw + mod) % mod;\n    }\n    return new InternalMove(ind, tw);\n  }\n\n  // Sequence must be simple sequence of block moves\n  // this one does not attempt to merge.\n  public sequenceToSearchSequence(\n    s: Sequence,\n    tr?: Transformation,\n  ): SearchSequence {\n    const ss = new SearchSequence(this, tr);\n    for (const mv of s.nestedUnits) {\n      ss.appendOneMove(this.blockMoveToInternalMove(mv as BlockMove));\n    }\n    return ss;\n  }\n\n  // Sequence to simple sequence, with merging.\n  public mergeSequenceToSearchSequence(\n    s: Sequence,\n    tr?: Transformation,\n  ): SearchSequence {\n    const ss = new SearchSequence(this, tr);\n    for (const mv of s.nestedUnits) {\n      ss.mergeOneMove(this.blockMoveToInternalMove(mv as BlockMove));\n    }\n    return ss;\n  }\n}\n// represents a single sequence we are working on\n// this can be a search sequence, or it can be a\n// \"cooked\" sequence that we want to use efficiently.\nexport class SearchSequence {\n  public moveseq: InternalMove[] = [];\n  public trans: Transformation;\n  constructor(private canon: Canonicalize, tr?: Transformation) {\n    if (tr) {\n      this.trans = tr;\n    } else {\n      this.trans = IdentityTransformation(canon.def);\n    }\n  }\n\n  /*\n   *  A common use for search sequences is to extend them, but\n   *  sometimes we shouldn't modify the returned one.  This\n   *  method gives you a copy you can do whatever you want with.\n   */\n  public clone(): SearchSequence {\n    const r = new SearchSequence(this.canon, this.trans);\n    r.moveseq = [...this.moveseq];\n    return r;\n  }\n\n  // returns 1 if the move is added, 0 if it is merged, -1 if it cancels a move\n  public mergeOneMove(mv: InternalMove): number {\n    const r = this.onlyMergeOneMove(mv);\n    this.trans = Combine(\n      this.canon.def,\n      this.trans,\n      mv.getTransformation(this.canon),\n    );\n    return r;\n  }\n\n  // does not do merge work; just slaps the new move on\n  public appendOneMove(mv: InternalMove): number {\n    this.moveseq.push(mv);\n    this.trans = Combine(\n      this.canon.def,\n      this.trans,\n      mv.getTransformation(this.canon),\n    );\n    return 1;\n  }\n\n  // pop a move off.\n  public popMove(): number {\n    const mv = this.moveseq.pop();\n    if (!mv) {\n      throw new Error(\"Can't pop an empty sequence\");\n    }\n    this.trans = Combine(\n      this.canon.def,\n      this.trans,\n      this.canon.transforms[mv.base][this.canon.moveorder[mv.base] - mv.twist],\n    );\n    return 1;\n  }\n\n  // do one more twist of the last move\n  public oneMoreTwist(): number {\n    const lastmv = this.moveseq[this.moveseq.length - 1];\n    this.trans = Combine(\n      this.canon.def,\n      this.trans,\n      this.canon.transforms[lastmv.base][1],\n    );\n    this.moveseq[this.moveseq.length - 1] = new InternalMove(\n      lastmv.base,\n      lastmv.twist + 1,\n    );\n    return 0;\n  }\n\n  private onlyMergeOneMove(mv: InternalMove): number {\n    let j = this.moveseq.length - 1;\n    while (j >= 0) {\n      if (mv.base === this.moveseq[j].base) {\n        const mo = this.canon.moveorder[mv.base];\n        let twist = (mv.twist + this.moveseq[j].twist) % mo;\n        if (twist < 0) {\n          twist = (twist + mo) % mo;\n        }\n        if (twist === 0) {\n          // this splice should not be a performance problem because the\n          // typical number of following moves should be small\n          this.moveseq.splice(j, 1);\n          return -1;\n        } else {\n          this.moveseq[j] = new InternalMove(mv.base, twist);\n          return 0;\n        }\n      } else if (this.canon.commutes[mv.base][this.moveseq[j].base]) {\n        j--;\n      } else {\n        break;\n      }\n    }\n    this.moveseq.push(mv);\n    return 1;\n  }\n\n  // returns the length of the merged sequence.\n  public mergeSequence(seq: SearchSequence): number {\n    let r = this.moveseq.length;\n    for (let i = 0; i < seq.moveseq.length; i++) {\n      const mv = seq.moveseq[i];\n      const d = this.onlyMergeOneMove(mv);\n      r += d;\n    }\n    this.trans = Combine(this.canon.def, this.trans, seq.trans);\n    return r;\n  }\n\n  public getSequenceAsString(): string {\n    const r: string[] = [];\n    for (const mv of this.moveseq) {\n      r.push(mv.asString(this.canon));\n    }\n    return r.join(\" \");\n  }\n}\n/*\n *   Iterate through canonical sequences by length.  This version\n *   uses generators.\n */\nexport class CanonicalSequenceIterator {\n  public ss: SearchSequence;\n  public targetLength: number;\n  constructor(public canon: Canonicalize, state?: Transformation) {\n    this.ss = new SearchSequence(canon, state);\n    this.targetLength = 0;\n  }\n\n  public nextState(base: number, canonstate: number[]): null | number[] {\n    const newstate: number[] = [];\n    for (const prevbase of canonstate) {\n      if (prevbase === base) {\n        return null;\n      } else if (!this.canon.commutes[prevbase][base]) {\n        // don't do anything in this case\n      } else if (base < prevbase) {\n        return null;\n      } else {\n        newstate.push(prevbase);\n      }\n    }\n    return newstate;\n  }\n\n  public *genSequence(\n    togo: number,\n    canonstate: number[],\n  ): Generator<SearchSequence, null, void> {\n    if (togo === 0) {\n      yield this.ss;\n    } else {\n      for (let base = 0; base < this.canon.baseMoveCount; base++) {\n        const newstate = this.nextState(base, canonstate);\n        if (newstate) {\n          newstate.push(base);\n          for (let tw = 1; tw < this.canon.moveorder[base]; tw++) {\n            this.ss.appendOneMove(new InternalMove(base, tw));\n            yield* this.genSequence(togo - 1, newstate);\n            this.ss.popMove();\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  public *generator(): Generator<SearchSequence, SearchSequence, void> {\n    for (let d = 0; ; d++) {\n      yield* this.genSequence(d, []);\n    }\n  }\n\n  public *genSequenceTree(\n    canonstate: number[],\n  ): Generator<SearchSequence, null, number> {\n    const r = yield this.ss;\n    if (r > 0) {\n      return null;\n    }\n    for (let base = 0; base < this.canon.baseMoveCount; base++) {\n      const newstate = this.nextState(base, canonstate);\n      if (newstate) {\n        newstate.push(base);\n        for (let tw = 1; tw < this.canon.moveorder[base]; tw++) {\n          this.ss.appendOneMove(new InternalMove(base, tw));\n          yield* this.genSequenceTree(newstate);\n          this.ss.popMove();\n        }\n      }\n    }\n    return null;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
