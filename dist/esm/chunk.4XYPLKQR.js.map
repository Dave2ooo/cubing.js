{
  "version": 3,
  "sources": ["../../src/kpuzzle/svg.ts", "../../src/kpuzzle/transformations.ts"],
  "sourcesContent": ["import { KPuzzleDefinition, Transformation } from \"./definition_types\";\nimport { KPuzzle } from \"./kpuzzle\";\n\nconst xmlns = \"http://www.w3.org/2000/svg\";\n\n// Unique ID mechanism to keep SVG gradient element IDs unique. TODO: Is there\n// something more performant, and that can't be broken by other elements of the\n// page? (And also doesn't break if this library is run in parallel.)\nlet svgCounter = 0;\nfunction nextSVGID(): string {\n  svgCounter += 1;\n  return \"svg\" + svgCounter.toString();\n}\n\nexport class SVG {\n  public element: HTMLElement;\n  public gradientDefs: SVGDefsElement;\n  private originalColors: { [type: string]: string } = {};\n  private gradients: { [type: string]: SVGGradientElement } = {};\n  private svgID: string;\n  constructor(public kPuzzleDefinition: KPuzzleDefinition) {\n    if (!kPuzzleDefinition.svg) {\n      throw new Error(\n        `No SVG definition for puzzle type: ${kPuzzleDefinition.name}`,\n      );\n    }\n\n    this.svgID = nextSVGID();\n\n    this.element = document.createElement(\"div\");\n    this.element.classList.add(\"svg-wrapper\");\n    // TODO: Sanitization.\n    this.element.innerHTML = kPuzzleDefinition.svg;\n\n    const svgElem = this.element.querySelector(\"svg\");\n    if (!svgElem) {\n      throw new Error(\"Could not get SVG element\");\n    }\n    if (xmlns !== svgElem.namespaceURI) {\n      throw new Error(\"Unexpected XML namespace\");\n    }\n    svgElem.style.maxWidth = \"100%\";\n    svgElem.style.maxHeight = \"100%\";\n    this.gradientDefs = document.createElementNS(\n      xmlns,\n      \"defs\",\n    ) as SVGDefsElement;\n    svgElem.insertBefore(this.gradientDefs, svgElem.firstChild);\n\n    for (const orbitName in kPuzzleDefinition.orbits) {\n      const orbitDefinition = kPuzzleDefinition.orbits[orbitName];\n\n      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n        for (\n          let orientation = 0;\n          orientation < orbitDefinition.orientations;\n          orientation++\n        ) {\n          const id = this.elementID(orbitName, idx, orientation);\n          const elem = this.elementByID(id);\n          const originalColor = elem.style.fill as string;\n          this.originalColors[id] = originalColor;\n          this.gradients[id] = this.newGradient(id, originalColor);\n          this.gradientDefs.appendChild(this.gradients[id]);\n          elem.setAttribute(\"style\", `fill: url(#grad-${this.svgID}-${id})`);\n        }\n      }\n    }\n  }\n\n  public drawKPuzzle(\n    kpuzzle: KPuzzle,\n    nextState?: Transformation,\n    fraction?: number,\n  ): void {\n    this.draw(kpuzzle.definition, kpuzzle.state, nextState, fraction);\n  }\n\n  // TODO: save definition in the constructor?\n  public draw(\n    definition: KPuzzleDefinition,\n    state: Transformation,\n    nextState?: Transformation,\n    fraction?: number,\n  ): void {\n    for (const orbitName in definition.orbits) {\n      const orbitDefinition = definition.orbits[orbitName];\n\n      const curOrbitState = state[orbitName];\n      const nextOrbitState = nextState\n        ? (nextState as Transformation)[orbitName]\n        : null;\n      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n        for (\n          let orientation = 0;\n          orientation < orbitDefinition.orientations;\n          orientation++\n        ) {\n          const id = this.elementID(orbitName, idx, orientation);\n          const fromCur = this.elementID(\n            orbitName,\n            curOrbitState.permutation[idx],\n            (orbitDefinition.orientations -\n              curOrbitState.orientation[idx] +\n              orientation) %\n              orbitDefinition.orientations,\n          );\n          let singleColor = false;\n          if (nextOrbitState) {\n            const fromNext = this.elementID(\n              orbitName,\n              nextOrbitState.permutation[idx],\n              (orbitDefinition.orientations -\n                nextOrbitState.orientation[idx] +\n                orientation) %\n                orbitDefinition.orientations,\n            );\n            if (fromCur === fromNext) {\n              singleColor = true; // TODO: Avoid redundant work during move.\n            }\n            fraction = fraction || 0; // TODO Use the type system to tie this to nextState?\n            const easedBackwardsPercent =\n              100 * (1 - fraction * fraction * (2 - fraction * fraction)); // TODO: Move easing up the stack.\n            this.gradients[id].children[0].setAttribute(\n              \"stop-color\",\n              this.originalColors[fromCur],\n            );\n            this.gradients[id].children[1].setAttribute(\n              \"stop-color\",\n              this.originalColors[fromCur],\n            );\n            this.gradients[id].children[1].setAttribute(\n              \"offset\",\n              `${Math.max(easedBackwardsPercent - 5, 0)}%`,\n            );\n            this.gradients[id].children[2].setAttribute(\n              \"offset\",\n              `${Math.max(easedBackwardsPercent - 5, 0)}%`,\n            );\n            this.gradients[id].children[3].setAttribute(\n              \"offset\",\n              `${easedBackwardsPercent}%`,\n            );\n            this.gradients[id].children[4].setAttribute(\n              \"offset\",\n              `${easedBackwardsPercent}%`,\n            );\n            this.gradients[id].children[4].setAttribute(\n              \"stop-color\",\n              this.originalColors[fromNext],\n            );\n            this.gradients[id].children[5].setAttribute(\n              \"stop-color\",\n              this.originalColors[fromNext],\n            );\n          } else {\n            singleColor = true; // TODO: Avoid redundant work during move.\n          }\n          if (singleColor) {\n            this.gradients[id].children[0].setAttribute(\n              \"stop-color\",\n              this.originalColors[fromCur],\n            );\n            this.gradients[id].children[1].setAttribute(\n              \"stop-color\",\n              this.originalColors[fromCur],\n            );\n            this.gradients[id].children[1].setAttribute(\"offset\", `100%`);\n            this.gradients[id].children[2].setAttribute(\"offset\", `100%`);\n            this.gradients[id].children[3].setAttribute(\"offset\", `100%`);\n            this.gradients[id].children[4].setAttribute(\"offset\", `100%`);\n          }\n          // this.gradients[id]\n          // this.elementByID(id).style.fill = this.originalColors[from];\n        }\n      }\n    }\n  }\n\n  private newGradient(id: string, originalColor: string): SVGGradientElement {\n    const grad = document.createElementNS(\n      xmlns,\n      \"radialGradient\",\n    ) as SVGGradientElement;\n    grad.setAttribute(\"id\", `grad-${this.svgID}-${id}`);\n    grad.setAttribute(\"r\", `70.7107%`); // TODO: Adapt to puzzle.\n    const stopDefs = [\n      { offset: 0, color: originalColor },\n      { offset: 0, color: originalColor },\n      { offset: 0, color: \"black\" },\n      { offset: 0, color: \"black\" },\n      { offset: 0, color: originalColor },\n      { offset: 100, color: originalColor },\n    ];\n    for (const stopDef of stopDefs) {\n      const stop = document.createElementNS(xmlns, \"stop\") as SVGStopElement;\n      stop.setAttribute(\"offset\", `${stopDef.offset}%`);\n      stop.setAttribute(\"stop-color\", stopDef.color);\n      stop.setAttribute(\"stop-opacity\", \"1\");\n      grad.appendChild(stop);\n    }\n    return grad;\n  }\n\n  private elementID(\n    orbitName: string,\n    idx: number,\n    orientation: number,\n  ): string {\n    return orbitName + \"-l\" + idx + \"-o\" + orientation;\n  }\n\n  private elementByID(id: string): HTMLElement {\n    // TODO: Use classes and scope selector to SVG element.\n    return this.element.querySelector(\"#\" + id) as HTMLElement;\n  }\n}\n", "import { KPuzzleDefinition, Transformation } from \"./definition_types\";\n\nexport function Combine(\n  def: KPuzzleDefinition,\n  t1: Transformation,\n  t2: Transformation,\n): Transformation {\n  const newTrans: Transformation = {} as Transformation;\n  for (const orbitName in def.orbits) {\n    const oDef = def.orbits[orbitName];\n    const o1 = t1[orbitName];\n    const o2 = t2[orbitName];\n    const newPerm = new Array(oDef.numPieces);\n    const newOri = new Array(oDef.numPieces);\n    for (let idx = 0; idx < oDef.numPieces; idx++) {\n      newOri[idx] =\n        (o1.orientation[o2.permutation[idx]] + o2.orientation[idx]) %\n        oDef.orientations;\n      newPerm[idx] = o1.permutation[o2.permutation[idx]];\n    }\n    newTrans[orbitName] = { permutation: newPerm, orientation: newOri };\n  }\n  return newTrans;\n}\n\nexport function Multiply(\n  def: KPuzzleDefinition,\n  t: Transformation,\n  amount: number,\n): Transformation {\n  if (amount < 0) {\n    return Multiply(def, Invert(def, t), -amount);\n  }\n  if (amount === 0) {\n    return IdentityTransformation(def);\n  }\n  if (amount === 1) {\n    return t;\n  }\n  const halfish = Multiply(def, t, Math.floor(amount / 2));\n  const twiceHalfish = Combine(def, halfish, halfish);\n  if (amount % 2 === 0) {\n    return twiceHalfish;\n  } else {\n    return Combine(def, t, twiceHalfish);\n  }\n}\nexport function IdentityTransformation(\n  definition: KPuzzleDefinition,\n): Transformation {\n  const transformation = {} as Transformation;\n  for (const orbitName in definition.orbits) {\n    const orbitDefinition = definition.orbits[orbitName];\n    const newPermutation = new Array(orbitDefinition.numPieces);\n    const newOrientation = new Array(orbitDefinition.numPieces);\n    for (let i = 0; i < orbitDefinition.numPieces; i++) {\n      newPermutation[i] = i;\n      newOrientation[i] = 0;\n    }\n    const orbitTransformation = {\n      permutation: newPermutation,\n      orientation: newOrientation,\n    };\n    transformation[orbitName] = orbitTransformation;\n  }\n  return transformation;\n}\n\nexport function Invert(\n  def: KPuzzleDefinition,\n  t: Transformation,\n): Transformation {\n  const newTrans: Transformation = {} as Transformation;\n  for (const orbitName in def.orbits) {\n    const oDef = def.orbits[orbitName];\n    const o = t[orbitName];\n    const newPerm = new Array(oDef.numPieces);\n    const newOri = new Array(oDef.numPieces);\n    for (let idx = 0; idx < oDef.numPieces; idx++) {\n      const fromIdx = o.permutation[idx] as number;\n      newPerm[fromIdx] = idx;\n      newOri[fromIdx] =\n        (oDef.orientations - o.orientation[idx] + oDef.orientations) %\n        oDef.orientations;\n    }\n    newTrans[orbitName] = { permutation: newPerm, orientation: newOri };\n  }\n  return newTrans;\n}\n\nfunction gcd(a: number, b: number): number {\n  if (b) {\n    return gcd(b, a % b);\n  }\n  return a;\n}\n/* calculate the order of a particular transformation. */\nexport function Order(def: KPuzzleDefinition, t: Transformation): number {\n  let r: number = 1;\n  for (const orbitName in def.orbits) {\n    const oDef = def.orbits[orbitName];\n    const o = t[orbitName];\n    const d = new Array(oDef.numPieces);\n    for (let idx = 0; idx < oDef.numPieces; idx++) {\n      if (!d[idx]) {\n        let w = idx;\n        let om = 0;\n        let pm = 0;\n        for (;;) {\n          d[w] = true;\n          om = om + o.orientation[w];\n          pm = pm + 1;\n          w = o.permutation[w];\n          if (w === idx) {\n            break;\n          }\n        }\n        if (om !== 0) {\n          pm = (pm * oDef.orientations) / gcd(oDef.orientations, om);\n        }\n        r = (r * pm) / gcd(r, pm);\n      }\n    }\n  }\n  return r;\n}\n\nexport function EquivalentTransformations(\n  def: KPuzzleDefinition,\n  t1: Transformation,\n  t2: Transformation,\n): boolean {\n  for (const orbitName in def.orbits) {\n    const oDef = def.orbits[orbitName];\n    const o1 = t1[orbitName];\n    const o2 = t2[orbitName];\n    for (let idx = 0; idx < oDef.numPieces; idx++) {\n      if (o1.orientation[idx] !== o2.orientation[idx]) {\n        return false;\n      }\n      if (o1.permutation[idx] !== o2.permutation[idx]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nexport function EquivalentStates(\n  def: KPuzzleDefinition,\n  t1: Transformation,\n  t2: Transformation,\n): boolean {\n  // Turn transformations into states.\n  // This accounts for indistinguishable pieces.\n  return EquivalentTransformations(\n    def,\n    Combine(def, def.startPieces, t1),\n    Combine(def, def.startPieces, t2),\n  );\n}\n"],
  "mappings": "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",
  "names": []
}
