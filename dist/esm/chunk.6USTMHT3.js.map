{
  "version": 3,
  "sources": ["../../src/protocol/binary/orbit-indexing.ts", "../../src/protocol/binary/binary3x3x3.ts", "../../src/protocol/binary/hex.ts"],
  "sourcesContent": ["export function identityPermutation(numElems: number): number[] {\n  const arr = new Array(numElems);\n  for (let i = 0; i < numElems; i++) {\n    arr[i] = i;\n  }\n  return arr;\n}\n\n// Inclusive start, exclusive end (similar to `Array.prototype.slice`)\nexport function orientationsToMask(\n  radix: number,\n  orientations: number[],\n): number {\n  let val = 0;\n  for (const orientation of orientations) {\n    val *= radix;\n    val += orientation;\n  }\n  return val;\n}\n\n// Inclusive start, exclusive end (similar to `Array.prototype.slice`)\nexport function maskToOrientations(\n  radix: number,\n  numElems: number,\n  mask: number,\n): number[] {\n  const arr = [];\n  while (mask > 0) {\n    arr.push(mask % radix);\n    mask = Math.floor(mask / radix);\n  }\n  return new Array(numElems - arr.length).fill(0).concat(arr.reverse());\n}\n\n// From https://www.jaapsch.net/puzzles/compindx.htm#perm\nexport function permutationToLex(permutation: number[]): number {\n  const n = permutation.length;\n  let lexicographicIdx = 0;\n  for (let i = 0; i < n - 1; i++) {\n    lexicographicIdx = lexicographicIdx * (n - i);\n    for (let j = i + 1; j < n; j++) {\n      if (permutation[i] > permutation[j]) {\n        lexicographicIdx += 1;\n      }\n    }\n  }\n  return lexicographicIdx;\n}\n\n// From https://www.jaapsch.net/puzzles/compindx.htm#perm\nexport function lexToPermutation(\n  numPieces: number,\n  lexicographicIdx: number,\n): number[] {\n  const permutation: number[] = new Array(numPieces);\n  permutation[numPieces - 1] = 0;\n  for (let i = numPieces - 2; i >= 0; i--) {\n    permutation[i] = lexicographicIdx % (numPieces - i);\n    lexicographicIdx = Math.floor(lexicographicIdx / (numPieces - i));\n    for (let j = i + 1; j < numPieces; j++) {\n      if (permutation[j] >= permutation[i]) {\n        permutation[j] = permutation[j] + 1;\n      }\n    }\n  }\n  return permutation;\n}\n", "import { parse, Sequence } from \"../../alg\";\nimport {\n  Combine,\n  Invert,\n  KPuzzle,\n  Puzzles,\n  Transformation,\n} from \"../../kpuzzle\";\nimport {\n  identityPermutation,\n  lexToPermutation,\n  maskToOrientations,\n  orientationsToMask,\n  permutationToLex,\n} from \"./orbit-indexing\";\n\ntype Binary3x3x3State = ArrayBuffer;\n\n// Bit lengths of the encoded components, in order.\nconst BIT_LENGTHS = [29, 12, 16, 13, 3, 2, 1, 12];\n\n// These fields are sorted by the order in which they appear in the binary format.\nexport interface Binary3x3x3Components {\n  epLex: number; // 29 bits, edge permutation\n  eoMask: number; // 12 bits, edge orientation\n  cpLex: number; // 16 bits, corner permutation\n  coMask: number; // 13 bits, corner orientation\n  poIdxU: number; // 3 bits, puzzle orientation (U face)\n  poIdxL: number; // 2 bits, puzzle orientation (L face)\n  moSupport: number; // 1 bit, center orientation support\n  moMask: number; // 12 bits, center orientation\n}\n\n// There are various clever ways to do this, but this is simple and efficient.\nfunction arraySum(arr: number[]): number {\n  let total = 0;\n  for (const entry of arr) {\n    total += entry;\n  }\n  return total;\n}\n\n// Due to limitations in JS bit operations, this is unsafe if any of the bit lengths span across the contents of more than 4 bytes.\n// - Safe: [8, 32]\n// - Unsafe: [4, 32, 4]\n// - Unsafe: [40, 4]\nfunction splitBinary(bitLengths: number[], buffy: ArrayBuffer): number[] {\n  const u8buffy = new Uint8Array(buffy);\n  let at = 0;\n  let bits = 0;\n  let accum = 0;\n  const values: number[] = [];\n  for (const bitLength of bitLengths) {\n    while (bits < bitLength) {\n      accum = (accum << 8) | u8buffy[at++];\n      bits += 8;\n    }\n    values.push((accum >> (bits - bitLength)) & ((1 << bitLength) - 1));\n    bits -= bitLength;\n  }\n  return values;\n}\n\n// See above for safety notes.\nfunction concatBinary(bitLengths: number[], values: number[]): ArrayBuffer {\n  const buffy = new Uint8Array(Math.ceil(arraySum(bitLengths) / 8));\n  let at = 0;\n  let bits = 0;\n  let accum = 0;\n  for (let i = 0; i < bitLengths.length; i++) {\n    accum = (accum << bitLengths[i]) | values[i];\n    bits += bitLengths[i];\n    while (bits >= 8) {\n      buffy[at++] = accum >> (bits - 8);\n      bits -= 8;\n    }\n  }\n  if (bits > 0) {\n    buffy[at++] = accum << (8 - bits);\n  }\n  return buffy;\n}\n\nfunction puzzleOrientationIdx(state: Transformation): [number, number] {\n  const idxU = state[\"CENTERS\"].permutation[0];\n  const idxD = state[\"CENTERS\"].permutation[5];\n  const unadjustedIdxL = state[\"CENTERS\"].permutation[1];\n  let idxL = unadjustedIdxL;\n  if (idxU < unadjustedIdxL) {\n    idxL--;\n  }\n  if (idxD < unadjustedIdxL) {\n    idxL--;\n  }\n  return [idxU, idxL];\n}\n\nconst puzzleOrientationCache: Transformation[][] = new Array(6)\n  .fill(0)\n  .map(() => {\n    return new Array(6);\n  });\n\n// We use a new block to avoid keeping a reference to temporary vars.\n{\n  const orientationKpuzzle = new KPuzzle(Puzzles[\"3x3x3\"]);\n  const uAlgs: Sequence[] = [\"\", \"z\", \"x\", \"z'\", \"x'\", \"x2\"].map((s) =>\n    parse(s),\n  );\n  const yAlg = parse(\"y\");\n  for (const uAlg of uAlgs) {\n    orientationKpuzzle.reset();\n    orientationKpuzzle.applyAlg(uAlg);\n    for (let i = 0; i < 4; i++) {\n      orientationKpuzzle.applyAlg(yAlg);\n      const [idxU, idxL] = puzzleOrientationIdx(orientationKpuzzle.state);\n      puzzleOrientationCache[idxU][idxL] = Invert(\n        Puzzles[\"3x3x3\"],\n        orientationKpuzzle.state,\n      );\n    }\n  }\n}\n\nfunction normalizePuzzleOrientation(s: Transformation): Transformation {\n  const [idxU, idxL] = puzzleOrientationIdx(s);\n  const orientationTransformation = puzzleOrientationCache[idxU][idxL];\n  return Combine(Puzzles[\"3x3x3\"], s, orientationTransformation);\n}\n\n// TODO: combine with `orientPuzzle`?\nfunction reorientPuzzle(\n  s: Transformation,\n  idxU: number,\n  idxL: number,\n): Transformation {\n  const orientationTransformation = Invert(\n    Puzzles[\"3x3x3\"],\n    puzzleOrientationCache[idxU][idxL],\n  );\n  return Combine(Puzzles[\"3x3x3\"], s, orientationTransformation);\n}\n// 0x111 (for idxU) means \"not supported\"\nfunction supportsPuzzleOrientation(components: Binary3x3x3Components): boolean {\n  return components.poIdxU !== 7;\n}\n\nexport function reid3x3x3ToBinaryComponents(\n  state: Transformation,\n): Binary3x3x3Components {\n  const normedState = normalizePuzzleOrientation(state);\n\n  const epLex = permutationToLex(normedState[\"EDGES\"].permutation);\n  const eoMask = orientationsToMask(2, normedState[\"EDGES\"].orientation);\n  const cpLex = permutationToLex(normedState[\"CORNERS\"].permutation);\n  const coMask = orientationsToMask(3, normedState[\"CORNERS\"].orientation);\n  const [poIdxU, poIdxL] = puzzleOrientationIdx(state);\n  const moSupport = 1; // Required for now.\n  const moMask = orientationsToMask(4, normedState[\"CENTERS\"].orientation);\n\n  return {\n    epLex,\n    eoMask,\n    cpLex,\n    coMask,\n    poIdxU,\n    poIdxL,\n    moSupport,\n    moMask,\n  };\n}\n\nexport function binaryComponentsToTwizzleBinary(\n  components: Binary3x3x3Components,\n): Binary3x3x3State {\n  const {\n    epLex,\n    eoMask,\n    cpLex,\n    coMask,\n    poIdxU,\n    poIdxL,\n    moSupport,\n    moMask,\n  } = components;\n\n  return concatBinary(BIT_LENGTHS, [\n    epLex,\n    eoMask,\n    cpLex,\n    coMask,\n    poIdxU,\n    poIdxL,\n    moSupport,\n    moMask,\n  ]);\n}\n\nexport function reid3x3x3ToTwizzleBinary(\n  state: Transformation,\n): Binary3x3x3State {\n  const components: Binary3x3x3Components = reid3x3x3ToBinaryComponents(state);\n  return binaryComponentsToTwizzleBinary(components);\n}\n\nexport function twizzleBinaryToBinaryComponents(\n  buffer: ArrayBuffer,\n): Binary3x3x3Components {\n  const [\n    epLex,\n    eoMask,\n    cpLex,\n    coMask,\n    poIdxU,\n    poIdxL,\n    moSupport,\n    moMask,\n  ] = splitBinary(BIT_LENGTHS, buffer);\n\n  return {\n    epLex,\n    eoMask,\n    cpLex,\n    coMask,\n    poIdxU,\n    poIdxL,\n    moSupport,\n    moMask,\n  };\n}\n\nexport function binaryComponentsToReid3x3x3(\n  components: Binary3x3x3Components,\n): Transformation {\n  if (components.moSupport !== 1) {\n    throw new Error(\"Must support center orientation.\");\n  }\n\n  const normedState = {\n    EDGES: {\n      permutation: lexToPermutation(12, components.epLex),\n      orientation: maskToOrientations(2, 12, components.eoMask),\n    },\n    CORNERS: {\n      permutation: lexToPermutation(8, components.cpLex),\n      orientation: maskToOrientations(3, 8, components.coMask),\n    },\n    CENTERS: {\n      permutation: identityPermutation(6),\n      orientation: maskToOrientations(4, 6, components.moMask),\n    },\n  };\n\n  if (!supportsPuzzleOrientation(components)) {\n    return normedState;\n  }\n\n  return reorientPuzzle(normedState, components.poIdxU, components.poIdxL);\n}\n\n// Returns a list of error string.\n// An empty list means validation success.\nfunction validateComponents(components: Binary3x3x3Components): string[] {\n  const errors = [];\n  if (components.epLex < 0 || components.epLex >= 479001600) {\n    errors.push(`epLex (${components.epLex}) out of range`);\n  }\n  if (components.cpLex < 0 || components.cpLex >= 40320) {\n    errors.push(`cpLex (${components.cpLex}) out of range`);\n  }\n  if (components.coMask < 0 || components.coMask >= 6561) {\n    errors.push(`coMask (${components.coMask}) out of range`);\n  }\n  if (components.poIdxU < 0 || components.poIdxU >= 6) {\n    // 0x111 (for idxU) means \"not supported\"\n    if (supportsPuzzleOrientation(components)) {\n      errors.push(`poIdxU (${components.poIdxU}) out of range`);\n    }\n  }\n  // The following cannot be (f decoded from binary properl) out of rangey.\n  if (components.eoMask < 0 || components.eoMask >= 4096) {\n    errors.push(`eoMask (${components.eoMask}) out of range`);\n  }\n  if (components.moMask < 0 || components.moMask >= 4096) {\n    errors.push(`moMask (${components.moMask}) out of range`);\n  }\n  if (components.poIdxL < 0 || components.poIdxL >= 4) {\n    errors.push(`poIdxL (${components.poIdxL}) out of range`);\n  }\n  if (components.moSupport < 0 || components.moSupport >= 2) {\n    errors.push(`moSupport (${components.moSupport}) out of range`);\n  }\n  return errors;\n}\n\nexport function twizzleBinaryToReid3x3x3(buffy: ArrayBuffer): Transformation {\n  const components = twizzleBinaryToBinaryComponents(buffy);\n  const errors = validateComponents(components);\n  if (errors.length !== 0) {\n    throw new Error(`Invalid binary state components: ${errors.join(\", \")}`);\n  }\n  return binaryComponentsToReid3x3x3(components);\n}\n", "export function bufferToSpacedHex(buffer: ArrayBuffer): string {\n  // buffer is an ArrayBuffer\n  return Array.prototype.map\n    .call(new Uint8Array(buffer), (x: number) =>\n      (\"00\" + x.toString(16)).slice(-2),\n    )\n    .join(\" \");\n}\n\nexport function spacedHexToBuffer(hex: string): Uint8Array {\n  return new Uint8Array(hex.split(\" \").map((c) => parseInt(c, 16)));\n}\n"],
  "mappings": "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",
  "names": []
}
