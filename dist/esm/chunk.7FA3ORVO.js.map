{
  "version": 3,
  "sources": ["../../src/alg/operation.ts", "../../src/alg/operation.ts"],
  "sourcesContent": ["import { BlockMove, Sequence } from \"./algorithm\";\n\nfunction canCoalesce(m1: BlockMove, m2: BlockMove): boolean {\n  return (\n    m1.family === m2.family &&\n    m1.innerLayer === m2.innerLayer &&\n    m1.outerLayer === m2.outerLayer\n  );\n}\n\ninterface BlockMoveModifications {\n  outerLayer?: number;\n  innerLayer?: number;\n  family?: string;\n  amount?: number;\n}\n\nexport function modifiedBlockMove(\n  original: BlockMove,\n  modifications: BlockMoveModifications,\n): BlockMove {\n  // TODO: use the nullish coalescing operator once it becomes available to us.\n  return new BlockMove(\n    modifications.outerLayer ?? original.outerLayer,\n    modifications.innerLayer ?? original.innerLayer,\n    modifications.family ?? original.family,\n    modifications.amount ?? original.amount,\n  );\n}\n\nexport function experimentalAppendBlockMove(\n  s: Sequence,\n  newMove: BlockMove,\n  coalesceLastMove: boolean = false,\n  mod: number = 0,\n): Sequence {\n  const oldNestedUnits = s.nestedUnits;\n  const oldLastMove = oldNestedUnits[\n    oldNestedUnits.length - 1\n  ] as BlockMove | null;\n  if (coalesceLastMove && oldLastMove && canCoalesce(oldLastMove, newMove)) {\n    const newNestedUnits = s.nestedUnits.slice(0, oldNestedUnits.length - 1);\n    let newAmount = oldLastMove.amount + newMove.amount;\n    if (mod > 1) {\n      newAmount = ((newAmount % mod) + mod) % mod;\n      if (newAmount * 2 > mod) {\n        newAmount -= mod;\n      }\n    }\n    if (newAmount !== 0) {\n      newNestedUnits.push(\n        modifiedBlockMove(oldLastMove, { amount: newAmount }),\n      );\n    }\n    return new Sequence(newNestedUnits);\n  } else {\n    return new Sequence([...oldNestedUnits, newMove]);\n  }\n}\n\n// This purposely takes sequences as individual arguments, instead of a lsit of sequences, because:\n//\n// 1. This matches Javascript's built-in `Array.concat()` functionality.\n// 2. It encourages avoiding lists of sequences (which might lead to coding mistakes).\n//\n// TODO: Now useful is it to coalesce at alg boundaries (rather than coalescing the whole result)?\n// Should that be a separate function, or should we change this to accept coalescing option arg like `experimentalAppendBlockMove()`?\nexport function experimentalConcatAlgs(...args: Sequence[]): Sequence {\n  return new Sequence(\n    Array.prototype.concat.apply(\n      [],\n      [...args].map((s) => s.nestedUnits),\n    ),\n  );\n}\n", "import { BlockMove, Sequence } from \"./algorithm\";\n\nfunction canCoalesce(m1: BlockMove, m2: BlockMove): boolean {\n  return (\n    m1.family === m2.family &&\n    m1.innerLayer === m2.innerLayer &&\n    m1.outerLayer === m2.outerLayer\n  );\n}\n\ninterface BlockMoveModifications {\n  outerLayer?: number;\n  innerLayer?: number;\n  family?: string;\n  amount?: number;\n}\n\nexport function modifiedBlockMove(\n  original: BlockMove,\n  modifications: BlockMoveModifications,\n): BlockMove {\n  // TODO: use the nullish coalescing operator once it becomes available to us.\n  return new BlockMove(\n    modifications.outerLayer ?? original.outerLayer,\n    modifications.innerLayer ?? original.innerLayer,\n    modifications.family ?? original.family,\n    modifications.amount ?? original.amount,\n  );\n}\n\nexport function experimentalAppendBlockMove(\n  s: Sequence,\n  newMove: BlockMove,\n  coalesceLastMove: boolean = false,\n  mod: number = 0,\n): Sequence {\n  const oldNestedUnits = s.nestedUnits;\n  const oldLastMove = oldNestedUnits[\n    oldNestedUnits.length - 1\n  ] as BlockMove | null;\n  if (coalesceLastMove && oldLastMove && canCoalesce(oldLastMove, newMove)) {\n    const newNestedUnits = s.nestedUnits.slice(0, oldNestedUnits.length - 1);\n    let newAmount = oldLastMove.amount + newMove.amount;\n    if (mod > 1) {\n      newAmount = ((newAmount % mod) + mod) % mod;\n      if (newAmount * 2 > mod) {\n        newAmount -= mod;\n      }\n    }\n    if (newAmount !== 0) {\n      newNestedUnits.push(\n        modifiedBlockMove(oldLastMove, { amount: newAmount }),\n      );\n    }\n    return new Sequence(newNestedUnits);\n  } else {\n    return new Sequence([...oldNestedUnits, newMove]);\n  }\n}\n\n// This purposely takes sequences as individual arguments, instead of a lsit of sequences, because:\n//\n// 1. This matches Javascript's built-in `Array.concat()` functionality.\n// 2. It encourages avoiding lists of sequences (which might lead to coding mistakes).\n//\n// TODO: Now useful is it to coalesce at alg boundaries (rather than coalescing the whole result)?\n// Should that be a separate function, or should we change this to accept coalescing option arg like `experimentalAppendBlockMove()`?\nexport function experimentalConcatAlgs(...args: Sequence[]): Sequence {\n  return new Sequence(\n    Array.prototype.concat.apply(\n      [],\n      [...args].map((s) => s.nestedUnits),\n    ),\n  );\n}\n"],
  "mappings": ";;;;;;;;AAEA,qBAAqB;AACnB,SACE,GAAG,WAAW,GAAG,UACjB,GAAG,eAAe,GAAG,cACrB,GAAG,eAAe,GAAG;AAAA;ACwBlB,qCACL,+BAE4B,aACd;AAEd,yBAAuB,EAAE;AACzB,sBAAoB,eAClB,eAAe,SAAS;AAE1B,MAAI,oBAAoB,eAAe,YAAY,aAAa;AAC9D,2BAAuB,EAAE,YAAY,MAAM,GAAG,eAAe,SAAS;AACtE,oBAAgB,YAAY,SAAS,QAAQ;AAC7C,QAAI,MAAM;AACR,kBAAc,aAAY,MAAO,OAAO;AACxC,UAAI,YAAY,IAAI;AAClB,qBAAa;AAAA;AAAA;AAGjB,QAAI,cAAc;AAChB,qBAAe,KACb,kBAAkB,aAAa,CAAE,QAAQ;AAAA;AAG7C,WAAO,IAAI,SAAS;AAAA;AAEpB,WAAO,IAAI,SAAS,CAAC,GAAG,gBAAgB;AAAA;AAAA;",
  "names": []
}
