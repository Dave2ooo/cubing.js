{
  "version": 3,
  "sources": ["../../src/twisty/dom/viewers/Twisty3DCanvas.ts", "../../src/twisty/animation/RenderScheduler.ts", "../../src/twisty/dom/element/node-custom-element-shims.ts", "../../src/twisty/dom/element/node-custom-element-shims.ts", "../../src/twisty/dom/element/ManagedCustomElement.ts", "../../src/twisty/dom/viewers/canvas.ts", "../../src/twisty/dom/viewers/Twisty3DCanvas.css.ts", "../../src/twisty/dom/viewers/vendor/OrbitControls.js", "../../src/twisty/dom/viewers/TwistyOrbitControls.ts", "../../src/vendor/node_modules/three/examples/jsm/libs/stats.module.js", "../../src/twisty/dom/viewers/Twisty3DCanvas.ts", "../../src/alg/traversal.ts", "../../app/twizzle/move-counter.ts", "../../src/twisty/3D/puzzles/Cube3D.ts", "../../src/twisty/animation/easing.ts", "../../src/twisty/dom/TwistyPlayerConfig.ts", "../../src/twisty/dom/element/ElementConfig.ts", "../../src/twisty/dom/element/ElementConfig.ts", "../../src/twisty/dom/element/ElementConfig.ts", "../../src/twisty/dom/element/ClassListManager.ts", "../../src/twisty/dom/viewers/TwistyViewerWrapper.css.ts", "../../src/twisty/dom/viewers/TwistyViewerWrapper.ts", "../../src/twisty/dom/TwistyPlayerConfig.ts", "../../src/twisty/3D/TAU.ts", "../../src/twisty/3D/puzzles/stickerings.ts", "../../src/twisty/3D/puzzles/Cube3D.ts", "../../src/twisty/3D/puzzles/PG3D.ts", "../../src/twisty/3D/puzzles/PG3D.ts", "../../src/twisty/3D/Twisty3DScene.ts", "../../src/twisty/3D/puzzles/KPuzzleWrapper.ts", "../../src/twisty/animation/alg/CursorTypes.ts", "../../src/twisty/animation/alg/CursorTypes.ts", "../../src/twisty/animation/alg/AlgDuration.ts", "../../src/twisty/animation/alg/AlgIndexer.ts", "../../src/twisty/animation/alg/TreeAlgIndexer.ts", "../../src/twisty/animation/alg/AlgCursor.ts", "../../src/twisty/animation/Timeline.ts", "../../src/twisty/dom/controls/buttons.css.ts", "../../src/twisty/dom/controls/buttons.ts", "../../src/twisty/dom/controls/TwistyScrubber.css.ts", "../../src/twisty/dom/controls/TwistyScrubber.ts", "../../src/twisty/dom/TwistyPlayer.css.ts", "../../src/twisty/dom/viewers/Twisty2DSVGView.css.ts", "../../src/twisty/dom/viewers/Twisty2DSVG.ts", "../../src/twisty/dom/TwistyPlayer.ts", "../../src/twisty/animation/alg/SimpleAlgIndexer.ts", "../../src/twisty/animation/stream/timeline-move-calculation-draft.ts"],
  "sourcesContent": ["import { PerspectiveCamera, Vector3, WebGLRenderer } from \"three\";\nimport { Twisty3DScene } from \"../../3D/Twisty3DScene\";\nimport { RenderScheduler } from \"../../animation/RenderScheduler\";\nimport { ManagedCustomElement } from \"../element/ManagedCustomElement\";\nimport { pixelRatio } from \"./canvas\";\nimport { twisty3DCanvasCSS } from \"./Twisty3DCanvas.css\";\nimport { TwistyOrbitControls } from \"./TwistyOrbitControls\";\nimport { TwistyViewerElement } from \"./TwistyViewerElement\";\nimport { customElementsShim } from \"../element/node-custom-element-shims\";\nimport Stats from \"../../../vendor/node_modules/three/examples/jsm/libs/stats.module\";\n\nlet SHOW_STATS = false;\n// Show render stats for newly contructed renderers.\nexport function experimentalShowRenderStats(show: boolean): void {\n  SHOW_STATS = show;\n}\n\nlet resizeObserverWarningShown = false;\n\nlet shareAllNewRenderers: boolean = false;\n\n// WARNING: The current shared renderer implementation is not every efficient.\n// Avoid using for players that are likely to have dimensions approaching 1 megapixel or higher.\n// TODO: use a dedicated renderer while fullscreen?\nexport function experimentalSetShareAllNewRenderers(share: boolean): void {\n  shareAllNewRenderers = share;\n}\n\nlet sharedRenderer: WebGLRenderer | null = null;\n\nfunction newRenderer(): WebGLRenderer {\n  return new WebGLRenderer({\n    antialias: true,\n    alpha: true, // TODO\n  });\n}\n\nfunction newSharedRenderer(): WebGLRenderer {\n  return sharedRenderer ?? (sharedRenderer = newRenderer());\n}\n\n// <twisty-3d-canvas>\nexport class Twisty3DCanvas\n  extends ManagedCustomElement\n  implements TwistyViewerElement {\n  private scene: Twisty3DScene;\n  public canvas: HTMLCanvasElement;\n  public camera: PerspectiveCamera;\n  private legacyExperimentalShift: number = 0;\n  private orbitControls: TwistyOrbitControls;\n  private scheduler = new RenderScheduler(this.render.bind(this));\n  private resizePending: boolean = false;\n\n  private renderer: WebGLRenderer; // TODO: share renderers across elements? (issue: renderers are not designed to be constantly resized?)\n  private rendererIsShared: boolean;\n  private canvas2DContext: CanvasRenderingContext2D;\n\n  private stats: Stats | null = null;\n\n  // TODO: Are there any render duration performance concerns with removing this?\n  #invisible: boolean = false;\n  constructor(\n    scene?: Twisty3DScene,\n    options: { cameraPosition?: Vector3; negateCameraPosition?: boolean } = {},\n  ) {\n    super();\n    this.addCSS(twisty3DCanvasCSS);\n\n    this.scene = scene!;\n    this.scene.addRenderTarget(this);\n    if (SHOW_STATS) {\n      this.stats = Stats();\n      this.stats.dom.style.position = \"absolute\";\n      this.addElement(this.stats.dom);\n    }\n\n    // We rely on the resize logic to handle renderer dimensions.\n    this.rendererIsShared = shareAllNewRenderers;\n    this.renderer = this.rendererIsShared ? newSharedRenderer() : newRenderer();\n    this.canvas = this.rendererIsShared\n      ? document.createElement(\"canvas\")\n      : this.renderer.domElement;\n    this.canvas2DContext = this.canvas.getContext(\"2d\")!; // TODO: avoid saving unneeded?\n    this.addElement(this.canvas);\n\n    this.camera = new PerspectiveCamera(\n      20,\n      1, // We rely on the resize logic to handle this.\n      0.1,\n      1000,\n    );\n    this.camera.position.copy(options.cameraPosition ?? new Vector3(2, 4, 4));\n    if (options.negateCameraPosition) {\n      this.camera.position.multiplyScalar(-1);\n    }\n    this.camera.lookAt(new Vector3(0, 0, 0)); // TODO: Handle with `negateCameraPosition`\n    this.orbitControls = new TwistyOrbitControls(\n      this.camera,\n      this.canvas,\n      this.scheduleRender.bind(this),\n    );\n\n    // TODO: Remove this when enough Safari users have `ResizeObserver`.\n    if (window.ResizeObserver) {\n      const observer = new window.ResizeObserver(this.onResize.bind(this));\n      observer.observe(this.contentWrapper);\n    } else {\n      this.scheduleRender();\n      if (!resizeObserverWarningShown) {\n        console.warn(\n          \"You are using an older browser that does not support `ResizeObserver`. Displayed puzzles will not be rescaled.\",\n        );\n        resizeObserverWarningShown = true;\n      }\n    }\n  }\n\n  public setMirror(partner: Twisty3DCanvas): void {\n    this.orbitControls.setMirror(partner.orbitControls);\n    partner.orbitControls.setMirror(this.orbitControls);\n  }\n\n  protected connectedCallback(): void {\n    // Resize as soon as we're in the DOM, to avoid a flash of incorrectly sized content.\n    this.resize();\n    this.render();\n  }\n\n  scheduleRender(): void {\n    this.scheduler.requestAnimFrame();\n  }\n\n  // If the current size/state is incorrect, it may be preferable to hide it\n  // briefly, rather than flashing an incorrect version for one frame.\n  makeInvisibleUntilRender(): void {\n    this.contentWrapper.classList.add(\"invisible\");\n    this.#invisible = true;\n  }\n\n  private render(): void {\n    // Cancel any scheduled frame, since we're rendering right now.\n    // We don't need to re-render until something schedules again.\n    this.stats?.begin();\n    this.scheduler.cancelAnimFrame();\n    if (this.resizePending) {\n      this.resize();\n    }\n    this.orbitControls.updateAndSchedule();\n\n    if (this.rendererIsShared) {\n      this.renderer.setSize(this.canvas.width, this.canvas.height, false);\n      this.canvas2DContext.clearRect(\n        0,\n        0,\n        this.canvas.width,\n        this.canvas.height,\n      );\n    }\n    this.renderer.render(this.scene, this.camera);\n    if (this.rendererIsShared) {\n      this.canvas2DContext.drawImage(this.renderer.domElement, 0, 0);\n    }\n\n    if (this.#invisible) {\n      this.contentWrapper.classList.remove(\"invisible\");\n    }\n    this.stats?.end();\n  }\n\n  private onResize(): void {\n    this.resizePending = true;\n    this.scheduleRender();\n  }\n\n  private resize(): void {\n    this.resizePending = false;\n\n    const w = this.contentWrapper.clientWidth;\n    const h = this.contentWrapper.clientHeight;\n    let off = 0;\n    if (this.legacyExperimentalShift > 0) {\n      off = Math.max(0, Math.floor((w - h) * 0.5));\n    } else if (this.legacyExperimentalShift < 0) {\n      off = -Math.max(0, Math.floor((w - h) * 0.5));\n    }\n    let yoff = 0;\n    let excess = 0;\n    if (h > w) {\n      excess = h - w;\n      yoff = -Math.floor(0.5 * excess);\n    }\n    this.camera.aspect = w / h;\n    this.camera.setViewOffset(w, h - excess, off, yoff, w, h);\n    this.camera.updateProjectionMatrix(); // TODO\n\n    if (this.rendererIsShared) {\n      this.canvas.width = w * pixelRatio();\n      this.canvas.height = h * pixelRatio();\n      this.canvas.style.width = w.toString();\n      this.canvas.style.height = w.toString();\n    } else {\n      this.renderer.setPixelRatio(pixelRatio());\n      this.renderer.setSize(w, h, true);\n    }\n\n    this.scheduleRender();\n  }\n\n  // Square crop is useful for rending icons.\n  renderToDataURL(options: { squareCrop?: boolean } = {}): string {\n    // We don't preserve the drawing buffer, so we have to render again and then immediately read the canvas data.\n    // https://stackoverflow.com/a/30647502\n    this.render();\n\n    // TODO: can we assume that a central crop is similar enough to how a square canvas render would loook?\n    if (!options.squareCrop || this.canvas.width === this.canvas.height) {\n      // TODO: is this such an uncommon path taht we can skip it?\n      return this.canvas.toDataURL();\n    } else {\n      const tempCanvas = document.createElement(\"canvas\");\n      const squareSize = Math.min(this.canvas.width, this.canvas.height);\n      tempCanvas.width = squareSize;\n      tempCanvas.height = squareSize;\n      const tempCtx = tempCanvas.getContext(\"2d\")!; // TODO: can we assume this is always availab?E\n      tempCtx.drawImage(\n        this.canvas,\n        -(this.canvas.width - squareSize) / 2,\n        -(this.canvas.height - squareSize) / 2,\n      );\n      return tempCanvas.toDataURL();\n    }\n  }\n}\n\ncustomElementsShim.define(\"twisty-3d-canvas\", Twisty3DCanvas);\n", "// Debounces `requestAnimationFrame()`.\nexport class RenderScheduler {\n  private animFrameID: number | null = null;\n  private animFrame = this.animFrameWrapper.bind(this);\n  constructor(private callback: (timestamp: DOMHighResTimeStamp) => void) {}\n  requestAnimFrame(): void {\n    if (!this.animFrameID) {\n      this.animFrameID = requestAnimationFrame(this.animFrame);\n    }\n  }\n\n  cancelAnimFrame(): void {\n    if (this.animFrameID) {\n      cancelAnimationFrame(this.animFrameID);\n      this.animFrameID = 0;\n    }\n  }\n\n  private animFrameWrapper(timestamp: DOMHighResTimeStamp): void {\n    this.animFrameID = 0;\n    this.callback(timestamp);\n  }\n}\n", "// Workarounds for `node`.\n// TODO: figure out how to remove this.\n\n// This stub does not need to be callable, just constructable to satisfy the `node` loader.\nclass HTMLElementStub {}\n\nlet HTMLElementShim: typeof HTMLElement;\nif (typeof HTMLElement !== \"undefined\") {\n  HTMLElementShim = HTMLElement;\n} else {\n  HTMLElementShim = HTMLElementStub as any;\n}\n\nexport { HTMLElementShim };\n\nclass CustomElementsStub {\n  define(): void {\n    // nothing\n  }\n}\n\nlet customElementsShim: typeof customElements;\n\nif (typeof customElements !== \"undefined\") {\n  customElementsShim = customElements;\n} else {\n  customElementsShim = new CustomElementsStub() as any;\n}\n\nexport { customElementsShim };\n", "// Workarounds for `node`.\n// TODO: figure out how to remove this.\n\n// This stub does not need to be callable, just constructable to satisfy the `node` loader.\nclass HTMLElementStub {}\n\nlet HTMLElementShim: typeof HTMLElement;\nif (typeof HTMLElement !== \"undefined\") {\n  HTMLElementShim = HTMLElement;\n} else {\n  HTMLElementShim = HTMLElementStub as any;\n}\n\nexport { HTMLElementShim };\n\nclass CustomElementsStub {\n  define(): void {\n    // nothing\n  }\n}\n\nlet customElementsShim: typeof customElements;\n\nif (typeof customElements !== \"undefined\") {\n  customElementsShim = customElements;\n} else {\n  customElementsShim = new CustomElementsStub() as any;\n}\n\nexport { customElementsShim };\n", "import {\n  HTMLElementShim,\n  customElementsShim,\n} from \"./node-custom-element-shims\";\n\nexport class CSSSource {\n  constructor(private sourceText: string) {\n    // TODO: Replace with adopted style sheets some day if we can.\n    // const blob = new Blob([sourceText], {\n    //   type: \"text/utf8\",\n    // });\n    // this.url = URL.createObjectURL(blob);\n  }\n\n  getAsString(): string {\n    return this.sourceText;\n  }\n}\n\n// - Wrapped element\n//   - Shadow root\n//     - Content wrapper\nexport class ManagedCustomElement extends HTMLElementShim {\n  public shadow: ShadowRoot;\n  public contentWrapper: HTMLDivElement; // TODO: can we get rid of this wrapper?\n\n  private cssSourceMap: Map<CSSSource, HTMLStyleElement> = new Map();\n  constructor() {\n    super();\n    this.shadow = this.attachShadow({ mode: \"closed\" });\n\n    this.contentWrapper = document.createElement(\"div\");\n    this.contentWrapper.classList.add(\"wrapper\");\n    this.shadow.appendChild(this.contentWrapper);\n  }\n\n  // Add the source, if not already added.\n  public addCSS(cssSource: CSSSource): void {\n    if (this.cssSourceMap.get(cssSource)) {\n      return;\n    }\n\n    const cssElem: HTMLStyleElement = document.createElement(\"style\");\n    cssElem.textContent = cssSource.getAsString();\n\n    this.cssSourceMap.set(cssSource, cssElem);\n    this.shadow.appendChild(cssElem);\n  }\n\n  // Remove the source, if it's currently added.\n  public removeCSS(cssSource: CSSSource): void {\n    const cssElem = this.cssSourceMap.get(cssSource);\n    if (!cssElem) {\n      return;\n    }\n    this.shadow.removeChild(cssElem);\n    this.cssSourceMap.delete(cssSource);\n  }\n\n  public addElement<T extends Node>(element: T): T {\n    return this.contentWrapper.appendChild(element);\n  }\n\n  public prependElement<T extends Node>(element: T): void {\n    this.contentWrapper.prepend(element);\n  }\n\n  public removeElement<T extends Node>(element: T): T {\n    return this.contentWrapper.removeChild(element);\n  }\n}\n\ncustomElementsShim.define(\n  \"twisty-managed-custom-element\",\n  ManagedCustomElement,\n);\n", "// TODO: Handle if you move across screens?\nexport function pixelRatio(): number {\n  return devicePixelRatio || 1;\n}\n", "import { CSSSource } from \"../element/ManagedCustomElement\";\n\n// The `position` values are a hack for a bug in Safari where the canvas either\n// grows infinitely, or takes up the full `fr` of any encompassing grid (making\n// the contents of that element e.g. over 100% of its height). `contain:\n// content` is a good fix for this, but there is no indication that Safari will\n// support it soon. https://developer.mozilla.org/en-US/docs/Web/CSS/contain\n\nexport const twisty3DCanvasCSS = new CSSSource(`\n:host(twisty-3d-canvas) {\n  contain: content;\n  overflow: hidden;\n}\n\n.wrapper {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  contain: content;\n}\n\n/* TODO: This is due to stats hack. Replace with \\`canvas\\`. */\n.wrapper > canvas {\n  position: absolute;\n  max-width: 100%;\n  max-height: 100%;\n}\n\n.wrapper.invisible {\n  opacity: 0;\n}\n`);\n", "// Note this `vendor` dir should be in another place, but it's here to avoid an `eslint` bug/error.\n\n// TODO: implement the parts we need in `TwistyOrbitControls.\n\n/* eslint-disable */\n\n/**\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n * @author ScieCode / http://github.com/sciecode\n */\n\nimport {\n  EventDispatcher,\n  MOUSE,\n  Quaternion,\n  Spherical,\n  TOUCH,\n  Vector2,\n  Vector3,\n} from \"three\";\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\n\nconst OrbitControls = function (object, domElement) {\n  if (domElement === undefined)\n    console.warn(\n      'THREE.OrbitControls: The second parameter \"domElement\" is now mandatory.',\n    );\n  if (domElement === document)\n    console.error(\n      'THREE.OrbitControls: \"document\" should not be used as the target \"domElement\". Please use \"renderer.domElement\" instead.',\n    );\n\n  this.object = object;\n  this.domElement = domElement;\n\n  // Set to false to disable this control\n  this.enabled = true;\n\n  // \"target\" sets the location of focus, where the object orbits around\n  this.target = new Vector3();\n\n  // How far you can dolly in and out ( PerspectiveCamera only )\n  this.minDistance = 0;\n  this.maxDistance = Infinity;\n\n  // How far you can zoom in and out ( OrthographicCamera only )\n  this.minZoom = 0;\n  this.maxZoom = Infinity;\n\n  // How far you can orbit vertically, upper and lower limits.\n  // Range is 0 to Math.PI radians.\n  this.minPolarAngle = 0; // radians\n  this.maxPolarAngle = Math.PI; // radians\n\n  // How far you can orbit horizontally, upper and lower limits.\n  // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n  this.minAzimuthAngle = -Infinity; // radians\n  this.maxAzimuthAngle = Infinity; // radians\n\n  // Set to true to enable damping (inertia)\n  // If damping is enabled, you must call controls.update() in your animation loop\n  this.enableDamping = false;\n  this.dampingFactor = 0.05;\n\n  // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n  // Set to false to disable zooming\n  this.enableZoom = true;\n  this.zoomSpeed = 1.0;\n\n  // Set to false to disable rotating\n  this.enableRotate = true;\n  this.rotateSpeed = 1.0;\n\n  // Set to false to disable panning\n  this.enablePan = true;\n  this.panSpeed = 1.0;\n  this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up\n  this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n\n  // Set to true to automatically rotate around the target\n  // If auto-rotate is enabled, you must call controls.update() in your animation loop\n  this.autoRotate = false;\n  this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n  // Set to false to disable use of the keys\n  this.enableKeys = true;\n\n  // The four arrow keys\n  this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\n\n  // Mouse buttons\n  this.mouseButtons = {\n    LEFT: MOUSE.ROTATE,\n    MIDDLE: MOUSE.DOLLY,\n    RIGHT: MOUSE.PAN,\n  };\n\n  // Touch fingers\n  this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };\n\n  // for reset\n  this.target0 = this.target.clone();\n  this.position0 = this.object.position.clone();\n  this.zoom0 = this.object.zoom;\n\n  //\n  // public methods\n  //\n\n  this.getPolarAngle = function () {\n    return spherical.phi;\n  };\n\n  this.getAzimuthalAngle = function () {\n    return spherical.theta;\n  };\n\n  this.saveState = function () {\n    scope.target0.copy(scope.target);\n    scope.position0.copy(scope.object.position);\n    scope.zoom0 = scope.object.zoom;\n  };\n\n  this.reset = function () {\n    scope.target.copy(scope.target0);\n    scope.object.position.copy(scope.position0);\n    scope.object.zoom = scope.zoom0;\n\n    scope.object.updateProjectionMatrix();\n    scope.dispatchEvent(changeEvent);\n\n    scope.update();\n\n    state = STATE.NONE;\n  };\n\n  // this method is exposed, but perhaps it would be better if we can make it private...\n  this.update = (function () {\n    const offset = new Vector3();\n\n    // so camera.up is the orbit axis\n    const quat = new Quaternion().setFromUnitVectors(\n      object.up,\n      new Vector3(0, 1, 0),\n    );\n    const quatInverse = quat.clone().inverse();\n\n    const lastPosition = new Vector3();\n    const lastQuaternion = new Quaternion();\n\n    const twoPI = 2 * Math.PI;\n\n    return function update() {\n      const position = scope.object.position;\n\n      offset.copy(position).sub(scope.target);\n\n      // rotate offset to \"y-axis-is-up\" space\n      offset.applyQuaternion(quat);\n\n      // angle from z-axis around y-axis\n      spherical.setFromVector3(offset);\n\n      if (scope.autoRotate && state === STATE.NONE) {\n        rotateLeft(getAutoRotationAngle());\n      }\n\n      if (scope.enableDamping) {\n        spherical.theta += sphericalDelta.theta * scope.dampingFactor;\n        spherical.phi += sphericalDelta.phi * scope.dampingFactor;\n      } else {\n        spherical.theta += sphericalDelta.theta;\n        spherical.phi += sphericalDelta.phi;\n      }\n\n      // restrict theta to be between desired limits\n\n      let min = scope.minAzimuthAngle;\n      let max = scope.maxAzimuthAngle;\n\n      if (isFinite(min) && isFinite(max)) {\n        if (min < -Math.PI) min += twoPI;\n        else if (min > Math.PI) min -= twoPI;\n\n        if (max < -Math.PI) max += twoPI;\n        else if (max > Math.PI) max -= twoPI;\n\n        if (min < max) {\n          spherical.theta = Math.max(min, Math.min(max, spherical.theta));\n        } else {\n          spherical.theta =\n            spherical.theta > (min + max) / 2\n              ? Math.max(min, spherical.theta)\n              : Math.min(max, spherical.theta);\n        }\n      }\n\n      // restrict phi to be between desired limits\n      spherical.phi = Math.max(\n        scope.minPolarAngle,\n        Math.min(scope.maxPolarAngle, spherical.phi),\n      );\n\n      spherical.makeSafe();\n\n      spherical.radius *= scale;\n\n      // restrict radius to be between desired limits\n      spherical.radius = Math.max(\n        scope.minDistance,\n        Math.min(scope.maxDistance, spherical.radius),\n      );\n\n      // move target to panned location\n\n      if (scope.enableDamping === true) {\n        scope.target.addScaledVector(panOffset, scope.dampingFactor);\n      } else {\n        scope.target.add(panOffset);\n      }\n\n      offset.setFromSpherical(spherical);\n\n      // rotate offset back to \"camera-up-vector-is-up\" space\n      offset.applyQuaternion(quatInverse);\n\n      position.copy(scope.target).add(offset);\n\n      scope.object.lookAt(scope.target);\n\n      if (scope.enableDamping === true) {\n        sphericalDelta.theta *= 1 - scope.dampingFactor;\n        sphericalDelta.phi *= 1 - scope.dampingFactor;\n\n        panOffset.multiplyScalar(1 - scope.dampingFactor);\n      } else {\n        sphericalDelta.set(0, 0, 0);\n\n        panOffset.set(0, 0, 0);\n      }\n\n      scale = 1;\n\n      // update condition is:\n      // min(camera displacement, camera rotation in radians)^2 > EPS\n      // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n      if (\n        zoomChanged ||\n        lastPosition.distanceToSquared(scope.object.position) > EPS ||\n        8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS\n      ) {\n        scope.dispatchEvent(changeEvent);\n\n        lastPosition.copy(scope.object.position);\n        lastQuaternion.copy(scope.object.quaternion);\n        zoomChanged = false;\n\n        return true;\n      }\n\n      return false;\n    };\n  })();\n\n  this.dispose = function () {\n    scope.domElement.removeEventListener(\"contextmenu\", onContextMenu, false);\n    scope.domElement.removeEventListener(\"mousedown\", onMouseDown, false);\n    scope.domElement.removeEventListener(\"wheel\", onMouseWheel, false);\n\n    scope.domElement.removeEventListener(\"touchstart\", onTouchStart, false);\n    scope.domElement.removeEventListener(\"touchend\", onTouchEnd, false);\n    scope.domElement.removeEventListener(\"touchmove\", onTouchMove, false);\n\n    scope.domElement.ownerDocument.removeEventListener(\n      \"mousemove\",\n      onMouseMove,\n      false,\n    );\n    scope.domElement.ownerDocument.removeEventListener(\n      \"mouseup\",\n      onMouseUp,\n      false,\n    );\n\n    scope.domElement.removeEventListener(\"keydown\", onKeyDown, false);\n\n    //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n  };\n\n  //\n  // internals\n  //\n\n  var scope = this;\n\n  var changeEvent = { type: \"change\" };\n  const startEvent = { type: \"start\" };\n  const endEvent = { type: \"end\" };\n\n  var STATE = {\n    NONE: -1,\n    ROTATE: 0,\n    DOLLY: 1,\n    PAN: 2,\n    TOUCH_ROTATE: 3,\n    TOUCH_PAN: 4,\n    TOUCH_DOLLY_PAN: 5,\n    TOUCH_DOLLY_ROTATE: 6,\n  };\n\n  var state = STATE.NONE;\n\n  var EPS = 0.000001;\n\n  // current position in spherical coordinates\n  var spherical = new Spherical();\n  var sphericalDelta = new Spherical();\n\n  var scale = 1;\n  var panOffset = new Vector3();\n  var zoomChanged = false;\n\n  const rotateStart = new Vector2();\n  const rotateEnd = new Vector2();\n  const rotateDelta = new Vector2();\n\n  const panStart = new Vector2();\n  const panEnd = new Vector2();\n  const panDelta = new Vector2();\n\n  const dollyStart = new Vector2();\n  const dollyEnd = new Vector2();\n  const dollyDelta = new Vector2();\n\n  function getAutoRotationAngle() {\n    return ((2 * Math.PI) / 60 / 60) * scope.autoRotateSpeed;\n  }\n\n  function getZoomScale() {\n    return Math.pow(0.95, scope.zoomSpeed);\n  }\n\n  function rotateLeft(angle) {\n    sphericalDelta.theta -= angle;\n  }\n\n  function rotateUp(angle) {\n    sphericalDelta.phi -= angle;\n  }\n\n  const panLeft = (function () {\n    const v = new Vector3();\n\n    return function panLeft(distance, objectMatrix) {\n      v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix\n      v.multiplyScalar(-distance);\n\n      panOffset.add(v);\n    };\n  })();\n\n  const panUp = (function () {\n    const v = new Vector3();\n\n    return function panUp(distance, objectMatrix) {\n      if (scope.screenSpacePanning === true) {\n        v.setFromMatrixColumn(objectMatrix, 1);\n      } else {\n        v.setFromMatrixColumn(objectMatrix, 0);\n        v.crossVectors(scope.object.up, v);\n      }\n\n      v.multiplyScalar(distance);\n\n      panOffset.add(v);\n    };\n  })();\n\n  // deltaX and deltaY are in pixels; right and down are positive\n  const pan = (function () {\n    const offset = new Vector3();\n\n    return function pan(deltaX, deltaY) {\n      const element = scope.domElement;\n\n      if (scope.object.isPerspectiveCamera) {\n        // perspective\n        const position = scope.object.position;\n        offset.copy(position).sub(scope.target);\n        let targetDistance = offset.length();\n\n        // half of the fov is center to top of screen\n        targetDistance *= Math.tan(((scope.object.fov / 2) * Math.PI) / 180.0);\n\n        // we use only clientHeight here so aspect ratio does not distort speed\n        panLeft(\n          (2 * deltaX * targetDistance) / element.clientHeight,\n          scope.object.matrix,\n        );\n        panUp(\n          (2 * deltaY * targetDistance) / element.clientHeight,\n          scope.object.matrix,\n        );\n      } else if (scope.object.isOrthographicCamera) {\n        // orthographic\n        panLeft(\n          (deltaX * (scope.object.right - scope.object.left)) /\n            scope.object.zoom /\n            element.clientWidth,\n          scope.object.matrix,\n        );\n        panUp(\n          (deltaY * (scope.object.top - scope.object.bottom)) /\n            scope.object.zoom /\n            element.clientHeight,\n          scope.object.matrix,\n        );\n      } else {\n        // camera neither orthographic nor perspective\n        console.warn(\n          \"WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.\",\n        );\n        scope.enablePan = false;\n      }\n    };\n  })();\n\n  function dollyOut(dollyScale) {\n    if (scope.object.isPerspectiveCamera) {\n      scale /= dollyScale;\n    } else if (scope.object.isOrthographicCamera) {\n      scope.object.zoom = Math.max(\n        scope.minZoom,\n        Math.min(scope.maxZoom, scope.object.zoom * dollyScale),\n      );\n      scope.object.updateProjectionMatrix();\n      zoomChanged = true;\n    } else {\n      console.warn(\n        \"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\",\n      );\n      scope.enableZoom = false;\n    }\n  }\n\n  function dollyIn(dollyScale) {\n    if (scope.object.isPerspectiveCamera) {\n      scale *= dollyScale;\n    } else if (scope.object.isOrthographicCamera) {\n      scope.object.zoom = Math.max(\n        scope.minZoom,\n        Math.min(scope.maxZoom, scope.object.zoom / dollyScale),\n      );\n      scope.object.updateProjectionMatrix();\n      zoomChanged = true;\n    } else {\n      console.warn(\n        \"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\",\n      );\n      scope.enableZoom = false;\n    }\n  }\n\n  //\n  // event callbacks - update the object state\n  //\n\n  function handleMouseDownRotate(event) {\n    rotateStart.set(event.clientX, event.clientY);\n  }\n\n  function handleMouseDownDolly(event) {\n    dollyStart.set(event.clientX, event.clientY);\n  }\n\n  function handleMouseDownPan(event) {\n    panStart.set(event.clientX, event.clientY);\n  }\n\n  function handleMouseMoveRotate(event) {\n    rotateEnd.set(event.clientX, event.clientY);\n\n    rotateDelta\n      .subVectors(rotateEnd, rotateStart)\n      .multiplyScalar(scope.rotateSpeed);\n\n    const element = scope.domElement;\n\n    rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight); // yes, height\n\n    rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight);\n\n    rotateStart.copy(rotateEnd);\n\n    scope.update();\n  }\n\n  function handleMouseMoveDolly(event) {\n    dollyEnd.set(event.clientX, event.clientY);\n\n    dollyDelta.subVectors(dollyEnd, dollyStart);\n\n    if (dollyDelta.y > 0) {\n      dollyOut(getZoomScale());\n    } else if (dollyDelta.y < 0) {\n      dollyIn(getZoomScale());\n    }\n\n    dollyStart.copy(dollyEnd);\n\n    scope.update();\n  }\n\n  function handleMouseMovePan(event) {\n    panEnd.set(event.clientX, event.clientY);\n\n    panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n\n    pan(panDelta.x, panDelta.y);\n\n    panStart.copy(panEnd);\n\n    scope.update();\n  }\n\n  function handleMouseUp(/*event*/) {\n    // no-op\n  }\n\n  function handleMouseWheel(event) {\n    if (event.deltaY < 0) {\n      dollyIn(getZoomScale());\n    } else if (event.deltaY > 0) {\n      dollyOut(getZoomScale());\n    }\n\n    scope.update();\n  }\n\n  function handleKeyDown(event) {\n    let needsUpdate = false;\n\n    switch (event.keyCode) {\n      case scope.keys.UP:\n        pan(0, scope.keyPanSpeed);\n        needsUpdate = true;\n        break;\n\n      case scope.keys.BOTTOM:\n        pan(0, -scope.keyPanSpeed);\n        needsUpdate = true;\n        break;\n\n      case scope.keys.LEFT:\n        pan(scope.keyPanSpeed, 0);\n        needsUpdate = true;\n        break;\n\n      case scope.keys.RIGHT:\n        pan(-scope.keyPanSpeed, 0);\n        needsUpdate = true;\n        break;\n    }\n\n    if (needsUpdate) {\n      // prevent the browser from scrolling on cursor keys\n      event.preventDefault();\n\n      scope.update();\n    }\n  }\n\n  function handleTouchStartRotate(event) {\n    if (event.touches.length == 1) {\n      rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n    } else {\n      const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\n      const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\n\n      rotateStart.set(x, y);\n    }\n  }\n\n  function handleTouchStartPan(event) {\n    if (event.touches.length == 1) {\n      panStart.set(event.touches[0].pageX, event.touches[0].pageY);\n    } else {\n      const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\n      const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\n\n      panStart.set(x, y);\n    }\n  }\n\n  function handleTouchStartDolly(event) {\n    const dx = event.touches[0].pageX - event.touches[1].pageX;\n    const dy = event.touches[0].pageY - event.touches[1].pageY;\n\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    dollyStart.set(0, distance);\n  }\n\n  function handleTouchStartDollyPan(event) {\n    if (scope.enableZoom) handleTouchStartDolly(event);\n\n    if (scope.enablePan) handleTouchStartPan(event);\n  }\n\n  function handleTouchStartDollyRotate(event) {\n    if (scope.enableZoom) handleTouchStartDolly(event);\n\n    if (scope.enableRotate) handleTouchStartRotate(event);\n  }\n\n  function handleTouchMoveRotate(event) {\n    if (event.touches.length == 1) {\n      rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n    } else {\n      const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\n      const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\n\n      rotateEnd.set(x, y);\n    }\n\n    rotateDelta\n      .subVectors(rotateEnd, rotateStart)\n      .multiplyScalar(scope.rotateSpeed);\n\n    const element = scope.domElement;\n\n    rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight); // yes, height\n\n    rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight);\n\n    rotateStart.copy(rotateEnd);\n  }\n\n  function handleTouchMovePan(event) {\n    if (event.touches.length == 1) {\n      panEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n    } else {\n      const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\n      const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\n\n      panEnd.set(x, y);\n    }\n\n    panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n\n    pan(panDelta.x, panDelta.y);\n\n    panStart.copy(panEnd);\n  }\n\n  function handleTouchMoveDolly(event) {\n    const dx = event.touches[0].pageX - event.touches[1].pageX;\n    const dy = event.touches[0].pageY - event.touches[1].pageY;\n\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    dollyEnd.set(0, distance);\n\n    dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));\n\n    dollyOut(dollyDelta.y);\n\n    dollyStart.copy(dollyEnd);\n  }\n\n  function handleTouchMoveDollyPan(event) {\n    if (scope.enableZoom) handleTouchMoveDolly(event);\n\n    if (scope.enablePan) handleTouchMovePan(event);\n  }\n\n  function handleTouchMoveDollyRotate(event) {\n    if (scope.enableZoom) handleTouchMoveDolly(event);\n\n    if (scope.enableRotate) handleTouchMoveRotate(event);\n  }\n\n  function handleTouchEnd(/*event*/) {\n    // no-op\n  }\n\n  //\n  // event handlers - FSM: listen for events and reset state\n  //\n\n  function onMouseDown(event) {\n    if (scope.enabled === false) return;\n\n    // Prevent the browser from scrolling.\n    event.preventDefault();\n\n    // Manually set the focus since calling preventDefault above\n    // prevents the browser from setting it automatically.\n\n    scope.domElement.focus ? scope.domElement.focus() : window.focus();\n\n    let mouseAction;\n\n    switch (event.button) {\n      case 0:\n        mouseAction = scope.mouseButtons.LEFT;\n        break;\n\n      case 1:\n        mouseAction = scope.mouseButtons.MIDDLE;\n        break;\n\n      case 2:\n        mouseAction = scope.mouseButtons.RIGHT;\n        break;\n\n      default:\n        mouseAction = -1;\n    }\n\n    switch (mouseAction) {\n      case MOUSE.DOLLY:\n        if (scope.enableZoom === false) return;\n\n        handleMouseDownDolly(event);\n\n        state = STATE.DOLLY;\n\n        break;\n\n      case MOUSE.ROTATE:\n        if (event.ctrlKey || event.metaKey || event.shiftKey) {\n          if (scope.enablePan === false) return;\n\n          handleMouseDownPan(event);\n\n          state = STATE.PAN;\n        } else {\n          if (scope.enableRotate === false) return;\n\n          handleMouseDownRotate(event);\n\n          state = STATE.ROTATE;\n        }\n\n        break;\n\n      case MOUSE.PAN:\n        if (event.ctrlKey || event.metaKey || event.shiftKey) {\n          if (scope.enableRotate === false) return;\n\n          handleMouseDownRotate(event);\n\n          state = STATE.ROTATE;\n        } else {\n          if (scope.enablePan === false) return;\n\n          handleMouseDownPan(event);\n\n          state = STATE.PAN;\n        }\n\n        break;\n\n      default:\n        state = STATE.NONE;\n    }\n\n    if (state !== STATE.NONE) {\n      scope.domElement.ownerDocument.addEventListener(\n        \"mousemove\",\n        onMouseMove,\n        false,\n      );\n      scope.domElement.ownerDocument.addEventListener(\n        \"mouseup\",\n        onMouseUp,\n        false,\n      );\n\n      scope.dispatchEvent(startEvent);\n    }\n  }\n\n  function onMouseMove(event) {\n    if (scope.enabled === false) return;\n\n    event.preventDefault();\n\n    switch (state) {\n      case STATE.ROTATE:\n        if (scope.enableRotate === false) return;\n\n        handleMouseMoveRotate(event);\n\n        break;\n\n      case STATE.DOLLY:\n        if (scope.enableZoom === false) return;\n\n        handleMouseMoveDolly(event);\n\n        break;\n\n      case STATE.PAN:\n        if (scope.enablePan === false) return;\n\n        handleMouseMovePan(event);\n\n        break;\n    }\n  }\n\n  function onMouseUp(event) {\n    if (scope.enabled === false) return;\n\n    handleMouseUp(event);\n\n    scope.domElement.ownerDocument.removeEventListener(\n      \"mousemove\",\n      onMouseMove,\n      false,\n    );\n    scope.domElement.ownerDocument.removeEventListener(\n      \"mouseup\",\n      onMouseUp,\n      false,\n    );\n\n    scope.dispatchEvent(endEvent);\n\n    state = STATE.NONE;\n  }\n\n  function onMouseWheel(event) {\n    if (\n      scope.enabled === false ||\n      scope.enableZoom === false ||\n      (state !== STATE.NONE && state !== STATE.ROTATE)\n    )\n      return;\n\n    event.preventDefault();\n    event.stopPropagation();\n\n    scope.dispatchEvent(startEvent);\n\n    handleMouseWheel(event);\n\n    scope.dispatchEvent(endEvent);\n  }\n\n  function onKeyDown(event) {\n    if (\n      scope.enabled === false ||\n      scope.enableKeys === false ||\n      scope.enablePan === false\n    )\n      return;\n\n    handleKeyDown(event);\n  }\n\n  function onTouchStart(event) {\n    if (scope.enabled === false) return;\n\n    event.preventDefault(); // prevent scrolling\n\n    switch (event.touches.length) {\n      case 1:\n        switch (scope.touches.ONE) {\n          case TOUCH.ROTATE:\n            if (scope.enableRotate === false) return;\n\n            handleTouchStartRotate(event);\n\n            state = STATE.TOUCH_ROTATE;\n\n            break;\n\n          case TOUCH.PAN:\n            if (scope.enablePan === false) return;\n\n            handleTouchStartPan(event);\n\n            state = STATE.TOUCH_PAN;\n\n            break;\n\n          default:\n            state = STATE.NONE;\n        }\n\n        break;\n\n      case 2:\n        switch (scope.touches.TWO) {\n          case TOUCH.DOLLY_PAN:\n            if (scope.enableZoom === false && scope.enablePan === false) return;\n\n            handleTouchStartDollyPan(event);\n\n            state = STATE.TOUCH_DOLLY_PAN;\n\n            break;\n\n          case TOUCH.DOLLY_ROTATE:\n            if (scope.enableZoom === false && scope.enableRotate === false)\n              return;\n\n            handleTouchStartDollyRotate(event);\n\n            state = STATE.TOUCH_DOLLY_ROTATE;\n\n            break;\n\n          default:\n            state = STATE.NONE;\n        }\n\n        break;\n\n      default:\n        state = STATE.NONE;\n    }\n\n    if (state !== STATE.NONE) {\n      scope.dispatchEvent(startEvent);\n    }\n  }\n\n  function onTouchMove(event) {\n    if (scope.enabled === false) return;\n\n    event.preventDefault(); // prevent scrolling\n    event.stopPropagation();\n\n    switch (state) {\n      case STATE.TOUCH_ROTATE:\n        if (scope.enableRotate === false) return;\n\n        handleTouchMoveRotate(event);\n\n        scope.update();\n\n        break;\n\n      case STATE.TOUCH_PAN:\n        if (scope.enablePan === false) return;\n\n        handleTouchMovePan(event);\n\n        scope.update();\n\n        break;\n\n      case STATE.TOUCH_DOLLY_PAN:\n        if (scope.enableZoom === false && scope.enablePan === false) return;\n\n        handleTouchMoveDollyPan(event);\n\n        scope.update();\n\n        break;\n\n      case STATE.TOUCH_DOLLY_ROTATE:\n        if (scope.enableZoom === false && scope.enableRotate === false) return;\n\n        handleTouchMoveDollyRotate(event);\n\n        scope.update();\n\n        break;\n\n      default:\n        state = STATE.NONE;\n    }\n  }\n\n  function onTouchEnd(event) {\n    if (scope.enabled === false) return;\n\n    handleTouchEnd(event);\n\n    scope.dispatchEvent(endEvent);\n\n    state = STATE.NONE;\n  }\n\n  function onContextMenu(event) {\n    if (scope.enabled === false) return;\n\n    event.preventDefault();\n  }\n\n  //\n\n  scope.domElement.addEventListener(\"contextmenu\", onContextMenu, false);\n\n  scope.domElement.addEventListener(\"mousedown\", onMouseDown, false);\n  scope.domElement.addEventListener(\"wheel\", onMouseWheel, false);\n\n  scope.domElement.addEventListener(\"touchstart\", onTouchStart, false);\n  scope.domElement.addEventListener(\"touchend\", onTouchEnd, false);\n  scope.domElement.addEventListener(\"touchmove\", onTouchMove, false);\n\n  scope.domElement.addEventListener(\"keydown\", onKeyDown, false);\n\n  // make sure element can receive keys.\n\n  if (scope.domElement.tabIndex === -1) {\n    scope.domElement.tabIndex = 0;\n  }\n\n  // force an update at start\n\n  this.update();\n};\n\nOrbitControls.prototype = Object.create(EventDispatcher.prototype);\nOrbitControls.prototype.constructor = OrbitControls;\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n// This is very similar to OrbitControls, another set of touch behavior\n//\n//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - left mouse, or arrow keys / touch: one-finger move\n\nconst MapControls = function (object, domElement) {\n  OrbitControls.call(this, object, domElement);\n\n  this.screenSpacePanning = false; // pan orthogonal to world-space direction camera.up\n\n  this.mouseButtons.LEFT = MOUSE.PAN;\n  this.mouseButtons.RIGHT = MOUSE.ROTATE;\n\n  this.touches.ONE = TOUCH.PAN;\n  this.touches.TWO = TOUCH.DOLLY_ROTATE;\n};\n\nMapControls.prototype = Object.create(EventDispatcher.prototype);\nMapControls.prototype.constructor = MapControls;\n\nexport { OrbitControls, MapControls };\n", "import { Camera } from \"three\";\nimport { OrbitControls as ThreeOrbitControls } from \"./vendor/OrbitControls\";\n\nconst INERTIA_DEFAULT: boolean = true;\n\n// TODO: Support limiting altitudinal angle, similar to alg.cubing.net v1.\n// TODO: Allow locking vertical rotation if the mouse/touch hasn't moved much, similar to alg.cubing.net v1.\n// TODO: Use more damping during drag, and less damping after letting go.\nexport class TwistyOrbitControls {\n  threeOrbitControls: ThreeOrbitControls;\n  mirrorControls?: TwistyOrbitControls;\n  constructor(\n    private camera: Camera,\n    canvas: HTMLCanvasElement,\n    private scheduleRender: () => void,\n  ) {\n    this.threeOrbitControls = new ThreeOrbitControls(camera, canvas);\n    this.threeOrbitControls.enableDamping = INERTIA_DEFAULT;\n    this.threeOrbitControls.rotateSpeed = 0.5;\n    this.threeOrbitControls.enablePan = false;\n    this.threeOrbitControls.enableZoom = false;\n\n    // Note we can get a `change` event after `end` due to dampening.\n    const eventHandler = this.onOrbitControlEvent.bind(this);\n    this.threeOrbitControls.addEventListener(\"start\", eventHandler);\n    this.threeOrbitControls.addEventListener(\"change\", eventHandler);\n    this.threeOrbitControls.addEventListener(\"end\", eventHandler);\n  }\n\n  public setInertia(enabled: boolean): void {\n    this.threeOrbitControls.enableDamping = enabled;\n  }\n\n  public onOrbitControlEvent(): void {\n    this.scheduleRender();\n    this.mirrorControls?.updateMirroredCamera(this.camera);\n  }\n\n  public setMirror(m: TwistyOrbitControls): void {\n    this.mirrorControls = m;\n  }\n\n  updateMirroredCamera(c: Camera): void {\n    this.camera.position.copy(c.position);\n    this.camera.position.multiplyScalar(-1);\n    this.scheduleRender();\n  }\n\n  updateAndSchedule(): void {\n    // The return value tells us whether there was an update. If there was an\n    // update, we schedule a render to check next frame. This means we might\n    // render an extra frame at the end, but that's a fairly low cost for the\n    // simplicity of implementation.\n    if (this.threeOrbitControls.update()) {\n      this.scheduleRender();\n    }\n  }\n}\n", "/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar Stats = function () {\n\n\tvar mode = 0;\n\n\tvar container = document.createElement( 'div' );\n\tcontainer.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000';\n\tcontainer.addEventListener( 'click', function ( event ) {\n\n\t\tevent.preventDefault();\n\t\tshowPanel( ++ mode % container.children.length );\n\n\t}, false );\n\n\t//\n\n\tfunction addPanel( panel ) {\n\n\t\tcontainer.appendChild( panel.dom );\n\t\treturn panel;\n\n\t}\n\n\tfunction showPanel( id ) {\n\n\t\tfor ( var i = 0; i < container.children.length; i ++ ) {\n\n\t\t\tcontainer.children[ i ].style.display = i === id ? 'block' : 'none';\n\n\t\t}\n\n\t\tmode = id;\n\n\t}\n\n\t//\n\n\tvar beginTime = ( performance || Date ).now(), prevTime = beginTime, frames = 0;\n\n\tvar fpsPanel = addPanel( new Stats.Panel( 'FPS', '#0ff', '#002' ) );\n\tvar msPanel = addPanel( new Stats.Panel( 'MS', '#0f0', '#020' ) );\n\n\tif ( self.performance && self.performance.memory ) {\n\n\t\tvar memPanel = addPanel( new Stats.Panel( 'MB', '#f08', '#201' ) );\n\n\t}\n\n\tshowPanel( 0 );\n\n\treturn {\n\n\t\tREVISION: 16,\n\n\t\tdom: container,\n\n\t\taddPanel: addPanel,\n\t\tshowPanel: showPanel,\n\n\t\tbegin: function () {\n\n\t\t\tbeginTime = ( performance || Date ).now();\n\n\t\t},\n\n\t\tend: function () {\n\n\t\t\tframes ++;\n\n\t\t\tvar time = ( performance || Date ).now();\n\n\t\t\tmsPanel.update( time - beginTime, 200 );\n\n\t\t\tif ( time >= prevTime + 1000 ) {\n\n\t\t\t\tfpsPanel.update( ( frames * 1000 ) / ( time - prevTime ), 100 );\n\n\t\t\t\tprevTime = time;\n\t\t\t\tframes = 0;\n\n\t\t\t\tif ( memPanel ) {\n\n\t\t\t\t\tvar memory = performance.memory;\n\t\t\t\t\tmemPanel.update( memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn time;\n\n\t\t},\n\n\t\tupdate: function () {\n\n\t\t\tbeginTime = this.end();\n\n\t\t},\n\n\t\t// Backwards Compatibility\n\n\t\tdomElement: container,\n\t\tsetMode: showPanel\n\n\t};\n\n};\n\nStats.Panel = function ( name, fg, bg ) {\n\n\tvar min = Infinity, max = 0, round = Math.round;\n\tvar PR = round( window.devicePixelRatio || 1 );\n\n\tvar WIDTH = 80 * PR, HEIGHT = 48 * PR,\n\t\tTEXT_X = 3 * PR, TEXT_Y = 2 * PR,\n\t\tGRAPH_X = 3 * PR, GRAPH_Y = 15 * PR,\n\t\tGRAPH_WIDTH = 74 * PR, GRAPH_HEIGHT = 30 * PR;\n\n\tvar canvas = document.createElement( 'canvas' );\n\tcanvas.width = WIDTH;\n\tcanvas.height = HEIGHT;\n\tcanvas.style.cssText = 'width:80px;height:48px';\n\n\tvar context = canvas.getContext( '2d' );\n\tcontext.font = 'bold ' + ( 9 * PR ) + 'px Helvetica,Arial,sans-serif';\n\tcontext.textBaseline = 'top';\n\n\tcontext.fillStyle = bg;\n\tcontext.fillRect( 0, 0, WIDTH, HEIGHT );\n\n\tcontext.fillStyle = fg;\n\tcontext.fillText( name, TEXT_X, TEXT_Y );\n\tcontext.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT );\n\n\tcontext.fillStyle = bg;\n\tcontext.globalAlpha = 0.9;\n\tcontext.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT );\n\n\treturn {\n\n\t\tdom: canvas,\n\n\t\tupdate: function ( value, maxValue ) {\n\n\t\t\tmin = Math.min( min, value );\n\t\t\tmax = Math.max( max, value );\n\n\t\t\tcontext.fillStyle = bg;\n\t\t\tcontext.globalAlpha = 1;\n\t\t\tcontext.fillRect( 0, 0, WIDTH, GRAPH_Y );\n\t\t\tcontext.fillStyle = fg;\n\t\t\tcontext.fillText( round( value ) + ' ' + name + ' (' + round( min ) + '-' + round( max ) + ')', TEXT_X, TEXT_Y );\n\n\t\t\tcontext.drawImage( canvas, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT );\n\n\t\t\tcontext.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT );\n\n\t\t\tcontext.fillStyle = bg;\n\t\t\tcontext.globalAlpha = 0.9;\n\t\t\tcontext.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round( ( 1 - ( value / maxValue ) ) * GRAPH_HEIGHT ) );\n\n\t\t}\n\n\t};\n\n};\n\nexport default Stats;\n", "import { PerspectiveCamera, Vector3, WebGLRenderer } from \"three\";\nimport { Twisty3DScene } from \"../../3D/Twisty3DScene\";\nimport { RenderScheduler } from \"../../animation/RenderScheduler\";\nimport { ManagedCustomElement } from \"../element/ManagedCustomElement\";\nimport { pixelRatio } from \"./canvas\";\nimport { twisty3DCanvasCSS } from \"./Twisty3DCanvas.css\";\nimport { TwistyOrbitControls } from \"./TwistyOrbitControls\";\nimport { TwistyViewerElement } from \"./TwistyViewerElement\";\nimport { customElementsShim } from \"../element/node-custom-element-shims\";\nimport Stats from \"../../../vendor/node_modules/three/examples/jsm/libs/stats.module\";\n\nlet SHOW_STATS = false;\n// Show render stats for newly contructed renderers.\nexport function experimentalShowRenderStats(show: boolean): void {\n  SHOW_STATS = show;\n}\n\nlet resizeObserverWarningShown = false;\n\nlet shareAllNewRenderers: boolean = false;\n\n// WARNING: The current shared renderer implementation is not every efficient.\n// Avoid using for players that are likely to have dimensions approaching 1 megapixel or higher.\n// TODO: use a dedicated renderer while fullscreen?\nexport function experimentalSetShareAllNewRenderers(share: boolean): void {\n  shareAllNewRenderers = share;\n}\n\nlet sharedRenderer: WebGLRenderer | null = null;\n\nfunction newRenderer(): WebGLRenderer {\n  return new WebGLRenderer({\n    antialias: true,\n    alpha: true, // TODO\n  });\n}\n\nfunction newSharedRenderer(): WebGLRenderer {\n  return sharedRenderer ?? (sharedRenderer = newRenderer());\n}\n\n// <twisty-3d-canvas>\nexport class Twisty3DCanvas\n  extends ManagedCustomElement\n  implements TwistyViewerElement {\n  private scene: Twisty3DScene;\n  public canvas: HTMLCanvasElement;\n  public camera: PerspectiveCamera;\n  private legacyExperimentalShift: number = 0;\n  private orbitControls: TwistyOrbitControls;\n  private scheduler = new RenderScheduler(this.render.bind(this));\n  private resizePending: boolean = false;\n\n  private renderer: WebGLRenderer; // TODO: share renderers across elements? (issue: renderers are not designed to be constantly resized?)\n  private rendererIsShared: boolean;\n  private canvas2DContext: CanvasRenderingContext2D;\n\n  private stats: Stats | null = null;\n\n  // TODO: Are there any render duration performance concerns with removing this?\n  #invisible: boolean = false;\n  constructor(\n    scene?: Twisty3DScene,\n    options: { cameraPosition?: Vector3; negateCameraPosition?: boolean } = {},\n  ) {\n    super();\n    this.addCSS(twisty3DCanvasCSS);\n\n    this.scene = scene!;\n    this.scene.addRenderTarget(this);\n    if (SHOW_STATS) {\n      this.stats = Stats();\n      this.stats.dom.style.position = \"absolute\";\n      this.addElement(this.stats.dom);\n    }\n\n    // We rely on the resize logic to handle renderer dimensions.\n    this.rendererIsShared = shareAllNewRenderers;\n    this.renderer = this.rendererIsShared ? newSharedRenderer() : newRenderer();\n    this.canvas = this.rendererIsShared\n      ? document.createElement(\"canvas\")\n      : this.renderer.domElement;\n    this.canvas2DContext = this.canvas.getContext(\"2d\")!; // TODO: avoid saving unneeded?\n    this.addElement(this.canvas);\n\n    this.camera = new PerspectiveCamera(\n      20,\n      1, // We rely on the resize logic to handle this.\n      0.1,\n      1000,\n    );\n    this.camera.position.copy(options.cameraPosition ?? new Vector3(2, 4, 4));\n    if (options.negateCameraPosition) {\n      this.camera.position.multiplyScalar(-1);\n    }\n    this.camera.lookAt(new Vector3(0, 0, 0)); // TODO: Handle with `negateCameraPosition`\n    this.orbitControls = new TwistyOrbitControls(\n      this.camera,\n      this.canvas,\n      this.scheduleRender.bind(this),\n    );\n\n    // TODO: Remove this when enough Safari users have `ResizeObserver`.\n    if (window.ResizeObserver) {\n      const observer = new window.ResizeObserver(this.onResize.bind(this));\n      observer.observe(this.contentWrapper);\n    } else {\n      this.scheduleRender();\n      if (!resizeObserverWarningShown) {\n        console.warn(\n          \"You are using an older browser that does not support `ResizeObserver`. Displayed puzzles will not be rescaled.\",\n        );\n        resizeObserverWarningShown = true;\n      }\n    }\n  }\n\n  public setMirror(partner: Twisty3DCanvas): void {\n    this.orbitControls.setMirror(partner.orbitControls);\n    partner.orbitControls.setMirror(this.orbitControls);\n  }\n\n  protected connectedCallback(): void {\n    // Resize as soon as we're in the DOM, to avoid a flash of incorrectly sized content.\n    this.resize();\n    this.render();\n  }\n\n  scheduleRender(): void {\n    this.scheduler.requestAnimFrame();\n  }\n\n  // If the current size/state is incorrect, it may be preferable to hide it\n  // briefly, rather than flashing an incorrect version for one frame.\n  makeInvisibleUntilRender(): void {\n    this.contentWrapper.classList.add(\"invisible\");\n    this.#invisible = true;\n  }\n\n  private render(): void {\n    // Cancel any scheduled frame, since we're rendering right now.\n    // We don't need to re-render until something schedules again.\n    this.stats?.begin();\n    this.scheduler.cancelAnimFrame();\n    if (this.resizePending) {\n      this.resize();\n    }\n    this.orbitControls.updateAndSchedule();\n\n    if (this.rendererIsShared) {\n      this.renderer.setSize(this.canvas.width, this.canvas.height, false);\n      this.canvas2DContext.clearRect(\n        0,\n        0,\n        this.canvas.width,\n        this.canvas.height,\n      );\n    }\n    this.renderer.render(this.scene, this.camera);\n    if (this.rendererIsShared) {\n      this.canvas2DContext.drawImage(this.renderer.domElement, 0, 0);\n    }\n\n    if (this.#invisible) {\n      this.contentWrapper.classList.remove(\"invisible\");\n    }\n    this.stats?.end();\n  }\n\n  private onResize(): void {\n    this.resizePending = true;\n    this.scheduleRender();\n  }\n\n  private resize(): void {\n    this.resizePending = false;\n\n    const w = this.contentWrapper.clientWidth;\n    const h = this.contentWrapper.clientHeight;\n    let off = 0;\n    if (this.legacyExperimentalShift > 0) {\n      off = Math.max(0, Math.floor((w - h) * 0.5));\n    } else if (this.legacyExperimentalShift < 0) {\n      off = -Math.max(0, Math.floor((w - h) * 0.5));\n    }\n    let yoff = 0;\n    let excess = 0;\n    if (h > w) {\n      excess = h - w;\n      yoff = -Math.floor(0.5 * excess);\n    }\n    this.camera.aspect = w / h;\n    this.camera.setViewOffset(w, h - excess, off, yoff, w, h);\n    this.camera.updateProjectionMatrix(); // TODO\n\n    if (this.rendererIsShared) {\n      this.canvas.width = w * pixelRatio();\n      this.canvas.height = h * pixelRatio();\n      this.canvas.style.width = w.toString();\n      this.canvas.style.height = w.toString();\n    } else {\n      this.renderer.setPixelRatio(pixelRatio());\n      this.renderer.setSize(w, h, true);\n    }\n\n    this.scheduleRender();\n  }\n\n  // Square crop is useful for rending icons.\n  renderToDataURL(options: { squareCrop?: boolean } = {}): string {\n    // We don't preserve the drawing buffer, so we have to render again and then immediately read the canvas data.\n    // https://stackoverflow.com/a/30647502\n    this.render();\n\n    // TODO: can we assume that a central crop is similar enough to how a square canvas render would loook?\n    if (!options.squareCrop || this.canvas.width === this.canvas.height) {\n      // TODO: is this such an uncommon path taht we can skip it?\n      return this.canvas.toDataURL();\n    } else {\n      const tempCanvas = document.createElement(\"canvas\");\n      const squareSize = Math.min(this.canvas.width, this.canvas.height);\n      tempCanvas.width = squareSize;\n      tempCanvas.height = squareSize;\n      const tempCtx = tempCanvas.getContext(\"2d\")!; // TODO: can we assume this is always availab?E\n      tempCtx.drawImage(\n        this.canvas,\n        -(this.canvas.width - squareSize) / 2,\n        -(this.canvas.height - squareSize) / 2,\n      );\n      return tempCanvas.toDataURL();\n    }\n  }\n}\n\ncustomElementsShim.define(\"twisty-3d-canvas\", Twisty3DCanvas);\n", "import {\n  assertIsUnit,\n  assertMatchesType,\n  isUnit,\n  matchesAlgType,\n} from \"./algorithm/alg-part\";\n\nimport {\n  AlgPart,\n  BlockMove,\n  Comment,\n  Commutator,\n  Conjugate,\n  Group,\n  NewLine,\n  Pause,\n  Sequence,\n  Unit,\n  WithAmount,\n} from \"./algorithm\";\n\nfunction dispatch<DataDown, DataUp>(\n  t: TraversalDownUp<DataDown, DataUp>,\n  algPart: AlgPart,\n  dataDown: DataDown,\n): DataUp {\n  switch (algPart.type) {\n    case \"sequence\":\n      assertMatchesType(algPart, \"sequence\");\n      return t.traverseSequence(algPart as Sequence, dataDown);\n    case \"group\":\n      assertMatchesType(algPart, \"group\");\n      return t.traverseGroup(algPart as Group, dataDown);\n    case \"blockMove\":\n      assertMatchesType(algPart, \"blockMove\");\n      return t.traverseBlockMove(algPart as BlockMove, dataDown);\n    case \"commutator\":\n      assertMatchesType(algPart, \"commutator\");\n      return t.traverseCommutator(algPart as Commutator, dataDown);\n    case \"conjugate\":\n      assertMatchesType(algPart, \"conjugate\");\n      return t.traverseConjugate(algPart as Conjugate, dataDown);\n    case \"pause\":\n      assertMatchesType(algPart, \"pause\");\n      return t.traversePause(algPart as Pause, dataDown);\n    case \"newLine\":\n      assertMatchesType(algPart, \"newLine\");\n      return t.traverseNewLine(algPart as NewLine, dataDown);\n    case \"comment\":\n      assertMatchesType(algPart, \"comment\");\n      return t.traverseComment(algPart as Comment, dataDown);\n    default:\n      throw new Error(`Unknown AlgPart type: ${algPart.type}`);\n  }\n}\n\nexport abstract class TraversalDownUp<DataDown, DataUp> {\n  // Immediate subclasses should overwrite this.\n  public traverse(algPart: AlgPart, dataDown: DataDown): DataUp {\n    return dispatch(this, algPart, dataDown);\n  }\n\n  public traverseIntoUnit(algPart: AlgPart, dataDown: DataDown): Unit {\n    return assertIsUnit(this.traverse(algPart, dataDown) as any);\n  }\n\n  public abstract traverseSequence(\n    sequence: Sequence,\n    dataDown: DataDown,\n  ): DataUp;\n\n  public abstract traverseGroup(group: Group, dataDown: DataDown): DataUp;\n  public abstract traverseBlockMove(\n    blockMove: BlockMove,\n    dataDown: DataDown,\n  ): DataUp;\n\n  public abstract traverseCommutator(\n    commutator: Commutator,\n    dataDown: DataDown,\n  ): DataUp;\n\n  public abstract traverseConjugate(\n    conjugate: Conjugate,\n    dataDown: DataDown,\n  ): DataUp;\n\n  public abstract traversePause(pause: Pause, dataDown: DataDown): DataUp;\n  public abstract traverseNewLine(newLine: NewLine, dataDown: DataDown): DataUp;\n  public abstract traverseComment(comment: Comment, dataDown: DataDown): DataUp;\n}\n\nexport abstract class TraversalUp<DataUp> extends TraversalDownUp<\n  undefined,\n  DataUp\n> {\n  public traverse(algPart: AlgPart): DataUp {\n    return dispatch<undefined, DataUp>(this, algPart, undefined);\n  }\n\n  public traverseIntoUnit(algPart: AlgPart): Unit {\n    return assertIsUnit(this.traverse(algPart) as any);\n  }\n\n  public abstract traverseSequence(sequence: Sequence): DataUp;\n  public abstract traverseGroup(group: Group): DataUp;\n  public abstract traverseBlockMove(blockMove: BlockMove): DataUp;\n  public abstract traverseCommutator(commutator: Commutator): DataUp;\n  public abstract traverseConjugate(conjugate: Conjugate): DataUp;\n  public abstract traversePause(pause: Pause): DataUp;\n  public abstract traverseNewLine(newLine: NewLine): DataUp;\n  public abstract traverseComment(comment: Comment): DataUp;\n}\n\n// TODO: Test that inverses are bijections.\nexport class Invert extends TraversalUp<AlgPart> {\n  public traverseSequence(sequence: Sequence): Sequence {\n    // TODO: Handle newLines and comments correctly\n    return new Sequence(\n      sequence.nestedUnits.map((a) => this.traverseIntoUnit(a)).reverse(),\n    );\n  }\n\n  public traverseGroup(group: Group): AlgPart {\n    return new Group(this.traverseSequence(group.nestedSequence), group.amount);\n  }\n\n  public traverseBlockMove(blockMove: BlockMove): AlgPart {\n    return new BlockMove(\n      blockMove.outerLayer,\n      blockMove.innerLayer,\n      blockMove.family,\n      -blockMove.amount,\n    );\n  }\n\n  public traverseCommutator(commutator: Commutator): AlgPart {\n    return new Commutator(commutator.B, commutator.A, commutator.amount);\n  }\n\n  public traverseConjugate(conjugate: Conjugate): AlgPart {\n    return new Conjugate(\n      conjugate.A,\n      this.traverseSequence(conjugate.B),\n      conjugate.amount,\n    );\n  }\n\n  public traversePause(pause: Pause): AlgPart {\n    return pause;\n  }\n\n  public traverseNewLine(newLine: NewLine): AlgPart {\n    return newLine;\n  }\n\n  public traverseComment(comment: Comment): AlgPart {\n    return comment;\n  }\n}\n\nexport class Expand extends TraversalUp<AlgPart> {\n  public traverseSequence(sequence: Sequence): Sequence {\n    return new Sequence(\n      this.flattenSequenceOneLevel(\n        sequence.nestedUnits.map((a) => this.traverse(a)),\n      ),\n    );\n  }\n\n  public traverseGroup(group: Group): AlgPart {\n    // TODO: Pass raw AlgPart[] to sequence.\n    return this.repeat(\n      this.flattenSequenceOneLevel([this.traverse(group.nestedSequence)]),\n      group,\n    );\n  }\n\n  public traverseBlockMove(blockMove: BlockMove): AlgPart {\n    return blockMove;\n  }\n\n  public traverseCommutator(commutator: Commutator): AlgPart {\n    const expandedA = this.traverseSequence(commutator.A);\n    const expandedB = this.traverseSequence(commutator.B);\n    let once: AlgPart[] = [];\n    once = once.concat(\n      expandedA,\n      expandedB,\n      invert(expandedA),\n      invert(expandedB),\n    );\n    return this.repeat(this.flattenSequenceOneLevel(once), commutator);\n  }\n\n  public traverseConjugate(conjugate: Conjugate): AlgPart {\n    const expandedA = this.traverseSequence(conjugate.A);\n    const expandedB = this.traverseSequence(conjugate.B);\n    let once: AlgPart[] = [];\n    once = once.concat(expandedA, expandedB, invert(expandedA));\n    return this.repeat(this.flattenSequenceOneLevel(once), conjugate);\n  }\n\n  public traversePause(pause: Pause): AlgPart {\n    return pause;\n  }\n\n  public traverseNewLine(newLine: NewLine): AlgPart {\n    return newLine;\n  }\n\n  public traverseComment(comment: Comment): AlgPart {\n    return comment;\n  }\n\n  private flattenSequenceOneLevel(algList: AlgPart[]): Unit[] {\n    let flattened: Unit[] = [];\n    for (const part of algList) {\n      if (matchesAlgType(part, \"sequence\")) {\n        flattened = flattened.concat((part as Sequence).nestedUnits);\n      } else if (isUnit(part)) {\n        flattened.push(part);\n      } else {\n        throw new Error(\n          \"expand() encountered an internal error. Did you pass in a valid Algorithm?\",\n        );\n      }\n    }\n    return flattened;\n  }\n\n  private repeat(algList: Unit[], accordingTo: WithAmount): Sequence {\n    const amount = Math.abs(accordingTo.amount);\n    const amountDir = accordingTo.amount > 0 ? 1 : -1; // Mutable\n\n    // TODO: Cleaner inversion\n    let once: Unit[];\n    if (amountDir === -1) {\n      // TODO: Avoid casting to sequence.\n      once = (invert(new Sequence(algList)) as Sequence).nestedUnits;\n    } else {\n      once = algList;\n    }\n\n    let repeated: Unit[] = [];\n    for (let i = 0; i < amount; i++) {\n      repeated = repeated.concat(once);\n    }\n\n    return new Sequence(repeated);\n  }\n}\n\nexport class StructureEquals extends TraversalDownUp<AlgPart, boolean> {\n  public traverseSequence(sequence: Sequence, dataDown: AlgPart): boolean {\n    if (isUnit(dataDown)) {\n      return false;\n    }\n    const dataDownSeq = dataDown as Sequence;\n    if (sequence.nestedUnits.length !== dataDownSeq.nestedUnits.length) {\n      return false;\n    }\n    for (let i = 0; i < sequence.nestedUnits.length; i++) {\n      if (!this.traverse(sequence.nestedUnits[i], dataDownSeq.nestedUnits[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  public traverseGroup(group: Group, dataDown: AlgPart): boolean {\n    return (\n      matchesAlgType(dataDown, \"group\") &&\n      this.traverse(group.nestedSequence, (dataDown as Group).nestedSequence)\n    );\n  }\n\n  public traverseBlockMove(blockMove: BlockMove, dataDown: AlgPart): boolean {\n    // TODO: Handle layers.\n    return (\n      matchesAlgType(dataDown, \"blockMove\") &&\n      blockMove.outerLayer === (dataDown as BlockMove).outerLayer &&\n      blockMove.innerLayer === (dataDown as BlockMove).innerLayer &&\n      blockMove.family === (dataDown as BlockMove).family &&\n      blockMove.amount === (dataDown as BlockMove).amount\n    );\n  }\n\n  public traverseCommutator(\n    commutator: Commutator,\n    dataDown: AlgPart,\n  ): boolean {\n    return (\n      matchesAlgType(dataDown, \"commutator\") &&\n      this.traverse(commutator.A, (dataDown as Commutator).A) &&\n      this.traverse(commutator.B, (dataDown as Commutator).B)\n    );\n  }\n\n  public traverseConjugate(conjugate: Conjugate, dataDown: AlgPart): boolean {\n    return (\n      matchesAlgType(dataDown, \"conjugate\") &&\n      this.traverse(conjugate.A, (dataDown as Conjugate).A) &&\n      this.traverse(conjugate.B, (dataDown as Conjugate).B)\n    );\n  }\n\n  public traversePause(_pause: Pause, dataDown: AlgPart): boolean {\n    return matchesAlgType(dataDown, \"pause\");\n  }\n\n  public traverseNewLine(_newLine: NewLine, dataDown: AlgPart): boolean {\n    return matchesAlgType(dataDown, \"newLine\");\n  }\n\n  public traverseComment(comment: Comment, dataDown: AlgPart): boolean {\n    return (\n      matchesAlgType(dataDown, \"comment\") &&\n      comment.comment === (dataDown as Comment).comment\n    );\n  }\n}\n\n// TODO: Test that inverses are bijections.\nexport class CoalesceBaseMoves extends TraversalUp<AlgPart> {\n  // TODO: Handle\n  public traverseSequence(sequence: Sequence): Sequence {\n    const coalesced: Unit[] = [];\n    for (const part of sequence.nestedUnits) {\n      if (!matchesAlgType(part, \"blockMove\")) {\n        coalesced.push(this.traverseIntoUnit(part));\n      } else if (coalesced.length > 0) {\n        const last = coalesced[coalesced.length - 1];\n        if (\n          matchesAlgType(last, \"blockMove\") &&\n          this.sameBlock(last as BlockMove, part as BlockMove)\n        ) {\n          // TODO: This is cube-specific. Perhaps pass the modules as DataDown?\n          const amount =\n            (last as BlockMove).amount + (part as BlockMove).amount;\n          coalesced.pop();\n          if (amount !== 0) {\n            // We could modify the last element instead of creating a new one,\n            // but this is safe against shifting coding practices.\n            // TODO: Figure out if the shoot-in-the-foot risk\n            // modification is worth the speed.\n            coalesced.push(\n              new BlockMove(\n                (part as BlockMove).outerLayer,\n                (part as BlockMove).innerLayer,\n                (part as BlockMove).family,\n                amount,\n              ),\n            );\n          }\n        } else {\n          coalesced.push(part);\n        }\n      } else {\n        coalesced.push(part);\n      }\n    }\n    return new Sequence(coalesced);\n  }\n\n  public traverseGroup(group: Group): AlgPart {\n    return group;\n  }\n\n  public traverseBlockMove(blockMove: BlockMove): AlgPart {\n    return blockMove;\n  }\n\n  public traverseCommutator(commutator: Commutator): AlgPart {\n    return commutator;\n  }\n\n  public traverseConjugate(conjugate: Conjugate): AlgPart {\n    return conjugate;\n  }\n\n  public traversePause(pause: Pause): AlgPart {\n    return pause;\n  }\n\n  public traverseNewLine(newLine: NewLine): AlgPart {\n    return newLine;\n  }\n\n  public traverseComment(comment: Comment): AlgPart {\n    return comment;\n  }\n\n  private sameBlock(moveA: BlockMove, moveB: BlockMove): boolean {\n    // TODO: Handle layers\n    return (\n      moveA.outerLayer === moveB.outerLayer &&\n      moveA.innerLayer === moveB.innerLayer &&\n      moveA.family === moveB.family\n    );\n  }\n}\n\n// export class Concat extends TraversalDownUp<Algorithm, Sequence> {\n//   private concatIntoSequence(A: Unit[], B: Algorithm): Sequence {\n//     var nestedAlgs: Unit[] = A.slice();\n//     if (matchesAlgType(B, \"sequence\")) {\n//       nestedAlgs = nestedAlgs.concat((B as unknown as Sequence).nestedUnits)\n//     } else {\n//       nestedAlgs.push(B as unknown as Unit);\n//     }\n//     return new Sequence(nestedAlgs)\n//   }\n//   public traverseSequence(     sequence:     Sequence,     dataDown: Algorithm): Sequence {return this.concatIntoSequence(sequence.nestedUnits, dataDown); }\n//   public traverseGroup(        group:        Group,        dataDown: Algorithm): Sequence {return this.concatIntoSequence([group]          , dataDown); }\n//   public traverseBlockMove(    BlockMove:    BlockMove,    dataDown: Algorithm): Sequence {return this.concatIntoSequence([BlockMove]      , dataDown); }\n//   public traverseCommutator(   commutator:   Commutator,   dataDown: Algorithm): Sequence {return this.concatIntoSequence([commutator]     , dataDown); }\n//   public traverseConjugate(    conjugate:    Conjugate,    dataDown: Algorithm): Sequence {return this.concatIntoSequence([conjugate]      , dataDown); }\n//   public traversePause(        pause:        Pause,        dataDown: Algorithm): Sequence {return this.concatIntoSequence([pause]          , dataDown); }\n//   public traverseNewLine(      newLine:      NewLine,      dataDown: Algorithm): Sequence {return this.concatIntoSequence([newLine]        , dataDown); }\n//   public traverseComment( comment: Comment, dataDown: Algorithm): Sequence {return this.concatIntoSequence([comment]   , dataDown); }\n// }\n\nfunction repetitionSuffix(amount: number): string {\n  const absAmount = Math.abs(amount);\n  let s = \"\";\n  if (absAmount !== 1) {\n    s += String(absAmount);\n  }\n  if (absAmount !== amount) {\n    s += \"'\";\n  }\n  return s;\n}\nexport function blockMoveToString(blockMove: BlockMove): string {\n  let out = blockMove.family + repetitionSuffix(blockMove.amount);\n  if (typeof blockMove.innerLayer !== \"undefined\") {\n    out = String(blockMove.innerLayer) + out;\n    if (typeof blockMove.outerLayer !== \"undefined\") {\n      out = String(blockMove.outerLayer) + \"-\" + out;\n    }\n  }\n  return out;\n}\n\nexport class ToString extends TraversalUp<string> {\n  public traverseSequence(sequence: Sequence): string {\n    let output = \"\";\n    if (sequence.nestedUnits.length > 0) {\n      output += this.traverse(sequence.nestedUnits[0]);\n      for (let i = 1; i < sequence.nestedUnits.length; i++) {\n        output += this.spaceBetween(\n          sequence.nestedUnits[i - 1],\n          sequence.nestedUnits[i],\n        );\n        output += this.traverse(sequence.nestedUnits[i]);\n      }\n    }\n    return output;\n  }\n\n  public traverseGroup(group: Group): string {\n    return (\n      \"(\" +\n      this.traverse(group.nestedSequence) +\n      \")\" +\n      repetitionSuffix(group.amount)\n    );\n  }\n\n  public traverseBlockMove(blockMove: BlockMove): string {\n    return blockMoveToString(blockMove);\n  }\n\n  public traverseCommutator(commutator: Commutator): string {\n    return (\n      \"[\" +\n      this.traverse(commutator.A) +\n      \", \" +\n      this.traverse(commutator.B) +\n      \"]\" +\n      repetitionSuffix(commutator.amount)\n    );\n  }\n\n  public traverseConjugate(conjugate: Conjugate): string {\n    return (\n      \"[\" +\n      this.traverse(conjugate.A) +\n      \": \" +\n      this.traverse(conjugate.B) +\n      \"]\" +\n      repetitionSuffix(conjugate.amount)\n    );\n  }\n\n  // TODO: Remove spaces between repeated pauses (in traverseSequence)\n  public traversePause(_pause: Pause): string {\n    return \".\";\n  }\n\n  public traverseNewLine(_newLine: NewLine): string {\n    return \"\\n\";\n  }\n\n  // TODO: Enforce being followed by a newline (or the end of the alg)?\n  public traverseComment(comment: Comment): string {\n    return \"//\" + comment.comment;\n  }\n\n  // TODO: Sanitize `*/`\n  private spaceBetween(u1: Unit, u2: Unit): string {\n    if (matchesAlgType(u1, \"pause\") && matchesAlgType(u2, \"pause\")) {\n      return \"\";\n    }\n    if (matchesAlgType(u1, \"newLine\") || matchesAlgType(u2, \"newLine\")) {\n      return \"\";\n    }\n    if (matchesAlgType(u1, \"comment\") && !matchesAlgType(u2, \"newLine\")) {\n      return \"\\n\";\n    }\n    return \" \";\n  }\n}\n\nconst invertInstance = new Invert();\nconst expandInstance = new Expand();\nconst structureEqualsInstance = new StructureEquals();\nconst coalesceBaseMovesInstance = new CoalesceBaseMoves();\nconst algToStringInstance = new ToString();\n\nexport const invert = invertInstance.traverseSequence.bind(invertInstance) as (\n  a: Sequence,\n) => Sequence;\nexport const expand = expandInstance.traverseSequence.bind(expandInstance) as (\n  a: Sequence,\n) => Sequence;\nexport const structureEquals = structureEqualsInstance.traverseSequence.bind(\n  structureEqualsInstance,\n) as (a1: Sequence, a2: Sequence) => boolean;\nexport const coalesceBaseMoves = coalesceBaseMovesInstance.traverseSequence.bind(\n  coalesceBaseMovesInstance,\n) as (a: Sequence) => Sequence;\nexport const algToString = algToStringInstance.traverseSequence.bind(\n  algToStringInstance,\n) as (a: Sequence) => string;\n\nexport const algPartStructureEqualsForTesting = algToStringInstance.traverse.bind(\n  algToStringInstance,\n) as (a1: AlgPart, a2: AlgPart) => boolean;\nexport const algPartToStringForTesting = algToStringInstance.traverse.bind(\n  algToStringInstance,\n) as (a: AlgPart) => string;\n\nexport function experimentalBlockMoveQuantumName(move: BlockMove): string {\n  return algPartToStringForTesting(\n    new BlockMove(move.outerLayer, move.innerLayer, move.family, 1),\n  );\n}\n", "import {\n  BlockMove,\n  Commutator,\n  Conjugate,\n  Pause,\n  Group,\n  NewLine,\n  Comment,\n  Sequence,\n  TraversalUp,\n} from \"../../src/alg/index\";\n\n/*\n *   For movecount, that understands puzzle rotations.  This code\n *   should be moved to the alg class, probably.\n */\nclass MoveCounter extends TraversalUp<number> {\n  constructor(private metric: (move: BlockMove) => number) {\n    super();\n  }\n\n  public traverseSequence(sequence: Sequence): number {\n    let r = 0;\n    for (let i = 0; i < sequence.nestedUnits.length; i++) {\n      r += this.traverse(sequence.nestedUnits[i]);\n    }\n    return r;\n  }\n\n  public traverseGroup(group: Group): number {\n    return this.traverse(group.nestedSequence) * Math.abs(group.amount);\n  }\n\n  public traverseBlockMove(move: BlockMove): number {\n    return this.metric(move);\n  }\n\n  public traverseCommutator(commutator: Commutator): number {\n    return (\n      Math.abs(commutator.amount) *\n      2 *\n      (this.traverse(commutator.A) + this.traverse(commutator.B))\n    );\n  }\n\n  public traverseConjugate(conjugate: Conjugate): number {\n    return (\n      Math.abs(conjugate.amount) *\n      (2 * this.traverse(conjugate.A) + this.traverse(conjugate.B))\n    );\n  }\n\n  // TODO: Remove spaces between repeated pauses (in traverseSequence)\n  public traversePause(_pause: Pause): number {\n    return 0;\n  }\n\n  public traverseNewLine(_newLine: NewLine): number {\n    return 0;\n  }\n\n  // TODO: Enforce being followed by a newline (or the end of the alg)?\n  public traverseComment(_comment: Comment): number {\n    return 0;\n  }\n}\n\nfunction isCharUppercase(c: string): boolean {\n  return \"A\" <= c && c <= \"Z\";\n}\n\nfunction baseMetric(move: BlockMove): number {\n  const fam = move.family;\n  if (\n    (isCharUppercase(fam[0]) && fam[fam.length - 1] === \"v\") ||\n    fam === \"x\" ||\n    fam === \"y\" ||\n    fam === \"z\"\n  ) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\nconst baseCounter = new MoveCounter(baseMetric);\nexport const countMoves = baseCounter.traverse.bind(baseCounter);\n", "import {\n  BackSide,\n  BoxGeometry,\n  DoubleSide,\n  Euler,\n  Group,\n  Matrix4,\n  Mesh,\n  MeshBasicMaterial,\n  Object3D,\n  PlaneGeometry,\n  Quaternion,\n  Vector3,\n} from \"three\";\nimport { BlockMove } from \"../../../alg\";\nimport { Puzzles, Transformation } from \"../../../kpuzzle\";\nimport { AlgCursor } from \"../../animation/alg/AlgCursor\";\nimport { PuzzlePosition } from \"../../animation/alg/CursorTypes\";\nimport { smootherStep } from \"../../animation/easing\";\nimport {\n  ExperimentalStickering,\n  experimentalStickerings,\n  HintFaceletStyle,\n  hintFaceletStyles,\n} from \"../../dom/TwistyPlayerConfig\";\nimport { TAU } from \"../TAU\";\nimport { FaceletMeshAppearance, PuzzleAppearance } from \"./appearance\";\nimport { stickerings } from \"./stickerings\";\nimport { Twisty3DPuzzle } from \"./Twisty3DPuzzle\";\n\nconst ignoredMaterial = new MeshBasicMaterial({\n  color: 0x444444,\n  side: DoubleSide,\n});\n\nconst ignoredMaterialHint = new MeshBasicMaterial({\n  color: 0xcccccc,\n  side: BackSide,\n});\n\nconst invisibleMaterial = new MeshBasicMaterial({\n  visible: false,\n});\n\nconst orientedMaterial = new MeshBasicMaterial({\n  color: 0xff88ff,\n});\n\nconst orientedMaterialHint = new MeshBasicMaterial({\n  color: 0xff88ff,\n  side: BackSide,\n});\n\ninterface MaterialMap extends Record<FaceletMeshAppearance, MeshBasicMaterial> {\n  regular: MeshBasicMaterial;\n  dim: MeshBasicMaterial;\n  ignored: MeshBasicMaterial;\n  invisible: MeshBasicMaterial;\n}\n\nclass AxisInfo {\n  public stickerMaterial: MaterialMap;\n  public hintStickerMaterial: MaterialMap;\n  constructor(\n    public vector: Vector3,\n    public fromZ: Euler,\n    public color: number,\n    public dimColor: number,\n  ) {\n    // TODO: Make sticker material single-sided when cubie foundation is opaque?\n    this.stickerMaterial = {\n      regular: new MeshBasicMaterial({\n        color,\n        side: DoubleSide,\n      }),\n      dim: new MeshBasicMaterial({\n        color: dimColor,\n        side: DoubleSide,\n      }),\n      oriented: orientedMaterial,\n      ignored: ignoredMaterial,\n      invisible: invisibleMaterial,\n    };\n    this.hintStickerMaterial = {\n      regular: new MeshBasicMaterial({\n        color,\n        side: BackSide,\n      }),\n      dim: new MeshBasicMaterial({\n        color: dimColor,\n        side: BackSide,\n        transparent: true,\n        opacity: 0.75,\n      }),\n      oriented: orientedMaterialHint,\n      ignored: ignoredMaterialHint,\n      invisible: invisibleMaterial,\n    };\n  }\n}\n\nconst axesInfo: AxisInfo[] = [\n  new AxisInfo(\n    new Vector3(0, 1, 0),\n    new Euler(-TAU / 4, 0, 0),\n    0xffffff,\n    0xdddddd,\n  ),\n  new AxisInfo(\n    new Vector3(-1, 0, 0),\n    new Euler(0, -TAU / 4, 0),\n    0xff8800,\n    0x884400,\n  ),\n  new AxisInfo(new Vector3(0, 0, 1), new Euler(0, 0, 0), 0x00ff00, 0x008800),\n  new AxisInfo(\n    new Vector3(1, 0, 0),\n    new Euler(0, TAU / 4, 0),\n    0xff0000,\n    0x660000,\n  ),\n  new AxisInfo(\n    new Vector3(0, 0, -1),\n    new Euler(0, TAU / 2, 0),\n    0x0000ff,\n    0x000088,\n  ),\n  new AxisInfo(\n    new Vector3(0, -1, 0),\n    new Euler(TAU / 4, 0, 0),\n    0xffff00,\n    0x888800,\n  ),\n];\n\nconst face: { [s: string]: number } = {\n  U: 0,\n  L: 1,\n  F: 2,\n  R: 3,\n  B: 4,\n  D: 5,\n};\n\nconst familyToAxis: { [s: string]: number } = {\n  U: face.U,\n  u: face.U,\n  y: face.U,\n  L: face.L,\n  l: face.L,\n  M: face.L,\n  F: face.F,\n  f: face.F,\n  S: face.F,\n  z: face.F,\n  R: face.R,\n  r: face.R,\n  x: face.R,\n  B: face.B,\n  b: face.B,\n  D: face.D,\n  d: face.D,\n  E: face.D,\n};\n\nconst cubieDimensions = {\n  stickerWidth: 0.85,\n  stickerElevation: 0.501,\n  foundationWidth: 1,\n  hintStickerElevation: 1.45,\n};\n\ntype OptionKey = \"showMainStickers\" | \"hintFacelets\" | \"showFoundation\";\n\ninterface Cube3DOptions {\n  showMainStickers?: boolean;\n  hintFacelets?: HintFaceletStyle;\n  showFoundation?: boolean; // TODO: better name\n  experimentalStickering?: ExperimentalStickering;\n}\n\nconst cube3DOptionsDefaults: Cube3DOptions = {\n  showMainStickers: true,\n  hintFacelets: \"floating\",\n  showFoundation: true,\n  experimentalStickering: \"full\",\n};\n\n// TODO: Make internal foundation faces one-sided, facing to the outside of the cube.\nconst blackMesh = new MeshBasicMaterial({\n  color: 0x000000,\n  opacity: 0.3,\n  transparent: true,\n});\n\nclass CubieDef {\n  public matrix: Matrix4;\n  public stickerFaces: number[];\n  // stickerFaceNames can be e.g. [\"U\", \"F\", \"R\"], \"UFR\" if every face is a single letter.\n  constructor(\n    public orbit: string,\n    stickerFaceNames: string[] | string,\n    q: Quaternion,\n  ) {\n    const individualStickerFaceNames =\n      typeof stickerFaceNames === \"string\"\n        ? stickerFaceNames.split(\"\")\n        : stickerFaceNames;\n    this.stickerFaces = individualStickerFaceNames.map((s) => face[s]);\n    this.matrix = new Matrix4();\n    this.matrix.setPosition(firstPiecePosition[orbit]);\n    this.matrix.premultiply(new Matrix4().makeRotationFromQuaternion(q));\n  }\n}\n\nfunction t(v: Vector3, t4: number): Quaternion {\n  return new Quaternion().setFromAxisAngle(v, (TAU * t4) / 4);\n}\n\nconst r = {\n  O: new Vector3(0, 0, 0),\n  U: new Vector3(0, -1, 0),\n  L: new Vector3(1, 0, 0),\n  F: new Vector3(0, 0, -1),\n  R: new Vector3(-1, 0, 0),\n  B: new Vector3(0, 0, 1),\n  D: new Vector3(0, 1, 0),\n};\n\ninterface OrbitIndexed<T> {\n  [s: string]: T;\n}\ntype PieceIndexed<T> = OrbitIndexed<T[]>;\n\nconst firstPiecePosition: OrbitIndexed<Vector3> = {\n  EDGES: new Vector3(0, 1, 1),\n  CORNERS: new Vector3(1, 1, 1),\n  CENTERS: new Vector3(0, 1, 0),\n};\nconst orientationRotation: OrbitIndexed<Matrix4[]> = {\n  EDGES: [0, 1].map((i) =>\n    new Matrix4().makeRotationAxis(\n      firstPiecePosition.EDGES.clone().normalize(),\n      (-i * TAU) / 2,\n    ),\n  ),\n  CORNERS: [0, 1, 2].map((i) =>\n    new Matrix4().makeRotationAxis(\n      firstPiecePosition.CORNERS.clone().normalize(),\n      (-i * TAU) / 3,\n    ),\n  ),\n  CENTERS: [0, 1, 2, 3].map((i) =>\n    new Matrix4().makeRotationAxis(\n      firstPiecePosition.CENTERS.clone().normalize(),\n      (-i * TAU) / 4,\n    ),\n  ),\n};\nconst cubieStickerOrder = [face.U, face.F, face.R];\n\nconst pieceDefs: PieceIndexed<CubieDef> = {\n  EDGES: [\n    new CubieDef(\"EDGES\", \"UF\", t(r.O, 0)),\n    new CubieDef(\"EDGES\", \"UR\", t(r.U, 3)),\n    new CubieDef(\"EDGES\", \"UB\", t(r.U, 2)),\n    new CubieDef(\"EDGES\", \"UL\", t(r.U, 1)),\n    new CubieDef(\"EDGES\", \"DF\", t(r.F, 2)),\n    new CubieDef(\"EDGES\", \"DR\", t(r.F, 2).premultiply(t(r.D, 1))),\n    new CubieDef(\"EDGES\", \"DB\", t(r.F, 2).premultiply(t(r.D, 2))),\n    new CubieDef(\"EDGES\", \"DL\", t(r.F, 2).premultiply(t(r.D, 3))),\n    new CubieDef(\"EDGES\", \"FR\", t(r.U, 3).premultiply(t(r.R, 3))),\n    new CubieDef(\"EDGES\", \"FL\", t(r.U, 1).premultiply(t(r.R, 3))),\n    new CubieDef(\"EDGES\", \"BR\", t(r.U, 3).premultiply(t(r.R, 1))),\n    new CubieDef(\"EDGES\", \"BL\", t(r.U, 1).premultiply(t(r.R, 1))),\n  ],\n  CORNERS: [\n    new CubieDef(\"CORNERS\", \"UFR\", t(r.O, 0)),\n    new CubieDef(\"CORNERS\", \"URB\", t(r.U, 3)),\n    new CubieDef(\"CORNERS\", \"UBL\", t(r.U, 2)),\n    new CubieDef(\"CORNERS\", \"ULF\", t(r.U, 1)),\n    new CubieDef(\"CORNERS\", \"DRF\", t(r.F, 2).premultiply(t(r.D, 1))),\n    new CubieDef(\"CORNERS\", \"DFL\", t(r.F, 2).premultiply(t(r.D, 0))),\n    new CubieDef(\"CORNERS\", \"DLB\", t(r.F, 2).premultiply(t(r.D, 3))),\n    new CubieDef(\"CORNERS\", \"DBR\", t(r.F, 2).premultiply(t(r.D, 2))),\n  ],\n  CENTERS: [\n    new CubieDef(\"CENTERS\", \"U\", t(r.O, 0)),\n    new CubieDef(\"CENTERS\", \"L\", t(r.R, 3).premultiply(t(r.U, 1))),\n    new CubieDef(\"CENTERS\", \"F\", t(r.R, 3)),\n    new CubieDef(\"CENTERS\", \"R\", t(r.R, 3).premultiply(t(r.D, 1))),\n    new CubieDef(\"CENTERS\", \"B\", t(r.R, 3).premultiply(t(r.D, 2))),\n    new CubieDef(\"CENTERS\", \"D\", t(r.R, 2)),\n  ],\n};\n\nconst CUBE_SCALE = 1 / 3;\n\ninterface FaceletInfo {\n  faceIdx: number;\n  facelet: Mesh;\n  hintFacelet?: Mesh;\n}\n\n// TODO: Split into \"scene model\" and \"view\".\nexport class Cube3D extends Object3D implements Twisty3DPuzzle {\n  kpuzzleFaceletInfo: Record<string, FaceletInfo[][]>;\n  private pieces: PieceIndexed<Object3D> = {};\n  private options: Cube3DOptions;\n  // TODO: Keep track of option-based meshes better.\n  private experimentalHintStickerMeshes: Mesh[] = [];\n  private experimentalFoundationMeshes: Mesh[] = [];\n  constructor(\n    cursor?: AlgCursor,\n    private scheduleRenderCallback?: () => void,\n    options: Cube3DOptions = {},\n  ) {\n    super();\n\n    const def = Puzzles[\"3x3x3\"];\n\n    this.options = {};\n    for (const key in cube3DOptionsDefaults) {\n      // TODO:Don't use `any`.\n      this.options[key as OptionKey] =\n        key in options\n          ? (options as any)[key]\n          : (cube3DOptionsDefaults as any)[key];\n    }\n\n    if (def.name !== \"3x3x3\") {\n      throw new Error(\"Invalid puzzle for this Cube3D implementation.\");\n    }\n    this.kpuzzleFaceletInfo = {};\n    for (const orbit in pieceDefs) {\n      const orbitFaceletInfo: FaceletInfo[][] = [];\n      this.kpuzzleFaceletInfo[orbit] = orbitFaceletInfo;\n      this.pieces[orbit] = pieceDefs[orbit].map(\n        this.createCubie.bind(this, orbitFaceletInfo),\n      );\n    }\n    this.scale.set(CUBE_SCALE, CUBE_SCALE, CUBE_SCALE);\n\n    // TODO: Can we construct this directly instead of applying it later? Would that be more code-efficient?\n    if (options.experimentalStickering) {\n      this.setAppearance(stickerings[options.experimentalStickering]);\n    }\n\n    cursor!.addPositionListener(this);\n  }\n\n  setAppearance(appearance: PuzzleAppearance): void {\n    for (const [orbitName, orbitAppearance] of Object.entries(\n      appearance.orbits,\n    )) {\n      for (\n        let pieceIdx = 0;\n        pieceIdx < orbitAppearance.pieces.length;\n        pieceIdx++\n      ) {\n        const pieceAppearance = orbitAppearance.pieces[pieceIdx];\n        if (pieceAppearance) {\n          const pieceInfo = this.kpuzzleFaceletInfo[orbitName][pieceIdx];\n          for (\n            let faceletIdx = 0;\n            faceletIdx < pieceInfo.length;\n            faceletIdx++\n          ) {\n            const faceletAppearance = pieceAppearance.facelets[faceletIdx];\n            if (faceletAppearance) {\n              const faceletInfo = pieceInfo[faceletIdx];\n\n              const appearance =\n                typeof faceletAppearance === \"string\"\n                  ? faceletAppearance\n                  : faceletAppearance?.appearance;\n\n              faceletInfo.facelet.material =\n                axesInfo[faceletInfo.faceIdx].stickerMaterial[appearance];\n              // TODO\n              const hintAppearance =\n                typeof faceletAppearance === \"string\"\n                  ? appearance\n                  : faceletAppearance.hintAppearance ?? appearance;\n              if (faceletInfo.hintFacelet) {\n                faceletInfo.hintFacelet.material =\n                  axesInfo[faceletInfo.faceIdx].hintStickerMaterial[\n                    hintAppearance\n                  ];\n              }\n            }\n          }\n        }\n      }\n    }\n    if (this.scheduleRenderCallback) {\n      this.scheduleRenderCallback();\n    }\n  }\n\n  /** @deprecated */\n  public experimentalUpdateOptions(options: Cube3DOptions): void {\n    if (\"showMainStickers\" in options) {\n      throw new Error(\"Unimplemented\");\n    }\n\n    const showFoundation = options.showFoundation;\n    if (\n      typeof showFoundation !== \"undefined\" &&\n      this.options.showFoundation !== showFoundation\n    ) {\n      this.options.showFoundation = showFoundation;\n      for (const foundation of this.experimentalFoundationMeshes) {\n        foundation.visible = showFoundation;\n      }\n    }\n\n    const hintFacelets = options.hintFacelets;\n    if (\n      typeof hintFacelets !== \"undefined\" &&\n      this.options.hintFacelets !== hintFacelets &&\n      hintFaceletStyles[hintFacelets] // TODO: test this\n    ) {\n      this.options.hintFacelets = hintFacelets;\n      for (const hintSticker of this.experimentalHintStickerMeshes) {\n        hintSticker.visible = hintFacelets === \"floating\";\n      }\n      this.scheduleRenderCallback!(); // TODO\n    }\n\n    const experimentalStickering = options.experimentalStickering;\n    if (\n      typeof experimentalStickering !== \"undefined\" &&\n      this.options.experimentalStickering !== experimentalStickering &&\n      experimentalStickerings[experimentalStickering] // TODO: test this\n    ) {\n      this.options.experimentalStickering = experimentalStickering;\n      this.setAppearance(stickerings[experimentalStickering]);\n      this.scheduleRenderCallback!(); // TODO\n    }\n  }\n\n  public onPositionChange(p: PuzzlePosition): void {\n    const reid333 = p.state as Transformation;\n    for (const orbit in pieceDefs) {\n      const pieces = pieceDefs[orbit];\n      for (let i = 0; i < pieces.length; i++) {\n        const j = reid333[orbit].permutation[i];\n        this.pieces[orbit][j].matrix.copy(pieceDefs[orbit][i].matrix);\n        this.pieces[orbit][j].matrix.multiply(\n          orientationRotation[orbit][reid333[orbit].orientation[i]],\n        );\n      }\n      for (const moveProgress of p.movesInProgress) {\n        const blockMove = moveProgress.move as BlockMove;\n        const turnNormal = axesInfo[familyToAxis[blockMove.family]].vector;\n        const moveMatrix = new Matrix4().makeRotationAxis(\n          turnNormal,\n          (-this.ease(moveProgress.fraction) *\n            moveProgress.direction *\n            blockMove.amount *\n            TAU) /\n            4,\n        );\n        for (let i = 0; i < pieces.length; i++) {\n          const k =\n            Puzzles[\"3x3x3\"].moves[blockMove.family][orbit].permutation[i];\n          if (\n            i !== k ||\n            Puzzles[\"3x3x3\"].moves[blockMove.family][orbit].orientation[i] !== 0\n          ) {\n            const j = reid333[orbit].permutation[i];\n            this.pieces[orbit][j].matrix.premultiply(moveMatrix);\n          }\n        }\n      }\n    }\n    this.scheduleRenderCallback!();\n  }\n\n  // TODO: Always create (but sometimes hide parts) so we can show them later,\n  // or (better) support creating puzzle parts on demand.\n  private createCubie(\n    orbitFacelets: FaceletInfo[][],\n    piece: CubieDef,\n  ): Object3D {\n    const cubieFaceletInfo: FaceletInfo[] = [];\n    orbitFacelets.push(cubieFaceletInfo);\n    const cubie = new Group();\n    if (this.options.showFoundation) {\n      const foundation = this.createCubieFoundation();\n      cubie.add(foundation);\n      this.experimentalFoundationMeshes.push(foundation);\n    }\n    for (let i = 0; i < piece.stickerFaces.length; i++) {\n      const sticker = this.createSticker(\n        axesInfo[cubieStickerOrder[i]],\n        axesInfo[piece.stickerFaces[i]],\n        false,\n      );\n      const faceletInfo: FaceletInfo = {\n        faceIdx: piece.stickerFaces[i],\n        facelet: sticker,\n      };\n      cubie.add(sticker);\n      if (this.options.hintFacelets === \"floating\") {\n        const hintSticker = this.createSticker(\n          axesInfo[cubieStickerOrder[i]],\n          axesInfo[piece.stickerFaces[i]],\n          true,\n        );\n        cubie.add(hintSticker);\n        faceletInfo.hintFacelet = hintSticker;\n        this.experimentalHintStickerMeshes.push(hintSticker);\n      }\n\n      cubieFaceletInfo.push(faceletInfo);\n    }\n    cubie.matrix.copy(piece.matrix);\n    cubie.matrixAutoUpdate = false;\n    this.add(cubie);\n    return cubie;\n  }\n\n  // TODO: Support creating only the outward-facing parts?\n  private createCubieFoundation(): Mesh {\n    const box = new BoxGeometry(\n      cubieDimensions.foundationWidth,\n      cubieDimensions.foundationWidth,\n      cubieDimensions.foundationWidth,\n    );\n    return new Mesh(box, blackMesh);\n  }\n\n  private createSticker(\n    posAxisInfo: AxisInfo,\n    materialAxisInfo: AxisInfo,\n    isHint: boolean,\n  ): Mesh {\n    const geo = new PlaneGeometry(\n      cubieDimensions.stickerWidth,\n      cubieDimensions.stickerWidth,\n    );\n    const stickerMesh = new Mesh(\n      geo,\n      isHint\n        ? materialAxisInfo.hintStickerMaterial.regular\n        : materialAxisInfo.stickerMaterial.regular,\n    );\n    stickerMesh.setRotationFromEuler(posAxisInfo.fromZ);\n    stickerMesh.position.copy(posAxisInfo.vector);\n    stickerMesh.position.multiplyScalar(\n      isHint\n        ? cubieDimensions.hintStickerElevation\n        : cubieDimensions.stickerElevation,\n    );\n    return stickerMesh;\n  }\n\n  private ease(fraction: number): number {\n    return smootherStep(fraction);\n  }\n}\n", "export function smootherStep(x: number): number {\n  return x * x * x * (10 - x * (15 - 6 * x));\n}\n", "import { Vector3 } from \"three\";\nimport { Sequence } from \"../../alg\";\nimport {\n  AlgAttribute,\n  StringEnumAttribute,\n  Vector3Attribute,\n} from \"./element/ElementConfig\";\nimport type { TwistyPlayer } from \"./TwistyPlayer\";\nimport { BackViewLayout, backViewLayouts } from \"./viewers/TwistyViewerWrapper\";\n\nconst DEFAULT_CAMERA_Z = 5;\n// Golden ratio is perfect for FTO and Megaminx.\nconst DEFAULT_CAMERA_Y = DEFAULT_CAMERA_Z * (2 / (1 + Math.sqrt(5)));\n\nexport const centeredCameraPosition = new Vector3(\n  0,\n  DEFAULT_CAMERA_Y,\n  DEFAULT_CAMERA_Z,\n);\n\n// TODO\nexport const cubeCameraPosition = new Vector3(3, 4, 5);\n\n// TODO: turn these maps into lists?\nexport const visualizationFormats = {\n  \"3D\": true, // default\n  \"2D\": true,\n  \"PG3D\": true,\n};\nexport type VisualizationFormat = keyof typeof visualizationFormats;\n\nexport const backgroundThemes = {\n  checkered: true, // default\n  none: true,\n};\nexport type BackgroundTheme = keyof typeof backgroundThemes;\n\n// TODO: turn these maps into lists?\nexport const hintFaceletStyles = {\n  floating: true, // default\n  none: true,\n};\nexport type HintFaceletStyle = keyof typeof hintFaceletStyles;\n\n// TODO: turn these maps into lists?\n// TODO: alg.cubing.net parity\nexport const experimentalStickerings = {\n  \"full\": true, // default\n  \"centers-only\": true, // TODO\n  \"PLL\": true,\n  \"CLS\": true,\n  \"OLL\": true,\n  \"ELS\": true,\n  \"LL\": true,\n  \"F2L\": true,\n  \"ZBLL\": true,\n  \"ZBLS\": true,\n  \"WVLS\": true,\n  \"VLS\": true,\n  \"LS\": true,\n  \"EO\": true,\n  \"CMLL\": true,\n  \"L6E\": true,\n  \"L6EO\": true,\n  \"Daisy\": true,\n  \"Cross\": true,\n  \"2x2x2\": true,\n  \"2x2x3\": true,\n  \"Void Cube\": true,\n};\nexport type ExperimentalStickering = keyof typeof experimentalStickerings;\n\nexport const controlsLocations = {\n  \"bottom-row\": true, // default\n  \"none\": true,\n};\nexport type ControlsLocation = keyof typeof controlsLocations;\n\nexport const puzzleIDs = {\n  \"3x3x3\": true, // default\n  \"custom\": true,\n  \"2x2x2\": true,\n  \"4x4x4\": true,\n  \"5x5x5\": true,\n  \"6x6x6\": true,\n  \"7x7x7\": true,\n  \"megaminx\": true,\n  \"pyraminx\": true,\n  \"sq1\": true,\n  \"clock\": true,\n  \"skewb\": true,\n  \"FTO\": true,\n};\nexport type PuzzleID = keyof typeof puzzleIDs;\n\n// TODO: templatize\nexport interface ManagedAttribute<K> {\n  string: string;\n  value: K;\n  setString(s: string): boolean;\n  setValue(v: K): boolean;\n}\n\ntype AnyManagedAttribute = ManagedAttribute<any>;\n\ninterface TwistyPlayerAttributes extends Record<string, AnyManagedAttribute> {\n  // Alg\n  \"alg\": AlgAttribute;\n  \"experimental-start-setup\": AlgAttribute;\n\n  // Puzzle\n  \"puzzle\": StringEnumAttribute<PuzzleID>;\n  \"visualization\": StringEnumAttribute<VisualizationFormat>;\n  \"hint-facelets\": StringEnumAttribute<HintFaceletStyle>;\n  \"experimental-stickering\": StringEnumAttribute<ExperimentalStickering>;\n\n  // Background\n  \"background\": StringEnumAttribute<BackgroundTheme>;\n  \"controls\": StringEnumAttribute<ControlsLocation>;\n\n  // 3D config\n  \"back-view\": StringEnumAttribute<BackViewLayout>;\n  \"camera-position\": Vector3Attribute;\n}\n\nexport interface TwistyPlayerConfigValues {\n  alg: Sequence;\n  experimentalStartSetup: Sequence;\n\n  puzzle: PuzzleID;\n  visualization: VisualizationFormat;\n  hintFacelets: HintFaceletStyle;\n  experimentalStickering: ExperimentalStickering;\n\n  background: BackgroundTheme;\n  controls: ControlsLocation;\n\n  backView: BackViewLayout;\n  cameraPosition: Vector3;\n}\n\nexport type TwistyPlayerInitialConfig = Partial<TwistyPlayerConfigValues>;\n\nconst twistyPlayerAttributeMap: Record<\n  keyof TwistyPlayerAttributes,\n  keyof TwistyPlayerConfigValues\n> = {\n  \"alg\": \"alg\",\n  \"experimental-start-setup\": \"experimentalStartSetup\",\n\n  \"puzzle\": \"puzzle\",\n  \"visualization\": \"visualization\",\n  \"hint-facelets\": \"hintFacelets\",\n  \"experimental-stickering\": \"experimentalStickering\",\n\n  \"background\": \"background\",\n  \"controls\": \"controls\",\n\n  \"back-view\": \"backView\",\n  \"camera-position\": \"cameraPosition\",\n};\n\n// TODO: Can we avoid instantiating a new class for ech attribute, and would it help performance?\nexport class TwistyPlayerConfig {\n  attributes: TwistyPlayerAttributes;\n  constructor(\n    private twistyPlayer: TwistyPlayer, // TODO\n    initialValues: TwistyPlayerInitialConfig,\n  ) {\n    this.attributes = {\n      \"alg\": new AlgAttribute(initialValues.alg),\n      \"experimental-start-setup\": new AlgAttribute(\n        initialValues.experimentalStartSetup,\n      ),\n\n      \"puzzle\": new StringEnumAttribute(puzzleIDs, initialValues.puzzle),\n      \"visualization\": new StringEnumAttribute(\n        visualizationFormats,\n        initialValues.visualization,\n      ),\n      \"hint-facelets\": new StringEnumAttribute(\n        hintFaceletStyles,\n        initialValues.hintFacelets,\n      ),\n      \"experimental-stickering\": new StringEnumAttribute(\n        experimentalStickerings,\n        initialValues.experimentalStickering,\n      ),\n\n      \"background\": new StringEnumAttribute(\n        backgroundThemes,\n        initialValues.background,\n      ),\n      \"controls\": new StringEnumAttribute(\n        controlsLocations,\n        initialValues.controls,\n      ),\n      \"back-view\": new StringEnumAttribute(\n        backViewLayouts,\n        initialValues[\"backView\"],\n      ),\n      \"camera-position\": new Vector3Attribute(\n        null,\n        initialValues[\"cameraPosition\"],\n      ),\n    };\n  }\n\n  static get observedAttributes(): (keyof TwistyPlayerAttributes & string)[] {\n    return Object.keys(twistyPlayerAttributeMap);\n  }\n\n  attributeChangedCallback(\n    attributeName: string,\n    oldValue: string,\n    newValue: string,\n  ): void {\n    const managedAttribute = this.attributes[attributeName];\n    if (managedAttribute) {\n      // TODO: Handle `null` better.\n      if (oldValue !== null && managedAttribute.string !== oldValue) {\n        console.warn(\n          \"Attribute out of sync!\",\n          attributeName,\n          managedAttribute.string,\n          oldValue,\n        );\n      }\n      managedAttribute.setString(newValue);\n\n      // TODO: can we make this type-safe?\n      // TODO: avoid double-setting in recursive calls\n      const propertyName: keyof TwistyPlayerConfigValues =\n        twistyPlayerAttributeMap[attributeName];\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      this.twistyPlayer[propertyName] = managedAttribute.value;\n    }\n  }\n}\n", "// // type ConfigAttributes = Record<string, any>;\n\nimport { Vector3 } from \"three\";\nimport { algToString, parse, Sequence } from \"../../../alg\";\n\nexport class AlgAttribute {\n  string: string;\n  value: Sequence;\n  constructor(initialValue?: Sequence) {\n    this.setValue(initialValue ?? this.defaultValue());\n  }\n\n  // Return value indicates if the attribute changed.\n  setString(str: string): boolean {\n    if (this.string === str) {\n      return false;\n    }\n    this.string = str;\n    this.value = this.toValue(str);\n    return true;\n  }\n\n  // Return value indicates if the attribute changed.\n  setValue(val: Sequence): boolean {\n    const str = this.toString(val);\n    if (this.string === str) {\n      return false;\n    }\n    this.string = str;\n    this.value = val;\n    return true;\n  }\n\n  private defaultValue(): Sequence {\n    return new Sequence([]);\n  }\n\n  private toValue(s: string): Sequence {\n    return parse(s);\n  }\n\n  private toString(s: Sequence): string {\n    return algToString(s);\n  }\n}\n\n// TODO: subset of string rather than `extends`\nexport class StringEnumAttribute<E extends string> {\n  string: string;\n  value: E;\n  valid: boolean;\n  constructor(private enumVal: { [key: string]: boolean }, initialValue?: E) {\n    this.setString(initialValue ?? this.defaultValue());\n  }\n\n  // Return value indicates if the attribute changed.\n  setString(str: string): boolean {\n    if (this.string === str) {\n      return false;\n    }\n    if (!(str in this.enumVal)) {\n      throw new Error(`Invalid string for attribute!: ${str}`);\n    }\n    this.string = str;\n    this.value = this.toValue(str);\n    return true;\n  }\n\n  // Return value indicates if the attribute changed.\n  setValue(val: string): boolean {\n    return this.setString(val);\n  }\n\n  private defaultValue(): string {\n    return Object.keys(this.enumVal)[0]; // TODO\n  }\n\n  private toValue(s: string): E {\n    return s as E;\n  }\n\n  // private toString(s: string): string {\n  //   return s;\n  // }\n}\n\n// TODO: subset of string rather than `extends`\nexport class StringFakeEnumAttribute<E extends string> {\n  string: string;\n  value: E;\n  valid: boolean;\n  constructor(private validStrings: string[], initialValue?: E) {\n    this.setString(initialValue ?? this.defaultValue());\n  }\n\n  // Return value indicates if the attribute changed.\n  setString(str: string): boolean {\n    if (this.string === str) {\n      return false;\n    }\n    if (!this.validStrings.includes(str)) {\n      throw new Error(`Invalid string for attribute!: ${str}`);\n    }\n    this.string = str;\n    this.value = this.toValue(str);\n    return true;\n  }\n\n  // Return value indicates if the attribute changed.\n  setValue(val: string): boolean {\n    return this.setString(val);\n  }\n\n  private defaultValue(): string {\n    return this.validStrings[0];\n  }\n\n  private toValue(s: string): E {\n    return s as E;\n  }\n\n  // private toString(s: string): string {\n  //   return s;\n  // }\n}\n\nexport class Vector3Attribute {\n  string: string;\n  value: Vector3 | null;\n  #defaultValue: Vector3 | null;\n  constructor(defaultValue: Vector3 | null, initialValue?: Vector3 | null) {\n    this.#defaultValue = defaultValue;\n    this.setValue(initialValue ?? this.defaultValue());\n  }\n\n  // Return value indicates if the attribute changed.\n  setString(str: string): boolean {\n    return this.setValue(str === \"\" ? null : this.toValue(str)); // TODO: test empty string\n  }\n\n  // Return value indicates if the attribute changed.\n  setValue(val: Vector3 | null): boolean {\n    const str = this.toString(val);\n    if (this.string === str) {\n      return false;\n    }\n    this.string = str;\n    this.value = val;\n    return true;\n  }\n\n  private defaultValue(): Vector3 | null {\n    return this.#defaultValue;\n  }\n\n  private toValue(s: string): Vector3 | null {\n    if (!s.startsWith(\"[\")) {\n      throw new Error(\"TODO\");\n    }\n    if (!s.endsWith(\"]\")) {\n      throw new Error(\"TODO\");\n    }\n    const coords = s.slice(1, s.length - 1).split(\",\");\n    if (coords.length !== 3) {\n      throw new Error(\"TODO\");\n    }\n    const [x, y, z] = coords.map((c) => parseInt(c, 10));\n    return new Vector3(x, y, z);\n  }\n\n  private toString(v: Vector3 | null): string {\n    return v ? `[${v.x}, ${v.y}, ${v.z}]` : \"\"; // TODO: empty string is not null\n  }\n}\n", "// // type ConfigAttributes = Record<string, any>;\n\nimport { Vector3 } from \"three\";\nimport { algToString, parse, Sequence } from \"../../../alg\";\n\nexport class AlgAttribute {\n  string: string;\n  value: Sequence;\n  constructor(initialValue?: Sequence) {\n    this.setValue(initialValue ?? this.defaultValue());\n  }\n\n  // Return value indicates if the attribute changed.\n  setString(str: string): boolean {\n    if (this.string === str) {\n      return false;\n    }\n    this.string = str;\n    this.value = this.toValue(str);\n    return true;\n  }\n\n  // Return value indicates if the attribute changed.\n  setValue(val: Sequence): boolean {\n    const str = this.toString(val);\n    if (this.string === str) {\n      return false;\n    }\n    this.string = str;\n    this.value = val;\n    return true;\n  }\n\n  private defaultValue(): Sequence {\n    return new Sequence([]);\n  }\n\n  private toValue(s: string): Sequence {\n    return parse(s);\n  }\n\n  private toString(s: Sequence): string {\n    return algToString(s);\n  }\n}\n\n// TODO: subset of string rather than `extends`\nexport class StringEnumAttribute<E extends string> {\n  string: string;\n  value: E;\n  valid: boolean;\n  constructor(private enumVal: { [key: string]: boolean }, initialValue?: E) {\n    this.setString(initialValue ?? this.defaultValue());\n  }\n\n  // Return value indicates if the attribute changed.\n  setString(str: string): boolean {\n    if (this.string === str) {\n      return false;\n    }\n    if (!(str in this.enumVal)) {\n      throw new Error(`Invalid string for attribute!: ${str}`);\n    }\n    this.string = str;\n    this.value = this.toValue(str);\n    return true;\n  }\n\n  // Return value indicates if the attribute changed.\n  setValue(val: string): boolean {\n    return this.setString(val);\n  }\n\n  private defaultValue(): string {\n    return Object.keys(this.enumVal)[0]; // TODO\n  }\n\n  private toValue(s: string): E {\n    return s as E;\n  }\n\n  // private toString(s: string): string {\n  //   return s;\n  // }\n}\n\n// TODO: subset of string rather than `extends`\nexport class StringFakeEnumAttribute<E extends string> {\n  string: string;\n  value: E;\n  valid: boolean;\n  constructor(private validStrings: string[], initialValue?: E) {\n    this.setString(initialValue ?? this.defaultValue());\n  }\n\n  // Return value indicates if the attribute changed.\n  setString(str: string): boolean {\n    if (this.string === str) {\n      return false;\n    }\n    if (!this.validStrings.includes(str)) {\n      throw new Error(`Invalid string for attribute!: ${str}`);\n    }\n    this.string = str;\n    this.value = this.toValue(str);\n    return true;\n  }\n\n  // Return value indicates if the attribute changed.\n  setValue(val: string): boolean {\n    return this.setString(val);\n  }\n\n  private defaultValue(): string {\n    return this.validStrings[0];\n  }\n\n  private toValue(s: string): E {\n    return s as E;\n  }\n\n  // private toString(s: string): string {\n  //   return s;\n  // }\n}\n\nexport class Vector3Attribute {\n  string: string;\n  value: Vector3 | null;\n  #defaultValue: Vector3 | null;\n  constructor(defaultValue: Vector3 | null, initialValue?: Vector3 | null) {\n    this.#defaultValue = defaultValue;\n    this.setValue(initialValue ?? this.defaultValue());\n  }\n\n  // Return value indicates if the attribute changed.\n  setString(str: string): boolean {\n    return this.setValue(str === \"\" ? null : this.toValue(str)); // TODO: test empty string\n  }\n\n  // Return value indicates if the attribute changed.\n  setValue(val: Vector3 | null): boolean {\n    const str = this.toString(val);\n    if (this.string === str) {\n      return false;\n    }\n    this.string = str;\n    this.value = val;\n    return true;\n  }\n\n  private defaultValue(): Vector3 | null {\n    return this.#defaultValue;\n  }\n\n  private toValue(s: string): Vector3 | null {\n    if (!s.startsWith(\"[\")) {\n      throw new Error(\"TODO\");\n    }\n    if (!s.endsWith(\"]\")) {\n      throw new Error(\"TODO\");\n    }\n    const coords = s.slice(1, s.length - 1).split(\",\");\n    if (coords.length !== 3) {\n      throw new Error(\"TODO\");\n    }\n    const [x, y, z] = coords.map((c) => parseInt(c, 10));\n    return new Vector3(x, y, z);\n  }\n\n  private toString(v: Vector3 | null): string {\n    return v ? `[${v.x}, ${v.y}, ${v.z}]` : \"\"; // TODO: empty string is not null\n  }\n}\n", "// // type ConfigAttributes = Record<string, any>;\n\nimport { Vector3 } from \"three\";\nimport { algToString, parse, Sequence } from \"../../../alg\";\n\nexport class AlgAttribute {\n  string: string;\n  value: Sequence;\n  constructor(initialValue?: Sequence) {\n    this.setValue(initialValue ?? this.defaultValue());\n  }\n\n  // Return value indicates if the attribute changed.\n  setString(str: string): boolean {\n    if (this.string === str) {\n      return false;\n    }\n    this.string = str;\n    this.value = this.toValue(str);\n    return true;\n  }\n\n  // Return value indicates if the attribute changed.\n  setValue(val: Sequence): boolean {\n    const str = this.toString(val);\n    if (this.string === str) {\n      return false;\n    }\n    this.string = str;\n    this.value = val;\n    return true;\n  }\n\n  private defaultValue(): Sequence {\n    return new Sequence([]);\n  }\n\n  private toValue(s: string): Sequence {\n    return parse(s);\n  }\n\n  private toString(s: Sequence): string {\n    return algToString(s);\n  }\n}\n\n// TODO: subset of string rather than `extends`\nexport class StringEnumAttribute<E extends string> {\n  string: string;\n  value: E;\n  valid: boolean;\n  constructor(private enumVal: { [key: string]: boolean }, initialValue?: E) {\n    this.setString(initialValue ?? this.defaultValue());\n  }\n\n  // Return value indicates if the attribute changed.\n  setString(str: string): boolean {\n    if (this.string === str) {\n      return false;\n    }\n    if (!(str in this.enumVal)) {\n      throw new Error(`Invalid string for attribute!: ${str}`);\n    }\n    this.string = str;\n    this.value = this.toValue(str);\n    return true;\n  }\n\n  // Return value indicates if the attribute changed.\n  setValue(val: string): boolean {\n    return this.setString(val);\n  }\n\n  private defaultValue(): string {\n    return Object.keys(this.enumVal)[0]; // TODO\n  }\n\n  private toValue(s: string): E {\n    return s as E;\n  }\n\n  // private toString(s: string): string {\n  //   return s;\n  // }\n}\n\n// TODO: subset of string rather than `extends`\nexport class StringFakeEnumAttribute<E extends string> {\n  string: string;\n  value: E;\n  valid: boolean;\n  constructor(private validStrings: string[], initialValue?: E) {\n    this.setString(initialValue ?? this.defaultValue());\n  }\n\n  // Return value indicates if the attribute changed.\n  setString(str: string): boolean {\n    if (this.string === str) {\n      return false;\n    }\n    if (!this.validStrings.includes(str)) {\n      throw new Error(`Invalid string for attribute!: ${str}`);\n    }\n    this.string = str;\n    this.value = this.toValue(str);\n    return true;\n  }\n\n  // Return value indicates if the attribute changed.\n  setValue(val: string): boolean {\n    return this.setString(val);\n  }\n\n  private defaultValue(): string {\n    return this.validStrings[0];\n  }\n\n  private toValue(s: string): E {\n    return s as E;\n  }\n\n  // private toString(s: string): string {\n  //   return s;\n  // }\n}\n\nexport class Vector3Attribute {\n  string: string;\n  value: Vector3 | null;\n  #defaultValue: Vector3 | null;\n  constructor(defaultValue: Vector3 | null, initialValue?: Vector3 | null) {\n    this.#defaultValue = defaultValue;\n    this.setValue(initialValue ?? this.defaultValue());\n  }\n\n  // Return value indicates if the attribute changed.\n  setString(str: string): boolean {\n    return this.setValue(str === \"\" ? null : this.toValue(str)); // TODO: test empty string\n  }\n\n  // Return value indicates if the attribute changed.\n  setValue(val: Vector3 | null): boolean {\n    const str = this.toString(val);\n    if (this.string === str) {\n      return false;\n    }\n    this.string = str;\n    this.value = val;\n    return true;\n  }\n\n  private defaultValue(): Vector3 | null {\n    return this.#defaultValue;\n  }\n\n  private toValue(s: string): Vector3 | null {\n    if (!s.startsWith(\"[\")) {\n      throw new Error(\"TODO\");\n    }\n    if (!s.endsWith(\"]\")) {\n      throw new Error(\"TODO\");\n    }\n    const coords = s.slice(1, s.length - 1).split(\",\");\n    if (coords.length !== 3) {\n      throw new Error(\"TODO\");\n    }\n    const [x, y, z] = coords.map((c) => parseInt(c, 10));\n    return new Vector3(x, y, z);\n  }\n\n  private toString(v: Vector3 | null): string {\n    return v ? `[${v.x}, ${v.y}, ${v.z}]` : \"\"; // TODO: empty string is not null\n  }\n}\n", "import { ManagedCustomElement } from \"./ManagedCustomElement\";\n\nexport class ClassListManager<SuffixType extends string> {\n  #currentClassName: string | null = null;\n  // The prefix should ideally end in a dash.\n  constructor(\n    private elem: ManagedCustomElement,\n    private prefix: string,\n    private validSuffixes: SuffixType[],\n  ) {}\n\n  // Does nothing if there was no value.\n  clearValue(): void {\n    if (this.#currentClassName) {\n      this.elem.contentWrapper.classList.remove(this.#currentClassName);\n    }\n    this.#currentClassName = null; // TODO: add test for this behaviour.\n  }\n\n  // Returns if the value changed\n  setValue(suffix: SuffixType): boolean {\n    if (!this.validSuffixes.includes(suffix)) {\n      throw new Error(`Invalid suffix: ${suffix}`);\n    }\n    const newClassName = `${this.prefix}${suffix}`;\n    const changed = this.#currentClassName !== newClassName;\n    if (changed) {\n      this.clearValue();\n      this.elem.contentWrapper.classList.add(newClassName);\n      this.#currentClassName = newClassName;\n    }\n    return changed;\n  }\n}\n", "import { CSSSource } from \"../element/ManagedCustomElement\";\n\nexport const twistyViewerWrapperCSS = new CSSSource(`\n.wrapper {\n  display: grid;\n  width: 100%;\n  height: 100%;\n  position: relative;\n  overflow: hidden;\n}\n\n.wrapper.back-view-side-by-side {\n  grid-template-columns: 1fr 1fr;\n}\n\n.wrapper > * {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n\n.wrapper.back-view-upper-right > :nth-child(2) {\n  position: absolute;\n  right: 0;\n  top: 0;\n  width: 25%;\n  height: 25%;\n}\n`);\n", "import { ClassListManager } from \"../element/ClassListManager\";\nimport { ManagedCustomElement } from \"../element/ManagedCustomElement\";\nimport { customElementsShim } from \"../element/node-custom-element-shims\";\nimport { twistyViewerWrapperCSS } from \"./TwistyViewerWrapper.css\";\n\nexport const backViewLayouts = {\n  \"none\": true, // default\n  \"side-by-side\": true,\n  \"upper-right\": true,\n};\nexport type BackViewLayout = keyof typeof backViewLayouts;\n\nexport interface TwistyViewerWrapperConfig {\n  backView?: BackViewLayout;\n}\n\nexport class TwistyViewerWrapper extends ManagedCustomElement {\n  #backViewClassListManager: ClassListManager<\n    BackViewLayout\n  > = new ClassListManager(this, \"back-view-\", [\n    \"none\",\n    \"side-by-side\",\n    \"upper-right\",\n  ]);\n\n  constructor(config: TwistyViewerWrapperConfig = {}) {\n    super();\n    this.addCSS(twistyViewerWrapperCSS);\n\n    if (config.backView && config.backView in backViewLayouts) {\n      this.#backViewClassListManager.setValue(config.backView);\n    }\n  }\n\n  // Returns if the value changed\n  /** @deprecated */\n  setBackView(backView: BackViewLayout): boolean {\n    return this.#backViewClassListManager.setValue(backView);\n  }\n}\n\ncustomElementsShim.define(\"twisty-viewer-wrapper\", TwistyViewerWrapper);\n", "import { Vector3 } from \"three\";\nimport { Sequence } from \"../../alg\";\nimport {\n  AlgAttribute,\n  StringEnumAttribute,\n  Vector3Attribute,\n} from \"./element/ElementConfig\";\nimport type { TwistyPlayer } from \"./TwistyPlayer\";\nimport { BackViewLayout, backViewLayouts } from \"./viewers/TwistyViewerWrapper\";\n\nconst DEFAULT_CAMERA_Z = 5;\n// Golden ratio is perfect for FTO and Megaminx.\nconst DEFAULT_CAMERA_Y = DEFAULT_CAMERA_Z * (2 / (1 + Math.sqrt(5)));\n\nexport const centeredCameraPosition = new Vector3(\n  0,\n  DEFAULT_CAMERA_Y,\n  DEFAULT_CAMERA_Z,\n);\n\n// TODO\nexport const cubeCameraPosition = new Vector3(3, 4, 5);\n\n// TODO: turn these maps into lists?\nexport const visualizationFormats = {\n  \"3D\": true, // default\n  \"2D\": true,\n  \"PG3D\": true,\n};\nexport type VisualizationFormat = keyof typeof visualizationFormats;\n\nexport const backgroundThemes = {\n  checkered: true, // default\n  none: true,\n};\nexport type BackgroundTheme = keyof typeof backgroundThemes;\n\n// TODO: turn these maps into lists?\nexport const hintFaceletStyles = {\n  floating: true, // default\n  none: true,\n};\nexport type HintFaceletStyle = keyof typeof hintFaceletStyles;\n\n// TODO: turn these maps into lists?\n// TODO: alg.cubing.net parity\nexport const experimentalStickerings = {\n  \"full\": true, // default\n  \"centers-only\": true, // TODO\n  \"PLL\": true,\n  \"CLS\": true,\n  \"OLL\": true,\n  \"ELS\": true,\n  \"LL\": true,\n  \"F2L\": true,\n  \"ZBLL\": true,\n  \"ZBLS\": true,\n  \"WVLS\": true,\n  \"VLS\": true,\n  \"LS\": true,\n  \"EO\": true,\n  \"CMLL\": true,\n  \"L6E\": true,\n  \"L6EO\": true,\n  \"Daisy\": true,\n  \"Cross\": true,\n  \"2x2x2\": true,\n  \"2x2x3\": true,\n  \"Void Cube\": true,\n};\nexport type ExperimentalStickering = keyof typeof experimentalStickerings;\n\nexport const controlsLocations = {\n  \"bottom-row\": true, // default\n  \"none\": true,\n};\nexport type ControlsLocation = keyof typeof controlsLocations;\n\nexport const puzzleIDs = {\n  \"3x3x3\": true, // default\n  \"custom\": true,\n  \"2x2x2\": true,\n  \"4x4x4\": true,\n  \"5x5x5\": true,\n  \"6x6x6\": true,\n  \"7x7x7\": true,\n  \"megaminx\": true,\n  \"pyraminx\": true,\n  \"sq1\": true,\n  \"clock\": true,\n  \"skewb\": true,\n  \"FTO\": true,\n};\nexport type PuzzleID = keyof typeof puzzleIDs;\n\n// TODO: templatize\nexport interface ManagedAttribute<K> {\n  string: string;\n  value: K;\n  setString(s: string): boolean;\n  setValue(v: K): boolean;\n}\n\ntype AnyManagedAttribute = ManagedAttribute<any>;\n\ninterface TwistyPlayerAttributes extends Record<string, AnyManagedAttribute> {\n  // Alg\n  \"alg\": AlgAttribute;\n  \"experimental-start-setup\": AlgAttribute;\n\n  // Puzzle\n  \"puzzle\": StringEnumAttribute<PuzzleID>;\n  \"visualization\": StringEnumAttribute<VisualizationFormat>;\n  \"hint-facelets\": StringEnumAttribute<HintFaceletStyle>;\n  \"experimental-stickering\": StringEnumAttribute<ExperimentalStickering>;\n\n  // Background\n  \"background\": StringEnumAttribute<BackgroundTheme>;\n  \"controls\": StringEnumAttribute<ControlsLocation>;\n\n  // 3D config\n  \"back-view\": StringEnumAttribute<BackViewLayout>;\n  \"camera-position\": Vector3Attribute;\n}\n\nexport interface TwistyPlayerConfigValues {\n  alg: Sequence;\n  experimentalStartSetup: Sequence;\n\n  puzzle: PuzzleID;\n  visualization: VisualizationFormat;\n  hintFacelets: HintFaceletStyle;\n  experimentalStickering: ExperimentalStickering;\n\n  background: BackgroundTheme;\n  controls: ControlsLocation;\n\n  backView: BackViewLayout;\n  cameraPosition: Vector3;\n}\n\nexport type TwistyPlayerInitialConfig = Partial<TwistyPlayerConfigValues>;\n\nconst twistyPlayerAttributeMap: Record<\n  keyof TwistyPlayerAttributes,\n  keyof TwistyPlayerConfigValues\n> = {\n  \"alg\": \"alg\",\n  \"experimental-start-setup\": \"experimentalStartSetup\",\n\n  \"puzzle\": \"puzzle\",\n  \"visualization\": \"visualization\",\n  \"hint-facelets\": \"hintFacelets\",\n  \"experimental-stickering\": \"experimentalStickering\",\n\n  \"background\": \"background\",\n  \"controls\": \"controls\",\n\n  \"back-view\": \"backView\",\n  \"camera-position\": \"cameraPosition\",\n};\n\n// TODO: Can we avoid instantiating a new class for ech attribute, and would it help performance?\nexport class TwistyPlayerConfig {\n  attributes: TwistyPlayerAttributes;\n  constructor(\n    private twistyPlayer: TwistyPlayer, // TODO\n    initialValues: TwistyPlayerInitialConfig,\n  ) {\n    this.attributes = {\n      \"alg\": new AlgAttribute(initialValues.alg),\n      \"experimental-start-setup\": new AlgAttribute(\n        initialValues.experimentalStartSetup,\n      ),\n\n      \"puzzle\": new StringEnumAttribute(puzzleIDs, initialValues.puzzle),\n      \"visualization\": new StringEnumAttribute(\n        visualizationFormats,\n        initialValues.visualization,\n      ),\n      \"hint-facelets\": new StringEnumAttribute(\n        hintFaceletStyles,\n        initialValues.hintFacelets,\n      ),\n      \"experimental-stickering\": new StringEnumAttribute(\n        experimentalStickerings,\n        initialValues.experimentalStickering,\n      ),\n\n      \"background\": new StringEnumAttribute(\n        backgroundThemes,\n        initialValues.background,\n      ),\n      \"controls\": new StringEnumAttribute(\n        controlsLocations,\n        initialValues.controls,\n      ),\n      \"back-view\": new StringEnumAttribute(\n        backViewLayouts,\n        initialValues[\"backView\"],\n      ),\n      \"camera-position\": new Vector3Attribute(\n        null,\n        initialValues[\"cameraPosition\"],\n      ),\n    };\n  }\n\n  static get observedAttributes(): (keyof TwistyPlayerAttributes & string)[] {\n    return Object.keys(twistyPlayerAttributeMap);\n  }\n\n  attributeChangedCallback(\n    attributeName: string,\n    oldValue: string,\n    newValue: string,\n  ): void {\n    const managedAttribute = this.attributes[attributeName];\n    if (managedAttribute) {\n      // TODO: Handle `null` better.\n      if (oldValue !== null && managedAttribute.string !== oldValue) {\n        console.warn(\n          \"Attribute out of sync!\",\n          attributeName,\n          managedAttribute.string,\n          oldValue,\n        );\n      }\n      managedAttribute.setString(newValue);\n\n      // TODO: can we make this type-safe?\n      // TODO: avoid double-setting in recursive calls\n      const propertyName: keyof TwistyPlayerConfigValues =\n        twistyPlayerAttributeMap[attributeName];\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      this.twistyPlayer[propertyName] = managedAttribute.value;\n    }\n  }\n}\n", "export const TAU = Math.PI * 2;\n", "import { ExperimentalStickering } from \"../../dom/TwistyPlayerConfig\";\nimport { PieceAppearance, PuzzleAppearance } from \"./appearance\";\n\n// regular\nconst r: PieceAppearance = {\n  facelets: [\"regular\", \"regular\", \"regular\"],\n};\n\n// dim / (already) solved\nconst d: PieceAppearance = {\n  facelets: [\"dim\", \"dim\", \"dim\"],\n};\n\n// dim / (already) oriented\nconst di: PieceAppearance = {\n  facelets: [\"dim\", \"ignored\", \"ignored\"],\n};\n\n// PLL\nconst p: PieceAppearance = {\n  facelets: [\"dim\", \"regular\", \"regular\"],\n};\n\n// OLL\nconst o: PieceAppearance = {\n  facelets: [\"regular\", \"ignored\", \"ignored\"],\n};\n\n// ignored\nconst i: PieceAppearance = {\n  facelets: [\"ignored\", \"ignored\", \"ignored\"],\n};\n\n// oriented\nconst oi: PieceAppearance = {\n  facelets: [\"oriented\", \"ignored\", \"ignored\"],\n};\n\nconst invis: PieceAppearance = {\n  facelets: [\"invisible\", \"invisible\", \"invisible\"],\n};\n\n// TODO: generalize stickerings by performing e.g. intersection on orbit selectors\n// Example: OLL is `LL: orient, !LL: dim`\nexport const stickerings: Record<ExperimentalStickering, PuzzleAppearance> = {\n  \"full\": {\n    // TODO: Support elision for regular pieces.\n    orbits: {\n      EDGES: {\n        pieces: [r, r, r, r, r, r, r, r, r, r, r, r],\n      },\n      CORNERS: {\n        pieces: [r, r, r, r, r, r, r, r],\n      },\n      CENTERS: {\n        pieces: [r, r, r, r, r, r],\n      },\n    },\n  },\n\n  \"centers-only\": {\n    orbits: {\n      EDGES: {\n        pieces: [i, i, i, i, i, i, i, i, i, i, i, i],\n      },\n      CORNERS: {\n        pieces: [i, i, i, i, i, i, i, i],\n      },\n      CENTERS: {\n        pieces: [r, r, r, r, r, r],\n      },\n    },\n  },\n\n  \"PLL\": {\n    orbits: {\n      EDGES: {\n        pieces: [p, p, p, p, d, d, d, d, d, d, d, d],\n      },\n      CORNERS: {\n        pieces: [p, p, p, p, d, d, d, d],\n      },\n      CENTERS: {\n        pieces: [p, d, d, d, d, d],\n      },\n    },\n  },\n\n  \"CLS\": {\n    orbits: {\n      EDGES: {\n        pieces: [di, di, di, di, d, d, d, d, d, d, d, d],\n      },\n      CORNERS: {\n        pieces: [o, o, o, o, o, d, d, d],\n      },\n      CENTERS: {\n        pieces: [d, d, d, d, d, d],\n      },\n    },\n  },\n\n  \"OLL\": {\n    orbits: {\n      EDGES: {\n        pieces: [o, o, o, o, d, d, d, d, d, d, d, d],\n      },\n      CORNERS: {\n        pieces: [o, o, o, o, d, d, d, d],\n      },\n      CENTERS: {\n        pieces: [r, d, d, d, d, d],\n      },\n    },\n  },\n\n  \"ELS\": {\n    orbits: {\n      EDGES: {\n        pieces: [o, o, o, o, d, d, d, d, r, d, d, d],\n      },\n      CORNERS: {\n        pieces: [i, i, i, i, i, d, d, d],\n      },\n      CENTERS: {\n        pieces: [r, d, d, d, d, d],\n      },\n    },\n  },\n\n  \"LL\": {\n    orbits: {\n      EDGES: {\n        pieces: [r, r, r, r, d, d, d, d, d, d, d, d],\n      },\n      CORNERS: {\n        pieces: [r, r, r, r, d, d, d, d],\n      },\n      CENTERS: {\n        pieces: [r, d, d, d, d, d],\n      },\n    },\n  },\n\n  \"F2L\": {\n    orbits: {\n      EDGES: {\n        pieces: [i, i, i, i, r, r, r, r, r, r, r, r],\n      },\n      CORNERS: {\n        pieces: [i, i, i, i, r, r, r, r],\n      },\n      CENTERS: {\n        pieces: [d, r, r, r, r, r],\n      },\n    },\n  },\n\n  \"ZBLL\": {\n    orbits: {\n      EDGES: {\n        pieces: [p, p, p, p, d, d, d, d, d, d, d, d],\n      },\n      CORNERS: {\n        pieces: [r, r, r, r, d, d, d, d],\n      },\n      CENTERS: {\n        pieces: [r, d, d, d, d, d],\n      },\n    },\n  },\n\n  \"ZBLS\": {\n    orbits: {\n      EDGES: {\n        pieces: [o, o, o, o, d, d, d, d, r, d, d, d],\n      },\n      CORNERS: {\n        pieces: [i, i, i, i, r, d, d, d],\n      },\n      CENTERS: {\n        pieces: [r, d, d, d, d, d],\n      },\n    },\n  },\n\n  \"WVLS\": {\n    orbits: {\n      EDGES: {\n        pieces: [o, o, o, o, d, d, d, d, r, d, d, d],\n      },\n      CORNERS: {\n        pieces: [o, o, o, o, r, d, d, d],\n      },\n      CENTERS: {\n        pieces: [r, d, d, d, d, d],\n      },\n    },\n  },\n\n  \"VLS\": {\n    orbits: {\n      EDGES: {\n        pieces: [o, o, o, o, d, d, d, d, r, d, d, d],\n      },\n      CORNERS: {\n        pieces: [o, o, o, o, r, d, d, d],\n      },\n      CENTERS: {\n        pieces: [r, d, d, d, d, d],\n      },\n    },\n  },\n\n  \"LS\": {\n    orbits: {\n      EDGES: {\n        pieces: [i, i, i, i, d, d, d, d, r, d, d, d],\n      },\n      CORNERS: {\n        pieces: [i, i, i, i, r, d, d, d],\n      },\n      CENTERS: {\n        pieces: [d, d, d, d, d, d],\n      },\n    },\n  },\n\n  \"EO\": {\n    orbits: {\n      EDGES: {\n        pieces: [oi, oi, oi, oi, oi, oi, oi, oi, oi, oi, oi, oi],\n      },\n      CORNERS: {\n        pieces: [i, i, i, i, i, i, i, i],\n      },\n    },\n  },\n\n  \"CMLL\": {\n    orbits: {\n      EDGES: {\n        pieces: [i, i, i, i, i, d, i, d, d, d, d, d],\n      },\n      CORNERS: {\n        pieces: [r, r, r, r, d, d, d, d],\n      },\n      CENTERS: {\n        pieces: [i, d, i, d, i, i],\n      },\n    },\n  },\n\n  \"L6E\": {\n    orbits: {\n      EDGES: {\n        pieces: [r, r, r, r, r, d, r, d, d, d, d, d],\n      },\n      CORNERS: {\n        pieces: [d, d, d, d, d, d, d, d],\n      },\n      CENTERS: {\n        pieces: [r, d, r, d, r, r],\n      },\n    },\n  },\n\n  \"L6EO\": {\n    orbits: {\n      EDGES: {\n        pieces: [oi, oi, oi, oi, oi, d, oi, d, d, d, d, d],\n      },\n      CORNERS: {\n        pieces: [d, d, d, d, d, d, d, d],\n      },\n      CENTERS: {\n        pieces: [oi, d, i, d, i, oi],\n      },\n    },\n  },\n\n  \"Daisy\": {\n    orbits: {\n      EDGES: {\n        pieces: [o, o, o, o, i, i, i, i, i, i, i, i],\n      },\n      CORNERS: {\n        pieces: [i, i, i, i, i, i, i, i],\n      },\n      CENTERS: {\n        pieces: [d, d, d, d, d, o],\n      },\n    },\n  },\n\n  // TODO: U? This doesn't match daisy.\n  \"Cross\": {\n    orbits: {\n      EDGES: {\n        pieces: [i, i, i, i, r, r, r, r, i, i, i, i],\n      },\n      CORNERS: {\n        pieces: [i, i, i, i, i, i, i, i],\n      },\n      CENTERS: {\n        pieces: [d, d, d, d, d, r],\n      },\n    },\n  },\n\n  \"2x2x2\": {\n    orbits: {\n      EDGES: {\n        pieces: [i, i, i, i, i, i, r, r, i, i, i, r],\n      },\n      CORNERS: {\n        pieces: [i, i, i, i, i, i, r, i],\n      },\n      CENTERS: {\n        pieces: [d, r, d, d, r, r],\n      },\n    },\n  },\n\n  \"2x2x3\": {\n    orbits: {\n      EDGES: {\n        pieces: [i, i, i, i, r, i, d, d, i, r, i, d],\n      },\n      CORNERS: {\n        pieces: [i, i, i, i, i, r, d, i],\n      },\n      CENTERS: {\n        pieces: [d, d, r, d, d, d],\n      },\n    },\n  },\n\n  // TODO: remove foundations\n  \"Void Cube\": {\n    orbits: {\n      EDGES: {\n        pieces: [r, r, r, r, r, r, r, r, r, r, r, r],\n      },\n      CORNERS: {\n        pieces: [r, r, r, r, r, r, r, r],\n      },\n      CENTERS: {\n        pieces: [invis, invis, invis, invis, invis, invis],\n      },\n    },\n  },\n};\n", "import {\n  BackSide,\n  BoxGeometry,\n  DoubleSide,\n  Euler,\n  Group,\n  Matrix4,\n  Mesh,\n  MeshBasicMaterial,\n  Object3D,\n  PlaneGeometry,\n  Quaternion,\n  Vector3,\n} from \"three\";\nimport { BlockMove } from \"../../../alg\";\nimport { Puzzles, Transformation } from \"../../../kpuzzle\";\nimport { AlgCursor } from \"../../animation/alg/AlgCursor\";\nimport { PuzzlePosition } from \"../../animation/alg/CursorTypes\";\nimport { smootherStep } from \"../../animation/easing\";\nimport {\n  ExperimentalStickering,\n  experimentalStickerings,\n  HintFaceletStyle,\n  hintFaceletStyles,\n} from \"../../dom/TwistyPlayerConfig\";\nimport { TAU } from \"../TAU\";\nimport { FaceletMeshAppearance, PuzzleAppearance } from \"./appearance\";\nimport { stickerings } from \"./stickerings\";\nimport { Twisty3DPuzzle } from \"./Twisty3DPuzzle\";\n\nconst ignoredMaterial = new MeshBasicMaterial({\n  color: 0x444444,\n  side: DoubleSide,\n});\n\nconst ignoredMaterialHint = new MeshBasicMaterial({\n  color: 0xcccccc,\n  side: BackSide,\n});\n\nconst invisibleMaterial = new MeshBasicMaterial({\n  visible: false,\n});\n\nconst orientedMaterial = new MeshBasicMaterial({\n  color: 0xff88ff,\n});\n\nconst orientedMaterialHint = new MeshBasicMaterial({\n  color: 0xff88ff,\n  side: BackSide,\n});\n\ninterface MaterialMap extends Record<FaceletMeshAppearance, MeshBasicMaterial> {\n  regular: MeshBasicMaterial;\n  dim: MeshBasicMaterial;\n  ignored: MeshBasicMaterial;\n  invisible: MeshBasicMaterial;\n}\n\nclass AxisInfo {\n  public stickerMaterial: MaterialMap;\n  public hintStickerMaterial: MaterialMap;\n  constructor(\n    public vector: Vector3,\n    public fromZ: Euler,\n    public color: number,\n    public dimColor: number,\n  ) {\n    // TODO: Make sticker material single-sided when cubie foundation is opaque?\n    this.stickerMaterial = {\n      regular: new MeshBasicMaterial({\n        color,\n        side: DoubleSide,\n      }),\n      dim: new MeshBasicMaterial({\n        color: dimColor,\n        side: DoubleSide,\n      }),\n      oriented: orientedMaterial,\n      ignored: ignoredMaterial,\n      invisible: invisibleMaterial,\n    };\n    this.hintStickerMaterial = {\n      regular: new MeshBasicMaterial({\n        color,\n        side: BackSide,\n      }),\n      dim: new MeshBasicMaterial({\n        color: dimColor,\n        side: BackSide,\n        transparent: true,\n        opacity: 0.75,\n      }),\n      oriented: orientedMaterialHint,\n      ignored: ignoredMaterialHint,\n      invisible: invisibleMaterial,\n    };\n  }\n}\n\nconst axesInfo: AxisInfo[] = [\n  new AxisInfo(\n    new Vector3(0, 1, 0),\n    new Euler(-TAU / 4, 0, 0),\n    0xffffff,\n    0xdddddd,\n  ),\n  new AxisInfo(\n    new Vector3(-1, 0, 0),\n    new Euler(0, -TAU / 4, 0),\n    0xff8800,\n    0x884400,\n  ),\n  new AxisInfo(new Vector3(0, 0, 1), new Euler(0, 0, 0), 0x00ff00, 0x008800),\n  new AxisInfo(\n    new Vector3(1, 0, 0),\n    new Euler(0, TAU / 4, 0),\n    0xff0000,\n    0x660000,\n  ),\n  new AxisInfo(\n    new Vector3(0, 0, -1),\n    new Euler(0, TAU / 2, 0),\n    0x0000ff,\n    0x000088,\n  ),\n  new AxisInfo(\n    new Vector3(0, -1, 0),\n    new Euler(TAU / 4, 0, 0),\n    0xffff00,\n    0x888800,\n  ),\n];\n\nconst face: { [s: string]: number } = {\n  U: 0,\n  L: 1,\n  F: 2,\n  R: 3,\n  B: 4,\n  D: 5,\n};\n\nconst familyToAxis: { [s: string]: number } = {\n  U: face.U,\n  u: face.U,\n  y: face.U,\n  L: face.L,\n  l: face.L,\n  M: face.L,\n  F: face.F,\n  f: face.F,\n  S: face.F,\n  z: face.F,\n  R: face.R,\n  r: face.R,\n  x: face.R,\n  B: face.B,\n  b: face.B,\n  D: face.D,\n  d: face.D,\n  E: face.D,\n};\n\nconst cubieDimensions = {\n  stickerWidth: 0.85,\n  stickerElevation: 0.501,\n  foundationWidth: 1,\n  hintStickerElevation: 1.45,\n};\n\ntype OptionKey = \"showMainStickers\" | \"hintFacelets\" | \"showFoundation\";\n\ninterface Cube3DOptions {\n  showMainStickers?: boolean;\n  hintFacelets?: HintFaceletStyle;\n  showFoundation?: boolean; // TODO: better name\n  experimentalStickering?: ExperimentalStickering;\n}\n\nconst cube3DOptionsDefaults: Cube3DOptions = {\n  showMainStickers: true,\n  hintFacelets: \"floating\",\n  showFoundation: true,\n  experimentalStickering: \"full\",\n};\n\n// TODO: Make internal foundation faces one-sided, facing to the outside of the cube.\nconst blackMesh = new MeshBasicMaterial({\n  color: 0x000000,\n  opacity: 0.3,\n  transparent: true,\n});\n\nclass CubieDef {\n  public matrix: Matrix4;\n  public stickerFaces: number[];\n  // stickerFaceNames can be e.g. [\"U\", \"F\", \"R\"], \"UFR\" if every face is a single letter.\n  constructor(\n    public orbit: string,\n    stickerFaceNames: string[] | string,\n    q: Quaternion,\n  ) {\n    const individualStickerFaceNames =\n      typeof stickerFaceNames === \"string\"\n        ? stickerFaceNames.split(\"\")\n        : stickerFaceNames;\n    this.stickerFaces = individualStickerFaceNames.map((s) => face[s]);\n    this.matrix = new Matrix4();\n    this.matrix.setPosition(firstPiecePosition[orbit]);\n    this.matrix.premultiply(new Matrix4().makeRotationFromQuaternion(q));\n  }\n}\n\nfunction t(v: Vector3, t4: number): Quaternion {\n  return new Quaternion().setFromAxisAngle(v, (TAU * t4) / 4);\n}\n\nconst r = {\n  O: new Vector3(0, 0, 0),\n  U: new Vector3(0, -1, 0),\n  L: new Vector3(1, 0, 0),\n  F: new Vector3(0, 0, -1),\n  R: new Vector3(-1, 0, 0),\n  B: new Vector3(0, 0, 1),\n  D: new Vector3(0, 1, 0),\n};\n\ninterface OrbitIndexed<T> {\n  [s: string]: T;\n}\ntype PieceIndexed<T> = OrbitIndexed<T[]>;\n\nconst firstPiecePosition: OrbitIndexed<Vector3> = {\n  EDGES: new Vector3(0, 1, 1),\n  CORNERS: new Vector3(1, 1, 1),\n  CENTERS: new Vector3(0, 1, 0),\n};\nconst orientationRotation: OrbitIndexed<Matrix4[]> = {\n  EDGES: [0, 1].map((i) =>\n    new Matrix4().makeRotationAxis(\n      firstPiecePosition.EDGES.clone().normalize(),\n      (-i * TAU) / 2,\n    ),\n  ),\n  CORNERS: [0, 1, 2].map((i) =>\n    new Matrix4().makeRotationAxis(\n      firstPiecePosition.CORNERS.clone().normalize(),\n      (-i * TAU) / 3,\n    ),\n  ),\n  CENTERS: [0, 1, 2, 3].map((i) =>\n    new Matrix4().makeRotationAxis(\n      firstPiecePosition.CENTERS.clone().normalize(),\n      (-i * TAU) / 4,\n    ),\n  ),\n};\nconst cubieStickerOrder = [face.U, face.F, face.R];\n\nconst pieceDefs: PieceIndexed<CubieDef> = {\n  EDGES: [\n    new CubieDef(\"EDGES\", \"UF\", t(r.O, 0)),\n    new CubieDef(\"EDGES\", \"UR\", t(r.U, 3)),\n    new CubieDef(\"EDGES\", \"UB\", t(r.U, 2)),\n    new CubieDef(\"EDGES\", \"UL\", t(r.U, 1)),\n    new CubieDef(\"EDGES\", \"DF\", t(r.F, 2)),\n    new CubieDef(\"EDGES\", \"DR\", t(r.F, 2).premultiply(t(r.D, 1))),\n    new CubieDef(\"EDGES\", \"DB\", t(r.F, 2).premultiply(t(r.D, 2))),\n    new CubieDef(\"EDGES\", \"DL\", t(r.F, 2).premultiply(t(r.D, 3))),\n    new CubieDef(\"EDGES\", \"FR\", t(r.U, 3).premultiply(t(r.R, 3))),\n    new CubieDef(\"EDGES\", \"FL\", t(r.U, 1).premultiply(t(r.R, 3))),\n    new CubieDef(\"EDGES\", \"BR\", t(r.U, 3).premultiply(t(r.R, 1))),\n    new CubieDef(\"EDGES\", \"BL\", t(r.U, 1).premultiply(t(r.R, 1))),\n  ],\n  CORNERS: [\n    new CubieDef(\"CORNERS\", \"UFR\", t(r.O, 0)),\n    new CubieDef(\"CORNERS\", \"URB\", t(r.U, 3)),\n    new CubieDef(\"CORNERS\", \"UBL\", t(r.U, 2)),\n    new CubieDef(\"CORNERS\", \"ULF\", t(r.U, 1)),\n    new CubieDef(\"CORNERS\", \"DRF\", t(r.F, 2).premultiply(t(r.D, 1))),\n    new CubieDef(\"CORNERS\", \"DFL\", t(r.F, 2).premultiply(t(r.D, 0))),\n    new CubieDef(\"CORNERS\", \"DLB\", t(r.F, 2).premultiply(t(r.D, 3))),\n    new CubieDef(\"CORNERS\", \"DBR\", t(r.F, 2).premultiply(t(r.D, 2))),\n  ],\n  CENTERS: [\n    new CubieDef(\"CENTERS\", \"U\", t(r.O, 0)),\n    new CubieDef(\"CENTERS\", \"L\", t(r.R, 3).premultiply(t(r.U, 1))),\n    new CubieDef(\"CENTERS\", \"F\", t(r.R, 3)),\n    new CubieDef(\"CENTERS\", \"R\", t(r.R, 3).premultiply(t(r.D, 1))),\n    new CubieDef(\"CENTERS\", \"B\", t(r.R, 3).premultiply(t(r.D, 2))),\n    new CubieDef(\"CENTERS\", \"D\", t(r.R, 2)),\n  ],\n};\n\nconst CUBE_SCALE = 1 / 3;\n\ninterface FaceletInfo {\n  faceIdx: number;\n  facelet: Mesh;\n  hintFacelet?: Mesh;\n}\n\n// TODO: Split into \"scene model\" and \"view\".\nexport class Cube3D extends Object3D implements Twisty3DPuzzle {\n  kpuzzleFaceletInfo: Record<string, FaceletInfo[][]>;\n  private pieces: PieceIndexed<Object3D> = {};\n  private options: Cube3DOptions;\n  // TODO: Keep track of option-based meshes better.\n  private experimentalHintStickerMeshes: Mesh[] = [];\n  private experimentalFoundationMeshes: Mesh[] = [];\n  constructor(\n    cursor?: AlgCursor,\n    private scheduleRenderCallback?: () => void,\n    options: Cube3DOptions = {},\n  ) {\n    super();\n\n    const def = Puzzles[\"3x3x3\"];\n\n    this.options = {};\n    for (const key in cube3DOptionsDefaults) {\n      // TODO:Don't use `any`.\n      this.options[key as OptionKey] =\n        key in options\n          ? (options as any)[key]\n          : (cube3DOptionsDefaults as any)[key];\n    }\n\n    if (def.name !== \"3x3x3\") {\n      throw new Error(\"Invalid puzzle for this Cube3D implementation.\");\n    }\n    this.kpuzzleFaceletInfo = {};\n    for (const orbit in pieceDefs) {\n      const orbitFaceletInfo: FaceletInfo[][] = [];\n      this.kpuzzleFaceletInfo[orbit] = orbitFaceletInfo;\n      this.pieces[orbit] = pieceDefs[orbit].map(\n        this.createCubie.bind(this, orbitFaceletInfo),\n      );\n    }\n    this.scale.set(CUBE_SCALE, CUBE_SCALE, CUBE_SCALE);\n\n    // TODO: Can we construct this directly instead of applying it later? Would that be more code-efficient?\n    if (options.experimentalStickering) {\n      this.setAppearance(stickerings[options.experimentalStickering]);\n    }\n\n    cursor!.addPositionListener(this);\n  }\n\n  setAppearance(appearance: PuzzleAppearance): void {\n    for (const [orbitName, orbitAppearance] of Object.entries(\n      appearance.orbits,\n    )) {\n      for (\n        let pieceIdx = 0;\n        pieceIdx < orbitAppearance.pieces.length;\n        pieceIdx++\n      ) {\n        const pieceAppearance = orbitAppearance.pieces[pieceIdx];\n        if (pieceAppearance) {\n          const pieceInfo = this.kpuzzleFaceletInfo[orbitName][pieceIdx];\n          for (\n            let faceletIdx = 0;\n            faceletIdx < pieceInfo.length;\n            faceletIdx++\n          ) {\n            const faceletAppearance = pieceAppearance.facelets[faceletIdx];\n            if (faceletAppearance) {\n              const faceletInfo = pieceInfo[faceletIdx];\n\n              const appearance =\n                typeof faceletAppearance === \"string\"\n                  ? faceletAppearance\n                  : faceletAppearance?.appearance;\n\n              faceletInfo.facelet.material =\n                axesInfo[faceletInfo.faceIdx].stickerMaterial[appearance];\n              // TODO\n              const hintAppearance =\n                typeof faceletAppearance === \"string\"\n                  ? appearance\n                  : faceletAppearance.hintAppearance ?? appearance;\n              if (faceletInfo.hintFacelet) {\n                faceletInfo.hintFacelet.material =\n                  axesInfo[faceletInfo.faceIdx].hintStickerMaterial[\n                    hintAppearance\n                  ];\n              }\n            }\n          }\n        }\n      }\n    }\n    if (this.scheduleRenderCallback) {\n      this.scheduleRenderCallback();\n    }\n  }\n\n  /** @deprecated */\n  public experimentalUpdateOptions(options: Cube3DOptions): void {\n    if (\"showMainStickers\" in options) {\n      throw new Error(\"Unimplemented\");\n    }\n\n    const showFoundation = options.showFoundation;\n    if (\n      typeof showFoundation !== \"undefined\" &&\n      this.options.showFoundation !== showFoundation\n    ) {\n      this.options.showFoundation = showFoundation;\n      for (const foundation of this.experimentalFoundationMeshes) {\n        foundation.visible = showFoundation;\n      }\n    }\n\n    const hintFacelets = options.hintFacelets;\n    if (\n      typeof hintFacelets !== \"undefined\" &&\n      this.options.hintFacelets !== hintFacelets &&\n      hintFaceletStyles[hintFacelets] // TODO: test this\n    ) {\n      this.options.hintFacelets = hintFacelets;\n      for (const hintSticker of this.experimentalHintStickerMeshes) {\n        hintSticker.visible = hintFacelets === \"floating\";\n      }\n      this.scheduleRenderCallback!(); // TODO\n    }\n\n    const experimentalStickering = options.experimentalStickering;\n    if (\n      typeof experimentalStickering !== \"undefined\" &&\n      this.options.experimentalStickering !== experimentalStickering &&\n      experimentalStickerings[experimentalStickering] // TODO: test this\n    ) {\n      this.options.experimentalStickering = experimentalStickering;\n      this.setAppearance(stickerings[experimentalStickering]);\n      this.scheduleRenderCallback!(); // TODO\n    }\n  }\n\n  public onPositionChange(p: PuzzlePosition): void {\n    const reid333 = p.state as Transformation;\n    for (const orbit in pieceDefs) {\n      const pieces = pieceDefs[orbit];\n      for (let i = 0; i < pieces.length; i++) {\n        const j = reid333[orbit].permutation[i];\n        this.pieces[orbit][j].matrix.copy(pieceDefs[orbit][i].matrix);\n        this.pieces[orbit][j].matrix.multiply(\n          orientationRotation[orbit][reid333[orbit].orientation[i]],\n        );\n      }\n      for (const moveProgress of p.movesInProgress) {\n        const blockMove = moveProgress.move as BlockMove;\n        const turnNormal = axesInfo[familyToAxis[blockMove.family]].vector;\n        const moveMatrix = new Matrix4().makeRotationAxis(\n          turnNormal,\n          (-this.ease(moveProgress.fraction) *\n            moveProgress.direction *\n            blockMove.amount *\n            TAU) /\n            4,\n        );\n        for (let i = 0; i < pieces.length; i++) {\n          const k =\n            Puzzles[\"3x3x3\"].moves[blockMove.family][orbit].permutation[i];\n          if (\n            i !== k ||\n            Puzzles[\"3x3x3\"].moves[blockMove.family][orbit].orientation[i] !== 0\n          ) {\n            const j = reid333[orbit].permutation[i];\n            this.pieces[orbit][j].matrix.premultiply(moveMatrix);\n          }\n        }\n      }\n    }\n    this.scheduleRenderCallback!();\n  }\n\n  // TODO: Always create (but sometimes hide parts) so we can show them later,\n  // or (better) support creating puzzle parts on demand.\n  private createCubie(\n    orbitFacelets: FaceletInfo[][],\n    piece: CubieDef,\n  ): Object3D {\n    const cubieFaceletInfo: FaceletInfo[] = [];\n    orbitFacelets.push(cubieFaceletInfo);\n    const cubie = new Group();\n    if (this.options.showFoundation) {\n      const foundation = this.createCubieFoundation();\n      cubie.add(foundation);\n      this.experimentalFoundationMeshes.push(foundation);\n    }\n    for (let i = 0; i < piece.stickerFaces.length; i++) {\n      const sticker = this.createSticker(\n        axesInfo[cubieStickerOrder[i]],\n        axesInfo[piece.stickerFaces[i]],\n        false,\n      );\n      const faceletInfo: FaceletInfo = {\n        faceIdx: piece.stickerFaces[i],\n        facelet: sticker,\n      };\n      cubie.add(sticker);\n      if (this.options.hintFacelets === \"floating\") {\n        const hintSticker = this.createSticker(\n          axesInfo[cubieStickerOrder[i]],\n          axesInfo[piece.stickerFaces[i]],\n          true,\n        );\n        cubie.add(hintSticker);\n        faceletInfo.hintFacelet = hintSticker;\n        this.experimentalHintStickerMeshes.push(hintSticker);\n      }\n\n      cubieFaceletInfo.push(faceletInfo);\n    }\n    cubie.matrix.copy(piece.matrix);\n    cubie.matrixAutoUpdate = false;\n    this.add(cubie);\n    return cubie;\n  }\n\n  // TODO: Support creating only the outward-facing parts?\n  private createCubieFoundation(): Mesh {\n    const box = new BoxGeometry(\n      cubieDimensions.foundationWidth,\n      cubieDimensions.foundationWidth,\n      cubieDimensions.foundationWidth,\n    );\n    return new Mesh(box, blackMesh);\n  }\n\n  private createSticker(\n    posAxisInfo: AxisInfo,\n    materialAxisInfo: AxisInfo,\n    isHint: boolean,\n  ): Mesh {\n    const geo = new PlaneGeometry(\n      cubieDimensions.stickerWidth,\n      cubieDimensions.stickerWidth,\n    );\n    const stickerMesh = new Mesh(\n      geo,\n      isHint\n        ? materialAxisInfo.hintStickerMaterial.regular\n        : materialAxisInfo.stickerMaterial.regular,\n    );\n    stickerMesh.setRotationFromEuler(posAxisInfo.fromZ);\n    stickerMesh.position.copy(posAxisInfo.vector);\n    stickerMesh.position.multiplyScalar(\n      isHint\n        ? cubieDimensions.hintStickerElevation\n        : cubieDimensions.stickerElevation,\n    );\n    return stickerMesh;\n  }\n\n  private ease(fraction: number): number {\n    return smootherStep(fraction);\n  }\n}\n", "import {\n  Color,\n  DoubleSide,\n  Euler,\n  Face3,\n  Geometry,\n  Group,\n  Mesh,\n  MeshBasicMaterial,\n  Object3D,\n  Vector3,\n} from \"three\";\nimport { BlockMove, modifiedBlockMove } from \"../../../alg\";\nimport {\n  KPuzzleDefinition,\n  stateForBlockMove,\n  Transformation,\n} from \"../../../kpuzzle\";\nimport { StickerDat, StickerDatSticker } from \"../../../puzzle-geometry\";\nimport { AlgCursor } from \"../../animation/alg/AlgCursor\";\nimport { TAU } from \"../TAU\";\nimport { Twisty3DPuzzle } from \"./Twisty3DPuzzle\";\nimport { smootherStep } from \"../../animation/easing\";\nimport { PuzzlePosition } from \"../../animation/alg/CursorTypes\";\n\nconst foundationMaterial = new MeshBasicMaterial({\n  side: DoubleSide,\n  color: 0x000000,\n  // transparency doesn't work very well here\n  // with duplicated center stickers\n  //  transparent: true,\n  //  opacity: 0.75,\n});\nconst stickerMaterial = new MeshBasicMaterial({\n  vertexColors: true,\n  //    side: DoubleSide,\n});\nconst polyMaterial = new MeshBasicMaterial({\n  transparent: true,\n  opacity: 0,\n  color: 0x000000,\n});\n\nfunction makePoly(coords: number[][], color: Color): Geometry {\n  const geo = new Geometry();\n  const vertind: number[] = [];\n  for (const coord of coords) {\n    const v = new Vector3(coord[0], coord[1], coord[2]);\n    vertind.push(geo.vertices.length);\n    geo.vertices.push(v);\n  }\n  for (let g = 1; g + 1 < vertind.length; g++) {\n    const face = new Face3(vertind[0], vertind[g], vertind[g + 1]);\n    face.color = color;\n    geo.faces.push(face);\n  }\n  geo.computeFaceNormals();\n  return geo;\n}\n\nclass StickerDef {\n  public origColor: Color;\n  public faceColor: Color;\n  public cubie: Group;\n  protected geo: Geometry;\n  constructor(\n    stickerDat: StickerDatSticker,\n    foundationDat: StickerDatSticker | undefined,\n  ) {\n    this.origColor = new Color(stickerDat.color);\n    this.faceColor = new Color(stickerDat.color);\n    this.cubie = new Group();\n    this.geo = makePoly(stickerDat.coords as number[][], this.faceColor);\n    const obj = new Mesh(this.geo, stickerMaterial);\n    obj.userData.name =\n      stickerDat.orbit + \" \" + (1 + stickerDat.ord) + \" \" + stickerDat.ori;\n    this.cubie.add(obj);\n    if (foundationDat) {\n      const fgeo = makePoly(foundationDat.coords as number[][], this.faceColor);\n      const foundation = new Mesh(fgeo, foundationMaterial);\n      foundation.scale.setScalar(0.999); // TODO: hacky\n      this.cubie.add(foundation);\n    }\n  }\n\n  public setColor(c: Color): void {\n    this.geo.colorsNeedUpdate = true;\n    this.faceColor.copy(c);\n  }\n}\n\nclass HitPlaneDef {\n  public cubie: Group;\n  protected geo: Geometry;\n  constructor(hitface: any) {\n    this.cubie = new Group();\n    this.geo = new Geometry();\n    const coords = hitface.coords as number[][];\n    const vertind: number[] = [];\n    for (const coord of coords) {\n      const v = new Vector3(coord[0], coord[1], coord[2]);\n      vertind.push(this.geo.vertices.length);\n      this.geo.vertices.push(v);\n    }\n    for (let g = 1; g + 1 < vertind.length; g++) {\n      const face = new Face3(vertind[0], vertind[g], vertind[g + 1]);\n      this.geo.faces.push(face);\n    }\n    this.geo.computeFaceNormals();\n    const obj = new Mesh(this.geo, polyMaterial);\n    obj.userData.name = hitface.name;\n    this.cubie.scale.setScalar(0.99);\n    this.cubie.add(obj);\n  }\n}\n\nclass AxisInfo {\n  public axis: Vector3;\n  public order: number;\n  constructor(axisDat: any) {\n    const vec = axisDat[0] as number[];\n    this.axis = new Vector3(vec[0], vec[1], vec[2]);\n    this.order = axisDat[2];\n  }\n}\n\nconst PG_SCALE = 0.5;\n\n// TODO: Split into \"scene model\" and \"view\".\nexport class PG3D extends Object3D implements Twisty3DPuzzle {\n  private stickers: { [key: string]: StickerDef[][] };\n  private axesInfo: { [key: string]: AxisInfo };\n\n  private stickerTargets: Object3D[] = [];\n  private controlTargets: Object3D[] = [];\n\n  constructor(\n    cursor: AlgCursor,\n    private scheduleRenderCallback: () => void,\n    private definition: KPuzzleDefinition,\n    private pgdat: StickerDat,\n    showFoundation: boolean = false,\n  ) {\n    super();\n\n    this.axesInfo = {};\n    const axesDef = this.pgdat.axis as any[];\n    for (const axis of axesDef) {\n      this.axesInfo[axis[1]] = new AxisInfo(axis);\n    }\n    const stickers = this.pgdat.stickers as any[];\n    this.stickers = {};\n    for (let si = 0; si < stickers.length; si++) {\n      const sticker = stickers[si];\n      const foundation = showFoundation\n        ? this.pgdat.foundations[si]\n        : undefined;\n      const orbit = sticker.orbit as number;\n      const ord = sticker.ord as number;\n      const ori = sticker.ori as number;\n      if (!this.stickers[orbit]) {\n        this.stickers[orbit] = [];\n      }\n      if (!this.stickers[orbit][ori]) {\n        this.stickers[orbit][ori] = [];\n      }\n      const stickerdef = new StickerDef(sticker, foundation);\n      stickerdef.cubie.scale.set(PG_SCALE, PG_SCALE, PG_SCALE);\n      this.stickers[orbit][ori][ord] = stickerdef;\n      this.add(stickerdef.cubie);\n      this.stickerTargets.push(stickerdef.cubie.children[0]);\n    }\n    const hitfaces = this.pgdat.faces as any[];\n    for (const hitface of hitfaces) {\n      const facedef = new HitPlaneDef(hitface);\n      facedef.cubie.scale.set(PG_SCALE, PG_SCALE, PG_SCALE);\n      this.add(facedef.cubie);\n      this.controlTargets.push(facedef.cubie.children[0]);\n    }\n\n    cursor!.addPositionListener(this);\n  }\n\n  public experimentalGetStickerTargets(): Object3D[] {\n    return this.stickerTargets;\n  }\n\n  public experimentalGetControlTargets(): Object3D[] {\n    return this.controlTargets;\n  }\n\n  public onPositionChange(p: PuzzlePosition): void {\n    const pos = p.state as Transformation;\n    const noRotation = new Euler();\n    for (const orbit in this.stickers) {\n      const pieces = this.stickers[orbit];\n      const pos2 = pos[orbit];\n      const orin = pieces.length;\n      for (let ori = 0; ori < orin; ori++) {\n        const pieces2 = pieces[ori];\n        for (let i = 0; i < pieces2.length; i++) {\n          pieces2[i].cubie.rotation.copy(noRotation);\n          const nori = (ori + orin - pos2.orientation[i]) % orin;\n          const ni = pos2.permutation[i];\n          pieces2[i].setColor(pieces[nori][ni].origColor);\n        }\n      }\n    }\n    // FIXME tgr const kp = new KPuzzle(this.definition);\n    for (const moveProgress of p.movesInProgress) {\n      const externalBlockMove = moveProgress.move as BlockMove;\n      // TODO: unswizzle goes external to internal, and so does the call after that\n      // and so does the stateForBlockMove call\n      const unswizzled = this.pgdat.unswizzle(externalBlockMove);\n      const blockMove = this.pgdat.notationMapper.notationToInternal(\n        externalBlockMove,\n      );\n      const simpleMove = modifiedBlockMove(externalBlockMove, { amount: 1 });\n      const baseMove = stateForBlockMove(this.definition, simpleMove);\n      const ax = this.axesInfo[unswizzled];\n      const turnNormal = ax.axis;\n      const angle =\n        (-this.ease(moveProgress.fraction) *\n          moveProgress.direction *\n          blockMove.amount *\n          TAU) /\n        ax.order;\n      for (const orbit in this.stickers) {\n        const pieces = this.stickers[orbit];\n        const orin = pieces.length;\n        const bmv = baseMove[orbit];\n        for (let ori = 0; ori < orin; ori++) {\n          const pieces2 = pieces[ori];\n          for (let i = 0; i < pieces2.length; i++) {\n            const ni = bmv.permutation[i];\n            if (ni !== i || bmv.orientation[i] !== 0) {\n              pieces2[i].cubie.rotateOnAxis(turnNormal, angle);\n            }\n          }\n        }\n      }\n    }\n    this.scheduleRenderCallback!();\n  }\n\n  private ease(fraction: number): number {\n    return smootherStep(fraction);\n  }\n}\n", "import {\n  Color,\n  DoubleSide,\n  Euler,\n  Face3,\n  Geometry,\n  Group,\n  Mesh,\n  MeshBasicMaterial,\n  Object3D,\n  Vector3,\n} from \"three\";\nimport { BlockMove, modifiedBlockMove } from \"../../../alg\";\nimport {\n  KPuzzleDefinition,\n  stateForBlockMove,\n  Transformation,\n} from \"../../../kpuzzle\";\nimport { StickerDat, StickerDatSticker } from \"../../../puzzle-geometry\";\nimport { AlgCursor } from \"../../animation/alg/AlgCursor\";\nimport { TAU } from \"../TAU\";\nimport { Twisty3DPuzzle } from \"./Twisty3DPuzzle\";\nimport { smootherStep } from \"../../animation/easing\";\nimport { PuzzlePosition } from \"../../animation/alg/CursorTypes\";\n\nconst foundationMaterial = new MeshBasicMaterial({\n  side: DoubleSide,\n  color: 0x000000,\n  // transparency doesn't work very well here\n  // with duplicated center stickers\n  //  transparent: true,\n  //  opacity: 0.75,\n});\nconst stickerMaterial = new MeshBasicMaterial({\n  vertexColors: true,\n  //    side: DoubleSide,\n});\nconst polyMaterial = new MeshBasicMaterial({\n  transparent: true,\n  opacity: 0,\n  color: 0x000000,\n});\n\nfunction makePoly(coords: number[][], color: Color): Geometry {\n  const geo = new Geometry();\n  const vertind: number[] = [];\n  for (const coord of coords) {\n    const v = new Vector3(coord[0], coord[1], coord[2]);\n    vertind.push(geo.vertices.length);\n    geo.vertices.push(v);\n  }\n  for (let g = 1; g + 1 < vertind.length; g++) {\n    const face = new Face3(vertind[0], vertind[g], vertind[g + 1]);\n    face.color = color;\n    geo.faces.push(face);\n  }\n  geo.computeFaceNormals();\n  return geo;\n}\n\nclass StickerDef {\n  public origColor: Color;\n  public faceColor: Color;\n  public cubie: Group;\n  protected geo: Geometry;\n  constructor(\n    stickerDat: StickerDatSticker,\n    foundationDat: StickerDatSticker | undefined,\n  ) {\n    this.origColor = new Color(stickerDat.color);\n    this.faceColor = new Color(stickerDat.color);\n    this.cubie = new Group();\n    this.geo = makePoly(stickerDat.coords as number[][], this.faceColor);\n    const obj = new Mesh(this.geo, stickerMaterial);\n    obj.userData.name =\n      stickerDat.orbit + \" \" + (1 + stickerDat.ord) + \" \" + stickerDat.ori;\n    this.cubie.add(obj);\n    if (foundationDat) {\n      const fgeo = makePoly(foundationDat.coords as number[][], this.faceColor);\n      const foundation = new Mesh(fgeo, foundationMaterial);\n      foundation.scale.setScalar(0.999); // TODO: hacky\n      this.cubie.add(foundation);\n    }\n  }\n\n  public setColor(c: Color): void {\n    this.geo.colorsNeedUpdate = true;\n    this.faceColor.copy(c);\n  }\n}\n\nclass HitPlaneDef {\n  public cubie: Group;\n  protected geo: Geometry;\n  constructor(hitface: any) {\n    this.cubie = new Group();\n    this.geo = new Geometry();\n    const coords = hitface.coords as number[][];\n    const vertind: number[] = [];\n    for (const coord of coords) {\n      const v = new Vector3(coord[0], coord[1], coord[2]);\n      vertind.push(this.geo.vertices.length);\n      this.geo.vertices.push(v);\n    }\n    for (let g = 1; g + 1 < vertind.length; g++) {\n      const face = new Face3(vertind[0], vertind[g], vertind[g + 1]);\n      this.geo.faces.push(face);\n    }\n    this.geo.computeFaceNormals();\n    const obj = new Mesh(this.geo, polyMaterial);\n    obj.userData.name = hitface.name;\n    this.cubie.scale.setScalar(0.99);\n    this.cubie.add(obj);\n  }\n}\n\nclass AxisInfo {\n  public axis: Vector3;\n  public order: number;\n  constructor(axisDat: any) {\n    const vec = axisDat[0] as number[];\n    this.axis = new Vector3(vec[0], vec[1], vec[2]);\n    this.order = axisDat[2];\n  }\n}\n\nconst PG_SCALE = 0.5;\n\n// TODO: Split into \"scene model\" and \"view\".\nexport class PG3D extends Object3D implements Twisty3DPuzzle {\n  private stickers: { [key: string]: StickerDef[][] };\n  private axesInfo: { [key: string]: AxisInfo };\n\n  private stickerTargets: Object3D[] = [];\n  private controlTargets: Object3D[] = [];\n\n  constructor(\n    cursor: AlgCursor,\n    private scheduleRenderCallback: () => void,\n    private definition: KPuzzleDefinition,\n    private pgdat: StickerDat,\n    showFoundation: boolean = false,\n  ) {\n    super();\n\n    this.axesInfo = {};\n    const axesDef = this.pgdat.axis as any[];\n    for (const axis of axesDef) {\n      this.axesInfo[axis[1]] = new AxisInfo(axis);\n    }\n    const stickers = this.pgdat.stickers as any[];\n    this.stickers = {};\n    for (let si = 0; si < stickers.length; si++) {\n      const sticker = stickers[si];\n      const foundation = showFoundation\n        ? this.pgdat.foundations[si]\n        : undefined;\n      const orbit = sticker.orbit as number;\n      const ord = sticker.ord as number;\n      const ori = sticker.ori as number;\n      if (!this.stickers[orbit]) {\n        this.stickers[orbit] = [];\n      }\n      if (!this.stickers[orbit][ori]) {\n        this.stickers[orbit][ori] = [];\n      }\n      const stickerdef = new StickerDef(sticker, foundation);\n      stickerdef.cubie.scale.set(PG_SCALE, PG_SCALE, PG_SCALE);\n      this.stickers[orbit][ori][ord] = stickerdef;\n      this.add(stickerdef.cubie);\n      this.stickerTargets.push(stickerdef.cubie.children[0]);\n    }\n    const hitfaces = this.pgdat.faces as any[];\n    for (const hitface of hitfaces) {\n      const facedef = new HitPlaneDef(hitface);\n      facedef.cubie.scale.set(PG_SCALE, PG_SCALE, PG_SCALE);\n      this.add(facedef.cubie);\n      this.controlTargets.push(facedef.cubie.children[0]);\n    }\n\n    cursor!.addPositionListener(this);\n  }\n\n  public experimentalGetStickerTargets(): Object3D[] {\n    return this.stickerTargets;\n  }\n\n  public experimentalGetControlTargets(): Object3D[] {\n    return this.controlTargets;\n  }\n\n  public onPositionChange(p: PuzzlePosition): void {\n    const pos = p.state as Transformation;\n    const noRotation = new Euler();\n    for (const orbit in this.stickers) {\n      const pieces = this.stickers[orbit];\n      const pos2 = pos[orbit];\n      const orin = pieces.length;\n      for (let ori = 0; ori < orin; ori++) {\n        const pieces2 = pieces[ori];\n        for (let i = 0; i < pieces2.length; i++) {\n          pieces2[i].cubie.rotation.copy(noRotation);\n          const nori = (ori + orin - pos2.orientation[i]) % orin;\n          const ni = pos2.permutation[i];\n          pieces2[i].setColor(pieces[nori][ni].origColor);\n        }\n      }\n    }\n    // FIXME tgr const kp = new KPuzzle(this.definition);\n    for (const moveProgress of p.movesInProgress) {\n      const externalBlockMove = moveProgress.move as BlockMove;\n      // TODO: unswizzle goes external to internal, and so does the call after that\n      // and so does the stateForBlockMove call\n      const unswizzled = this.pgdat.unswizzle(externalBlockMove);\n      const blockMove = this.pgdat.notationMapper.notationToInternal(\n        externalBlockMove,\n      );\n      const simpleMove = modifiedBlockMove(externalBlockMove, { amount: 1 });\n      const baseMove = stateForBlockMove(this.definition, simpleMove);\n      const ax = this.axesInfo[unswizzled];\n      const turnNormal = ax.axis;\n      const angle =\n        (-this.ease(moveProgress.fraction) *\n          moveProgress.direction *\n          blockMove.amount *\n          TAU) /\n        ax.order;\n      for (const orbit in this.stickers) {\n        const pieces = this.stickers[orbit];\n        const orin = pieces.length;\n        const bmv = baseMove[orbit];\n        for (let ori = 0; ori < orin; ori++) {\n          const pieces2 = pieces[ori];\n          for (let i = 0; i < pieces2.length; i++) {\n            const ni = bmv.permutation[i];\n            if (ni !== i || bmv.orientation[i] !== 0) {\n              pieces2[i].cubie.rotateOnAxis(turnNormal, angle);\n            }\n          }\n        }\n      }\n    }\n    this.scheduleRenderCallback!();\n  }\n\n  private ease(fraction: number): number {\n    return smootherStep(fraction);\n  }\n}\n", "import { Scene as ThreeScene, PointLight } from \"three\";\nimport { Twisty3DRenderTarget } from \"./Twisty3DRenderTarget\";\nimport { Twisty3DPuzzle } from \"./puzzles/Twisty3DPuzzle\";\n\nexport class Twisty3DScene extends ThreeScene implements Twisty3DRenderTarget {\n  private renderTargets: Set<Twisty3DRenderTarget> = new Set();\n  public twisty3Ds: Set<Twisty3DPuzzle> = new Set();\n\n  constructor() {\n    super();\n\n    const lights = [];\n    lights[0] = new PointLight(0xffffff, 1, 0);\n    lights[1] = new PointLight(0xffffff, 1, 0);\n    lights[2] = new PointLight(0xffffff, 1, 0);\n\n    lights[0].position.set(0, 200, 0);\n    lights[1].position.set(100, 200, 100);\n    lights[2].position.set(-100, -200, -100);\n\n    this.add(lights[0]);\n    this.add(lights[1]);\n    this.add(lights[2]);\n  }\n\n  addRenderTarget(renderTarget: Twisty3DRenderTarget): void {\n    this.renderTargets.add(renderTarget);\n  }\n\n  scheduleRender(): void {\n    for (const renderTarget of this.renderTargets) {\n      renderTarget.scheduleRender();\n    }\n  }\n\n  addTwisty3DPuzzle(twisty3DPuzzle: Twisty3DPuzzle): void {\n    this.twisty3Ds.add(twisty3DPuzzle);\n    this.add(twisty3DPuzzle);\n  }\n\n  removeTwisty3DPuzzle(twisty3DPuzzle: Twisty3DPuzzle): void {\n    this.twisty3Ds.delete(twisty3DPuzzle);\n    this.remove(twisty3DPuzzle);\n  }\n}\n", "import { BlockMove, blockMoveToString } from \"../../../alg\";\nimport {\n  Combine,\n  EquivalentStates,\n  IdentityTransformation,\n  Invert,\n  KPuzzleDefinition,\n  Puzzles,\n  stateForBlockMove,\n  Transformation,\n} from \"../../../kpuzzle\";\n\nexport type MoveName = string;\n\nexport interface MoveProgress {\n  blockMove: BlockMove;\n  fraction: number;\n}\n\n// tslint:disable-next-line no-empty-interfaces\n// eslint-disable-next-line @typescript-eslint/no-empty-interface, @typescript-eslint/no-unused-vars-experimental\nexport interface State<T extends PuzzleWrapper> {}\n\nexport abstract class PuzzleWrapper {\n  public abstract startState(): State<PuzzleWrapper>;\n  public abstract invert(state: State<PuzzleWrapper>): State<PuzzleWrapper>;\n  public abstract combine(\n    s1: State<PuzzleWrapper>,\n    s2: State<PuzzleWrapper>,\n  ): State<PuzzleWrapper>;\n\n  public multiply(\n    state: State<PuzzleWrapper>,\n    amount: number,\n  ): State<PuzzleWrapper> {\n    if (amount < 0) {\n      return this.invert(this.multiply(state, -amount));\n    }\n\n    let newState = this.identity();\n    while (amount > 0) {\n      if (amount % 2 === 1) {\n        newState = this.combine(newState, state);\n      }\n      amount = Math.floor(amount / 2);\n      state = this.combine(state, state);\n    }\n    return newState;\n  }\n\n  public abstract stateFromMove(blockMove: BlockMove): State<PuzzleWrapper>;\n  public abstract identity(): State<PuzzleWrapper>;\n  public abstract equivalent(\n    s1: State<PuzzleWrapper>,\n    s2: State<PuzzleWrapper>,\n  ): boolean;\n}\n\ninterface KSolvePuzzleState extends Transformation, State<KPuzzleWrapper> {}\n\nexport class KPuzzleWrapper extends PuzzleWrapper {\n  // don't work the underlying kdefinition/multiply so hard\n  public static fromID(id: string): KPuzzleWrapper {\n    return new KPuzzleWrapper(Puzzles[id]);\n  }\n\n  public moveStash: { [key: string]: Transformation } = {};\n  constructor(private definition: KPuzzleDefinition) {\n    super();\n  }\n\n  public startState(): KSolvePuzzleState {\n    return this.definition.startPieces;\n  }\n\n  public invert(state: KSolvePuzzleState): KSolvePuzzleState {\n    return Invert(this.definition, state);\n  }\n\n  public combine(\n    s1: KSolvePuzzleState,\n    s2: KSolvePuzzleState,\n  ): KSolvePuzzleState {\n    return Combine(this.definition, s1, s2);\n  }\n\n  public stateFromMove(blockMove: BlockMove): KSolvePuzzleState {\n    const key = blockMoveToString(blockMove);\n    if (!this.moveStash[key]) {\n      this.moveStash[key] = stateForBlockMove(this.definition, blockMove);\n    }\n    return this.moveStash[key];\n  }\n\n  public identity(): KSolvePuzzleState {\n    return IdentityTransformation(this.definition);\n  }\n\n  public equivalent(s1: KSolvePuzzleState, s2: KSolvePuzzleState): boolean {\n    return EquivalentStates(this.definition, s1, s2);\n  }\n}\n\nclass QTMCounterState implements State<QTMCounterPuzzle> {\n  constructor(public value: number) {}\n}\n\nexport class QTMCounterPuzzle extends PuzzleWrapper {\n  public startState(): QTMCounterState {\n    return new QTMCounterState(0);\n  }\n\n  public invert(state: QTMCounterState): QTMCounterState {\n    return new QTMCounterState(-state.value);\n  }\n\n  public combine(s1: QTMCounterState, s2: QTMCounterState): QTMCounterState {\n    return new QTMCounterState(s1.value + s2.value);\n  }\n\n  public stateFromMove(blockMove: BlockMove): QTMCounterState {\n    return new QTMCounterState(Math.abs(blockMove.amount));\n  }\n\n  public identity(): QTMCounterState {\n    return new QTMCounterState(0);\n  }\n\n  public equivalent(s1: QTMCounterState, s2: QTMCounterState): boolean {\n    return s1.value === s2.value;\n  }\n}\n", "import { AlgPart } from \"../../../alg\";\nimport { Transformation as KPuzzleState } from \"../../../kpuzzle\";\n\nexport type MillisecondTimestamp = number;\n\n// TODO: unify duration/timstamp types\nexport type Duration = MillisecondTimestamp; // Duration in milliseconds\n// TODO: Extend `number`, introduce MoveSequenceTimestamp vs. EpochTimestamp,\n// force Duration to be a difference.\nexport type Timestamp = MillisecondTimestamp; // Duration since a particular epoch.\n\nexport type Fraction = number; // Value from 0 to 1.\n\n// 1, 0, -1 are used as scalars for `directionScalar` below.\nexport enum Direction {\n  Forwards = 1,\n  Paused = 0,\n  Backwards = -1,\n}\n\nexport function directionScalar(direction: Direction): MillisecondTimestamp {\n  return direction;\n}\n\nexport interface MoveInProgress {\n  move: AlgPart;\n  direction: Direction;\n  fraction: number;\n}\n\nexport type PuzzlePosition = {\n  state: KPuzzleState;\n  movesInProgress: MoveInProgress[];\n};\n\nexport enum BoundaryType {\n  Move,\n  EntireTimeline,\n}\n\nexport type DurationForAmount = (amount: number) => Duration;\n// eslint-disable-next-line no-inner-declarations\n\nexport function ConstantDurationForAmount(_amount: number): Duration {\n  return 1000;\n}\n\n// eslint-disable-next-line no-inner-declarations\nexport function DefaultDurationForAmount(amount: number): Duration {\n  switch (Math.abs(amount)) {\n    case 0:\n      return 0;\n    case 1:\n      return 1000;\n    case 2:\n      return 1500;\n    default:\n      return 2000;\n  }\n}\n// eslint-disable-next-line no-inner-declarations\nexport function ExperimentalScaledDefaultDurationForAmount(\n  scale: number,\n  amount: number,\n): Duration {\n  switch (Math.abs(amount)) {\n    case 0:\n      return 0;\n    case 1:\n      return scale * 1000;\n    case 2:\n      return scale * 1500;\n    default:\n      return scale * 2000;\n  }\n}\n", "import { AlgPart } from \"../../../alg\";\nimport { Transformation as KPuzzleState } from \"../../../kpuzzle\";\n\nexport type MillisecondTimestamp = number;\n\n// TODO: unify duration/timstamp types\nexport type Duration = MillisecondTimestamp; // Duration in milliseconds\n// TODO: Extend `number`, introduce MoveSequenceTimestamp vs. EpochTimestamp,\n// force Duration to be a difference.\nexport type Timestamp = MillisecondTimestamp; // Duration since a particular epoch.\n\nexport type Fraction = number; // Value from 0 to 1.\n\n// 1, 0, -1 are used as scalars for `directionScalar` below.\nexport enum Direction {\n  Forwards = 1,\n  Paused = 0,\n  Backwards = -1,\n}\n\nexport function directionScalar(direction: Direction): MillisecondTimestamp {\n  return direction;\n}\n\nexport interface MoveInProgress {\n  move: AlgPart;\n  direction: Direction;\n  fraction: number;\n}\n\nexport type PuzzlePosition = {\n  state: KPuzzleState;\n  movesInProgress: MoveInProgress[];\n};\n\nexport enum BoundaryType {\n  Move,\n  EntireTimeline,\n}\n\nexport type DurationForAmount = (amount: number) => Duration;\n// eslint-disable-next-line no-inner-declarations\n\nexport function ConstantDurationForAmount(_amount: number): Duration {\n  return 1000;\n}\n\n// eslint-disable-next-line no-inner-declarations\nexport function DefaultDurationForAmount(amount: number): Duration {\n  switch (Math.abs(amount)) {\n    case 0:\n      return 0;\n    case 1:\n      return 1000;\n    case 2:\n      return 1500;\n    default:\n      return 2000;\n  }\n}\n// eslint-disable-next-line no-inner-declarations\nexport function ExperimentalScaledDefaultDurationForAmount(\n  scale: number,\n  amount: number,\n): Duration {\n  switch (Math.abs(amount)) {\n    case 0:\n      return 0;\n    case 1:\n      return scale * 1000;\n    case 2:\n      return scale * 1500;\n    default:\n      return scale * 2000;\n  }\n}\n", "import {\n  BlockMove,\n  Comment,\n  Commutator,\n  Conjugate,\n  Group,\n  NewLine,\n  Pause,\n  Sequence,\n  TraversalUp,\n} from \"../../../alg\";\nimport { Duration, DefaultDurationForAmount } from \"./CursorTypes\";\nexport class AlgDuration extends TraversalUp<Duration> {\n  // TODO: Pass durationForAmount as Down type instead?\n  constructor(\n    public durationForAmount: (\n      amount: number,\n    ) => Duration = DefaultDurationForAmount,\n  ) {\n    super();\n  }\n\n  public traverseSequence(sequence: Sequence): Duration {\n    let total = 0;\n    for (const alg of sequence.nestedUnits) {\n      total += this.traverse(alg);\n    }\n    return total;\n  }\n\n  public traverseGroup(group: Group): Duration {\n    return group.amount * this.traverse(group.nestedSequence);\n  }\n\n  public traverseBlockMove(blockMove: BlockMove): Duration {\n    return this.durationForAmount(blockMove.amount);\n  }\n\n  public traverseCommutator(commutator: Commutator): Duration {\n    return (\n      commutator.amount *\n      2 *\n      (this.traverse(commutator.A) + this.traverse(commutator.B))\n    );\n  }\n\n  public traverseConjugate(conjugate: Conjugate): Duration {\n    return (\n      conjugate.amount *\n      (2 * this.traverse(conjugate.A) + this.traverse(conjugate.B))\n    );\n  }\n\n  public traversePause(_pause: Pause): Duration {\n    return this.durationForAmount(1);\n  }\n\n  public traverseNewLine(_newLine: NewLine): Duration {\n    return this.durationForAmount(1);\n  }\n\n  public traverseComment(_comment: Comment): Duration {\n    return this.durationForAmount(0);\n  }\n}\n", "import {\n  AlgPart,\n  BlockMove,\n  Comment,\n  Commutator,\n  Conjugate,\n  Group,\n  NewLine,\n  Pause,\n  Sequence,\n  TraversalDownUp,\n  TraversalUp,\n  Unit,\n} from \"../../../alg\";\nimport { PuzzleWrapper, State } from \"../../3D/puzzles/KPuzzleWrapper\";\nimport { Timestamp, Duration, DefaultDurationForAmount } from \"./CursorTypes\";\nimport { AlgDuration } from \"./AlgDuration\";\n\n// TODO: Include Pause.\nclass CountAnimatedMoves extends TraversalUp<number> {\n  public traverseSequence(sequence: Sequence): number {\n    let total = 0;\n    for (const part of sequence.nestedUnits) {\n      total += this.traverse(part);\n    }\n    return total;\n  }\n\n  public traverseGroup(group: Group): number {\n    return this.traverseSequence(group.nestedSequence);\n  }\n\n  public traverseBlockMove(_blockMove: BlockMove): number {\n    return 1;\n  }\n\n  public traverseCommutator(commutator: Commutator): number {\n    return (\n      2 *\n      (this.traverseSequence(commutator.A) +\n        this.traverseSequence(commutator.B))\n    );\n  }\n\n  public traverseConjugate(conjugate: Conjugate): number {\n    return (\n      2 * this.traverseSequence(conjugate.A) +\n      this.traverseSequence(conjugate.B)\n    );\n  }\n\n  public traversePause(_pause: Pause): number {\n    return 0;\n  }\n\n  public traverseNewLine(_newLine: NewLine): number {\n    return 0;\n  }\n\n  public traverseComment(_comment: Comment): number {\n    return 0;\n  }\n}\n\nexport interface AlgIndexer<P extends PuzzleWrapper> {\n  getMove(index: number): BlockMove;\n  indexToMoveStartTimestamp(index: number): Timestamp;\n  stateAtIndex(index: number, startTransformation?: State<P>): State<P>;\n  transformAtIndex(index: number): State<P>;\n  numMoves(): number;\n  timestampToIndex(timestamp: Timestamp): number;\n  algDuration(): Duration;\n  moveDuration(index: number): number;\n}\n\nexport class AlgPartDecoration<P extends PuzzleWrapper> {\n  constructor(\n    _puz: PuzzleWrapper,\n    public moveCount: number,\n    public duration: number,\n    public forward: State<P>,\n    public backward: State<P>,\n    public children: Array<AlgPartDecoration<P>> = [],\n  ) {}\n}\nexport class DecoratorConstructor<P extends PuzzleWrapper> extends TraversalUp<\n  AlgPartDecoration<P>\n> {\n  private identity: State<P>;\n  private dummyLeaf: AlgPartDecoration<P>;\n  private durationFn: TraversalUp<Duration> = new AlgDuration(\n    DefaultDurationForAmount,\n  );\n\n  constructor(private puz: PuzzleWrapper) {\n    super();\n    this.identity = puz.identity();\n    this.dummyLeaf = new AlgPartDecoration<P>(\n      puz,\n      0,\n      0,\n      this.identity,\n      this.identity,\n      [],\n    );\n  }\n\n  public traverseSequence(sequence: Sequence): AlgPartDecoration<P> {\n    let moveCount = 0;\n    let duration = 0;\n    let state = this.identity;\n    const child: Array<AlgPartDecoration<P>> = [];\n    for (const part of sequence.nestedUnits) {\n      const apd = this.traverse(part);\n      moveCount += apd.moveCount;\n      duration += apd.duration;\n      state = this.puz.combine(state, apd.forward);\n      child.push(apd);\n    }\n    return new AlgPartDecoration<P>(\n      this.puz,\n      moveCount,\n      duration,\n      state,\n      this.puz.invert(state),\n      child,\n    );\n  }\n\n  public traverseGroup(group: Group): AlgPartDecoration<P> {\n    const dec = this.traverseSequence(group.nestedSequence);\n    return this.mult(dec, group.amount, [dec]);\n  }\n\n  public traverseBlockMove(blockMove: BlockMove): AlgPartDecoration<P> {\n    return new AlgPartDecoration<P>(\n      this.puz,\n      1,\n      this.durationFn.traverse(blockMove),\n      this.puz.stateFromMove(blockMove),\n      this.puz.stateFromMove(invertBlockMove(blockMove)),\n    );\n  }\n\n  public traverseCommutator(commutator: Commutator): AlgPartDecoration<P> {\n    const decA = this.traverseSequence(commutator.A);\n    const decB = this.traverseSequence(commutator.B);\n    const AB = this.puz.combine(decA.forward, decB.forward);\n    const ApBp = this.puz.combine(decA.backward, decB.backward);\n    const ABApBp = this.puz.combine(AB, ApBp);\n    const dec = new AlgPartDecoration<P>(\n      this.puz,\n      2 * (decA.moveCount + decB.moveCount),\n      2 * (decA.duration + decB.duration),\n      ABApBp,\n      this.puz.invert(ABApBp),\n      [decA, decB],\n    );\n    return this.mult(dec, commutator.amount, [dec, decA, decB]);\n  }\n\n  public traverseConjugate(conjugate: Conjugate): AlgPartDecoration<P> {\n    const decA = this.traverseSequence(conjugate.A);\n    const decB = this.traverseSequence(conjugate.B);\n    const AB = this.puz.combine(decA.forward, decB.forward);\n    const ABAp = this.puz.combine(AB, decA.backward);\n    const dec = new AlgPartDecoration<P>(\n      this.puz,\n      2 * decA.moveCount + decB.moveCount,\n      2 * decA.duration + decB.duration,\n      ABAp,\n      this.puz.invert(ABAp),\n      [decA, decB],\n    );\n    return this.mult(dec, conjugate.amount, [dec, decA, decB]);\n  }\n\n  public traversePause(pause: Pause): AlgPartDecoration<P> {\n    return new AlgPartDecoration<P>(\n      this.puz,\n      1,\n      this.durationFn.traverse(pause),\n      this.identity,\n      this.identity,\n    );\n  }\n\n  public traverseNewLine(_newLine: NewLine): AlgPartDecoration<P> {\n    return this.dummyLeaf;\n  }\n\n  public traverseComment(_comment: Comment): AlgPartDecoration<P> {\n    return this.dummyLeaf;\n  }\n\n  private mult(\n    apd: AlgPartDecoration<P>,\n    n: number,\n    child: Array<AlgPartDecoration<P>>,\n  ): AlgPartDecoration<P> {\n    const absn = Math.abs(n);\n    const st = this.puz.multiply(apd.forward, n);\n    return new AlgPartDecoration<P>(\n      this.puz,\n      apd.moveCount * absn,\n      apd.duration * absn,\n      st,\n      this.puz.invert(st),\n      child,\n    );\n  }\n}\nclass WalkerDown<P extends PuzzleWrapper> {\n  constructor(public apd: AlgPartDecoration<P>, public back: boolean) {\n    /**/\n  }\n}\nexport class AlgWalker<P extends PuzzleWrapper> extends TraversalDownUp<\n  WalkerDown<P>,\n  boolean\n> {\n  public mv?: Unit;\n  public moveDur: number;\n  public back: boolean;\n  public st: State<P>;\n  public root: WalkerDown<P>;\n  public i: number;\n  public dur: number;\n  private goali: number;\n  private goaldur: number;\n  constructor(\n    public puz: P,\n    public alg: AlgPart,\n    public apd: AlgPartDecoration<P>,\n  ) {\n    super();\n    this.i = -1;\n    this.dur = -1;\n    this.goali = -1;\n    this.goaldur = -1;\n    this.mv = undefined;\n    this.back = false;\n    this.moveDur = 0;\n    this.st = this.puz.identity();\n    this.root = new WalkerDown(this.apd, false);\n  }\n\n  public moveByIndex(loc: number): boolean {\n    if (this.i >= 0 && this.i === loc) {\n      return this.mv !== undefined;\n    }\n    return this.dosearch(loc, Infinity);\n  }\n\n  public moveByDuration(dur: number): boolean {\n    if (this.dur >= 0 && this.dur < dur && this.dur + this.moveDur >= dur) {\n      return this.mv !== undefined;\n    }\n    return this.dosearch(Infinity, dur);\n  }\n\n  public dosearch(loc: number, dur: number): boolean {\n    this.goali = loc;\n    this.goaldur = dur;\n    this.i = 0;\n    this.dur = 0;\n    this.mv = undefined;\n    this.moveDur = 0;\n    this.back = false;\n    this.st = this.puz.identity();\n    const r = this.traverse(this.alg, this.root);\n    return r;\n  }\n\n  public traverseSequence(sequence: Sequence, wd: WalkerDown<P>): boolean {\n    if (!this.firstcheck(wd)) {\n      return false;\n    }\n    if (wd.back) {\n      for (let i = sequence.nestedUnits.length - 1; i >= 0; i--) {\n        const part = sequence.nestedUnits[i];\n        if (this.traverse(part, new WalkerDown(wd.apd.children[i], wd.back))) {\n          return true;\n        }\n      }\n    } else {\n      for (let i = 0; i < sequence.nestedUnits.length; i++) {\n        const part = sequence.nestedUnits[i];\n        if (this.traverse(part, new WalkerDown(wd.apd.children[i], wd.back))) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  public traverseGroup(group: Group, wd: WalkerDown<P>): boolean {\n    if (!this.firstcheck(wd)) {\n      return false;\n    }\n    const back = this.domult(wd, group.amount);\n    return this.traverse(\n      group.nestedSequence,\n      new WalkerDown(wd.apd.children[0], back),\n    );\n  }\n\n  public traverseBlockMove(blockMove: BlockMove, wd: WalkerDown<P>): boolean {\n    if (!this.firstcheck(wd)) {\n      return false;\n    }\n    this.mv = blockMove;\n    this.moveDur = wd.apd.duration;\n    this.back = wd.back;\n    return true;\n  }\n\n  public traverseCommutator(\n    commutator: Commutator,\n    wd: WalkerDown<P>,\n  ): boolean {\n    if (!this.firstcheck(wd)) {\n      return false;\n    }\n    const back = this.domult(wd, commutator.amount);\n    if (back) {\n      return (\n        this.traverse(\n          commutator.B,\n          new WalkerDown(wd.apd.children[2], !back),\n        ) ||\n        this.traverse(\n          commutator.A,\n          new WalkerDown(wd.apd.children[1], !back),\n        ) ||\n        this.traverse(commutator.B, new WalkerDown(wd.apd.children[2], back)) ||\n        this.traverse(commutator.A, new WalkerDown(wd.apd.children[1], back))\n      );\n    } else {\n      return (\n        this.traverse(commutator.A, new WalkerDown(wd.apd.children[1], back)) ||\n        this.traverse(commutator.B, new WalkerDown(wd.apd.children[2], back)) ||\n        this.traverse(\n          commutator.A,\n          new WalkerDown(wd.apd.children[1], !back),\n        ) ||\n        this.traverse(commutator.B, new WalkerDown(wd.apd.children[2], !back))\n      );\n    }\n  }\n\n  public traverseConjugate(conjugate: Conjugate, wd: WalkerDown<P>): boolean {\n    if (!this.firstcheck(wd)) {\n      return false;\n    }\n    const back = this.domult(wd, conjugate.amount);\n    if (back) {\n      return (\n        this.traverse(conjugate.A, new WalkerDown(wd.apd.children[1], !back)) ||\n        this.traverse(conjugate.B, new WalkerDown(wd.apd.children[2], back)) ||\n        this.traverse(conjugate.A, new WalkerDown(wd.apd.children[1], back))\n      );\n    } else {\n      return (\n        this.traverse(conjugate.A, new WalkerDown(wd.apd.children[1], back)) ||\n        this.traverse(conjugate.B, new WalkerDown(wd.apd.children[2], back)) ||\n        this.traverse(conjugate.A, new WalkerDown(wd.apd.children[1], !back))\n      );\n    }\n  }\n\n  public traversePause(pause: Pause, wd: WalkerDown<P>): boolean {\n    if (!this.firstcheck(wd)) {\n      return false;\n    }\n    this.mv = pause;\n    this.moveDur = wd.apd.duration;\n    this.back = wd.back;\n    return true;\n  }\n\n  public traverseNewLine(_newLine: NewLine, _wd: WalkerDown<P>): boolean {\n    return false;\n  }\n\n  public traverseComment(_comment: Comment, _wd: WalkerDown<P>): boolean {\n    return false;\n  }\n\n  private firstcheck(wd: WalkerDown<P>): boolean {\n    if (\n      wd.apd.moveCount + this.i <= this.goali &&\n      wd.apd.duration + this.dur < this.goaldur\n    ) {\n      return this.keepgoing(wd);\n    }\n    return true;\n  }\n\n  private domult(wd: WalkerDown<P>, amount: number): boolean {\n    let back = wd.back;\n    if (amount === 0) {\n      // I don't believe this will ever happen\n      return back;\n    }\n    if (amount < 0) {\n      back = !back;\n      amount = -amount;\n    }\n    const base = wd.apd.children[0];\n    const full = Math.min(\n      Math.floor((this.goali - this.i) / base.moveCount),\n      Math.ceil((this.goaldur - this.dur) / base.duration - 1),\n    );\n    if (full > 0) {\n      this.keepgoing(new WalkerDown<P>(base, back), full);\n    }\n    return back;\n  }\n\n  private keepgoing(wd: WalkerDown<P>, mul: number = 1): boolean {\n    this.i += mul * wd.apd.moveCount;\n    this.dur += mul * wd.apd.duration;\n    if (mul !== 1) {\n      if (wd.back) {\n        this.st = this.puz.combine(\n          this.st,\n          this.puz.multiply(wd.apd.backward, mul),\n        );\n      } else {\n        this.st = this.puz.combine(\n          this.st,\n          this.puz.multiply(wd.apd.forward, mul),\n        );\n      }\n    } else {\n      if (wd.back) {\n        this.st = this.puz.combine(this.st, wd.apd.backward);\n      } else {\n        this.st = this.puz.combine(this.st, wd.apd.forward);\n      }\n    }\n    return false;\n  }\n}\nexport function invertBlockMove(bm: BlockMove): BlockMove {\n  return new BlockMove(bm.outerLayer, bm.innerLayer, bm.family, -bm.amount);\n}\nconst countAnimatedMovesInstance = new CountAnimatedMoves();\nexport const countAnimatedMoves = countAnimatedMovesInstance.traverse.bind(\n  countAnimatedMovesInstance,\n);\n", "import { BlockMove, Sequence } from \"../../../alg\";\nimport { PuzzleWrapper, State } from \"../../3D/puzzles/KPuzzleWrapper\";\nimport {\n  AlgIndexer,\n  AlgPartDecoration,\n  AlgWalker,\n  DecoratorConstructor,\n  invertBlockMove,\n} from \"./AlgIndexer\";\nimport { Timestamp, Duration } from \"./CursorTypes\";\n\nexport class TreeAlgIndexer<P extends PuzzleWrapper> implements AlgIndexer<P> {\n  private decoration: AlgPartDecoration<P>;\n  private walker: AlgWalker<P>;\n  constructor(private puzzle: P, alg: Sequence) {\n    const deccon = new DecoratorConstructor<P>(this.puzzle);\n    this.decoration = deccon.traverse(alg);\n    this.walker = new AlgWalker<P>(this.puzzle, alg, this.decoration);\n  }\n\n  public getMove(index: number): BlockMove {\n    // FIXME need to support Pause\n    if (this.walker.moveByIndex(index)) {\n      if (!this.walker.mv) {\n        throw new Error(\"`this.walker.mv` missing\");\n      }\n      const bm = this.walker.mv as BlockMove;\n      // TODO: this type of negation needs to be in alg\n      if (this.walker.back) {\n        return invertBlockMove(bm);\n      }\n      return bm;\n    }\n    throw new Error(\"Out of algorithm: index \" + index);\n  }\n\n  public indexToMoveStartTimestamp(index: number): Timestamp {\n    if (this.walker.moveByIndex(index) || this.walker.i === index) {\n      return this.walker.dur;\n    }\n    throw new Error(\"Out of algorithm: index \" + index);\n  }\n\n  public stateAtIndex(index: number, startTransformation?: State<P>): State<P> {\n    this.walker.moveByIndex(index);\n    return this.puzzle.combine(\n      startTransformation ?? this.puzzle.startState(),\n      this.walker.st,\n    );\n  }\n\n  // TransformAtIndex does not reflect the start state; it only reflects\n  // the change from the start state to the current move index.  If you\n  // want the actual state, use stateAtIndex.\n  public transformAtIndex(index: number): State<P> {\n    this.walker.moveByIndex(index);\n    return this.walker.st;\n  }\n\n  public numMoves(): number {\n    return this.decoration.moveCount;\n  }\n\n  public timestampToIndex(timestamp: Timestamp): number {\n    this.walker.moveByDuration(timestamp);\n    return this.walker.i;\n  }\n\n  public algDuration(): Duration {\n    return this.decoration.duration;\n  }\n\n  public moveDuration(index: number): number {\n    this.walker.moveByIndex(index);\n    return this.walker.moveDur;\n  }\n}\n", "/* eslint-disable no-case-declarations */\n// TODO: private vs. public properties/methods.\n// TODO: optional construtor arguments for DOM elements\n// TODO: figure out what can be moved into a worker using OffscreenCanvas https://developers.google.com/web/updates/2018/08/offscreen-canvas\n\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\n// start of imports\nimport { Sequence } from \"../../../alg\";\nimport { KPuzzle, KPuzzleDefinition, Transformation } from \"../../../kpuzzle\";\nimport { KPuzzleWrapper } from \"../../3D/puzzles/KPuzzleWrapper\";\nimport { Timeline, TimelineTimestampListener } from \"../Timeline\";\nimport {\n  Direction,\n  directionScalar,\n  PuzzlePosition,\n  MillisecondTimestamp,\n} from \"./CursorTypes\";\nimport { TreeAlgIndexer } from \"./TreeAlgIndexer\";\n// end of imports\n\n// Model\n\nexport interface PositionListener {\n  onPositionChange(position: PuzzlePosition): void;\n}\n\nexport interface PositionDispatcher {\n  addPositionListener(positionListener: PositionListener): void;\n}\n\nexport interface TimeRange {\n  start: MillisecondTimestamp;\n  end: MillisecondTimestamp;\n}\n\nexport class AlgCursor\n  implements TimelineTimestampListener, PositionDispatcher {\n  private todoIndexer: TreeAlgIndexer<KPuzzleWrapper>;\n  private positionListeners: Set<PositionListener> = new Set(); // TODO: accessor instead of direct access\n  private ksolvePuzzle: KPuzzleWrapper;\n  private startState: Transformation;\n  constructor(\n    private timeline: Timeline,\n    private def: KPuzzleDefinition,\n    private alg: Sequence,\n    startStateSequence?: Sequence, // TODO: accept actual start state\n  ) {\n    timeline.addTimestampListener(this);\n    this.ksolvePuzzle = new KPuzzleWrapper(def);\n    this.todoIndexer = new TreeAlgIndexer(this.ksolvePuzzle, alg);\n    this.startState = startStateSequence\n      ? this.algToState(startStateSequence)\n      : this.ksolvePuzzle.startState();\n  }\n\n  setStartState(startState: Transformation): void {\n    this.startState = startState;\n    this.dispatchPositionForTimestamp(this.timeline.timestamp);\n  }\n\n  /** @deprecated */\n  algToState(s: Sequence): Transformation {\n    const kpuzzle = new KPuzzle(this.def);\n    kpuzzle.applyAlg(s);\n    return this.ksolvePuzzle.combine(this.def.startPieces, kpuzzle.state);\n  }\n\n  timeRange(): TimeRange {\n    return {\n      start: 0,\n      end: this.todoIndexer.algDuration(),\n    };\n  }\n\n  /** @deprecated */\n  experimentalTimestampForStartOfLastMove(): MillisecondTimestamp {\n    const numMoves = this.todoIndexer.numMoves();\n    if (numMoves > 0) {\n      return this.todoIndexer.indexToMoveStartTimestamp(numMoves - 1);\n    }\n    return 0;\n  }\n\n  addPositionListener(positionListener: PositionListener): void {\n    this.positionListeners.add(positionListener);\n    this.dispatchPositionForTimestamp(this.timeline.timestamp, [\n      positionListener,\n    ]); // TODO: should this be a separate dispatch, or should the listener manually ask for the position?\n  }\n\n  removePositionListener(positionListener: PositionListener): void {\n    this.positionListeners.delete(positionListener);\n  }\n\n  onTimelineTimestampChange(timestamp: MillisecondTimestamp): void {\n    this.dispatchPositionForTimestamp(timestamp);\n  }\n\n  private dispatchPositionForTimestamp(\n    timestamp: MillisecondTimestamp,\n    listeners: PositionListener[] | Set<PositionListener> = this\n      .positionListeners,\n  ): void {\n    const idx = this.todoIndexer.timestampToIndex(timestamp);\n    const state = this.todoIndexer.stateAtIndex(idx, this.startState) as any; // TODO\n    const position: PuzzlePosition = {\n      state,\n      movesInProgress: [],\n    };\n\n    if (this.todoIndexer.numMoves() > 0) {\n      const fraction =\n        (timestamp - this.todoIndexer.indexToMoveStartTimestamp(idx)) /\n        this.todoIndexer.moveDuration(idx);\n      if (fraction === 1) {\n        // TODO: push this into the indexer\n        position.state = this.ksolvePuzzle.combine(\n          state,\n          this.ksolvePuzzle.stateFromMove(this.todoIndexer.getMove(idx)),\n        ) as Transformation;\n      } else if (fraction > 0) {\n        position.movesInProgress.push({\n          move: this.todoIndexer.getMove(idx),\n          direction: Direction.Forwards,\n          fraction,\n        });\n      }\n    }\n\n    for (const listener of listeners) {\n      listener.onPositionChange(position);\n    }\n  }\n\n  onTimeRangeChange(_timeRange: TimeRange): void {\n    // nothing to do\n  }\n\n  setAlg(alg: Sequence): void {\n    this.todoIndexer = new TreeAlgIndexer(this.ksolvePuzzle, alg);\n    this.timeline.onCursorChange(this);\n    this.dispatchPositionForTimestamp(this.timeline.timestamp);\n    // TODO: Handle state change.\n  }\n\n  moveBoundary(\n    timestamp: MillisecondTimestamp,\n    direction: Direction.Backwards | Direction.Forwards,\n  ): MillisecondTimestamp | null {\n    if (this.todoIndexer.numMoves() === 0) {\n      return null;\n    }\n    // TODO: define semantics of indexing edge cases and remove this hack.\n    const offsetHack = directionScalar(direction) * 0.001;\n    const idx = this.todoIndexer.timestampToIndex(timestamp + offsetHack);\n    const moveStart = this.todoIndexer.indexToMoveStartTimestamp(idx);\n\n    if (direction === Direction.Backwards) {\n      return timestamp >= moveStart ? moveStart : null;\n    } else {\n      const moveEnd = moveStart + this.todoIndexer.moveDuration(idx);\n      return timestamp <= moveEnd ? moveEnd : null;\n    }\n  }\n\n  setPuzzle(\n    def: KPuzzleDefinition,\n    alg: Sequence = this.alg,\n    startStateSequence?: Sequence,\n  ): void {\n    this.ksolvePuzzle = new KPuzzleWrapper(def);\n    this.def = def;\n    this.todoIndexer = new TreeAlgIndexer(this.ksolvePuzzle, alg);\n    if (alg !== this.alg) {\n      this.timeline.onCursorChange(this);\n    }\n    this.setStartState(\n      startStateSequence\n        ? this.algToState(startStateSequence)\n        : this.ksolvePuzzle.startState(),\n    );\n    this.alg = alg;\n  }\n}\n", "import { RenderScheduler } from \"./RenderScheduler\";\nimport { AlgCursor, TimeRange } from \"./alg/AlgCursor\";\nimport {\n  BoundaryType,\n  Direction,\n  directionScalar,\n  MillisecondTimestamp,\n} from \"./alg/CursorTypes\";\n\n// TODO: We use symbols to avoid exposing `number` values. Is this performant enough? Should/can we use symbols?\nexport enum TimelineAction {\n  StartingToPlay = \"StartingToPlay\", // TODO playing backwards.\n  Pausing = \"Pausing\",\n  Jumping = \"Jumping\",\n}\n\n// TODO: We use symbols to avoid exposing `number` values. Is this performant enough? Should/can we use symbols?\nexport enum TimestampLocationType {\n  StartOfTimeline = \"Start\",\n  EndOfTimeline = \"End\",\n  StartOfMove = \"StartOfMove\",\n  EndOfMove = \"EndOfMove\",\n  MiddleOfMove = \"MiddleOfMove\",\n  BetweenMoves = \"BetweenMoves\",\n}\n\nexport interface TimelineActionEvent {\n  action: TimelineAction;\n  locationType: TimestampLocationType;\n}\n\n// This should be used by classes that (directly or indirectly) update puzzle\n// state based on a timestamp. It fires every time the timestamp is changed for\n// a new render (e.g. 60 times a second during animation), and only fires if the\n// timestamp has changed since the last call. This means you can use it as a\n// reliable callback telling you when to schedule a new render.\nexport interface TimelineTimestampListener {\n  onTimelineTimestampChange(timestamp: MillisecondTimestamp): void;\n  onTimeRangeChange(timeRange: TimeRange): void;\n}\n\n// This should be used by classes that (directly or indirectly) update UI (e.g.\n// pause/play buttons).\n//\n// Note: the action events of a `Timeline` are not necessarily coordinated with\n// the timestamp events, since timestamp events are tied to animation frames.\n// For example, if you receive a \"pausing\" event, the final frame may already\n// have been drawn, or may be drawn in the near future.\nexport interface TimelineActionListener {\n  onTimelineAction(actionEvent: TimelineActionEvent): void;\n}\n\nexport interface TimelineTimestampDispatcher {\n  addTimestampListener(timestampListener: TimelineTimestampListener): void;\n}\n\nexport interface TimelineActionDispatcher {\n  addActionListener(actionListener: TimelineActionListener): void;\n}\n\n// `performance.now()` is rounded for security concerns, so it's usually not\n// accurate to the millisecond. So we round it, which lets us work with whole ms\n// everywhere.\nfunction getNow(): MillisecondTimestamp {\n  return Math.round(performance.now());\n}\n\nexport class Timeline\n  implements TimelineTimestampDispatcher, TimelineActionDispatcher {\n  animating: boolean = false;\n  tempoScale: number = 1;\n  private cursors: Set<AlgCursor> = new Set();\n  private timestampListeners: Set<TimelineTimestampListener> = new Set();\n  private actionListeners: Set<TimelineActionListener> = new Set();\n  timestamp: number = 0;\n  lastAnimFrameNow: DOMHighResTimeStamp = 0;\n  lastAnimFrameTimestamp: MillisecondTimestamp;\n  private scheduler: RenderScheduler;\n\n  direction: Direction.Backwards | Direction.Forwards = Direction.Forwards; // TODO: handle pausing here?\n\n  boundaryType: BoundaryType = BoundaryType.EntireTimeline;\n  cachedNextBoundary: MillisecondTimestamp;\n\n  constructor() {\n    const animFrame = (_now: MillisecondTimestamp): void => {\n      if (this.animating) {\n        const now = getNow(); // TODO: See if we can use the rAF value without monotonicity issues.;\n        this.timestamp =\n          this.timestamp +\n          this.tempoScale *\n            directionScalar(this.direction) *\n            (now - this.lastAnimFrameNow);\n        this.lastAnimFrameNow = now;\n\n        const atOrPastBoundary =\n          this.direction === Direction.Backwards\n            ? this.timestamp <= this.cachedNextBoundary\n            : this.timestamp >= this.cachedNextBoundary;\n        if (atOrPastBoundary) {\n          this.timestamp = this.cachedNextBoundary;\n          if (this.animating) {\n            this.animating = false;\n            this.dispatchAction(TimelineAction.Pausing);\n          }\n        }\n      }\n\n      if (this.timestamp !== this.lastAnimFrameTimestamp) {\n        this.dispatchTimestamp();\n        this.lastAnimFrameTimestamp = this.timestamp;\n      }\n\n      if (this.animating) {\n        this.scheduler.requestAnimFrame();\n      }\n    };\n    this.scheduler = new RenderScheduler(animFrame);\n  }\n\n  public addCursor(cursor: AlgCursor): void {\n    this.cursors.add(cursor);\n    this.dispatchTimeRange();\n  }\n\n  removeCursor(cursor: AlgCursor): void {\n    this.cursors.delete(cursor);\n    this.clampTimestampToRange();\n    this.dispatchTimeRange();\n  }\n\n  // TODO: test\n  private clampTimestampToRange(): void {\n    const timeRange = this.timeRange();\n    if (this.timestamp < timeRange.start) {\n      this.setTimestamp(timeRange.start);\n    }\n    if (this.timestamp > timeRange.end) {\n      this.setTimestamp(timeRange.end);\n    }\n  }\n\n  // In the future, this might do some calculations or caching.\n  public onCursorChange(_cursor: AlgCursor): void {\n    if (this.timestamp > this.maxTimestamp()) {\n      this.timestamp = this.maxTimestamp();\n    }\n    this.dispatchTimeRange();\n  }\n\n  timeRange(): TimeRange {\n    let start = 0;\n    let end = 0;\n    for (const cursor of this.cursors) {\n      const cursorTimeRange = cursor.timeRange();\n      start = Math.min(start, cursorTimeRange.start);\n      end = Math.max(end, cursorTimeRange.end);\n    }\n\n    return { start, end };\n  }\n\n  minTimestamp(): number {\n    // TODO: Calculate and cache this value every time there's a new cursor.\n    return this.timeRange().start;\n  }\n\n  maxTimestamp(): number {\n    // TODO: Calculate and cache this value every time there's a new cursor.\n    return this.timeRange().end;\n  }\n\n  private dispatchTimeRange(): void {\n    const timeRange = this.timeRange();\n    for (const listener of this.cursors) {\n      // TODO: dedup in case the timestamp hasn't changed sine last time.\n      listener.onTimeRangeChange(timeRange);\n    }\n    // TODO: Combine loops without extra memory?\n    for (const listener of this.timestampListeners) {\n      // TODO: dedup in case the timestamp hasn't changed sine last time.\n      listener.onTimeRangeChange(timeRange);\n    }\n  }\n\n  private dispatchTimestamp(): void {\n    for (const listener of this.cursors) {\n      // TODO: dedup in case the timestamp hasn't changed sine last time.\n      listener.onTimelineTimestampChange(this.timestamp);\n    }\n    // TODO: Combine loops without extra memory?\n    for (const listener of this.timestampListeners) {\n      // TODO: dedup in case the timestamp hasn't changed sine last time.\n      listener.onTimelineTimestampChange(this.timestamp);\n    }\n  }\n\n  addTimestampListener(timestampListener: TimelineTimestampListener): void {\n    this.timestampListeners.add(timestampListener);\n  }\n\n  removeTimestampListener(timestampListener: TimelineTimestampListener): void {\n    this.timestampListeners.delete(timestampListener);\n  }\n\n  addActionListener(actionListener: TimelineActionListener): void {\n    this.actionListeners.add(actionListener);\n  }\n\n  removeActionListener(actionListener: TimelineActionListener): void {\n    this.actionListeners.delete(actionListener);\n  }\n\n  play(): void {\n    this.experimentalPlay(Direction.Forwards, BoundaryType.EntireTimeline);\n  }\n\n  experimentalPlay(\n    direction: Direction.Backwards | Direction.Forwards,\n    boundaryType: BoundaryType = BoundaryType.EntireTimeline,\n  ): void {\n    this.direction = direction;\n    this.boundaryType = boundaryType;\n    const nextBoundary = this.nextBoundary(\n      this.timestamp,\n      direction,\n      this.boundaryType,\n    );\n    if (nextBoundary === null) {\n      return; // Nowhere to end, so we don't animate.\n    }\n    this.cachedNextBoundary = nextBoundary;\n    if (!this.animating) {\n      this.animating = true;\n      this.lastAnimFrameNow = getNow();\n      this.dispatchAction(TimelineAction.StartingToPlay);\n      this.scheduler.requestAnimFrame();\n    }\n  }\n\n  // Non-inclusive\n  private nextBoundary(\n    timestamp: MillisecondTimestamp,\n    direction: Direction.Backwards | Direction.Forwards,\n    boundaryType: BoundaryType = BoundaryType.EntireTimeline,\n  ): MillisecondTimestamp | null {\n    switch (boundaryType) {\n      case BoundaryType.EntireTimeline: {\n        switch (direction) {\n          case Direction.Backwards:\n            return timestamp <= this.minTimestamp()\n              ? null\n              : this.minTimestamp();\n          case Direction.Forwards:\n            return timestamp >= this.maxTimestamp()\n              ? null\n              : this.maxTimestamp();\n          default:\n            throw new Error(\"invalid direction\");\n        }\n      }\n      case BoundaryType.Move: {\n        let result: null | MillisecondTimestamp = null;\n        for (const cursor of this.cursors) {\n          const boundaryTimestamp = cursor.moveBoundary(timestamp, direction);\n          if (boundaryTimestamp !== null) {\n            switch (direction) {\n              case Direction.Backwards: {\n                result = Math.min(\n                  result ?? boundaryTimestamp,\n                  boundaryTimestamp,\n                );\n                break;\n              }\n              case Direction.Forwards: {\n                result = Math.max(\n                  result ?? boundaryTimestamp,\n                  boundaryTimestamp,\n                );\n                break;\n              }\n              default:\n                throw new Error(\"invalid direction\");\n            }\n          }\n        }\n        return result;\n      }\n      default:\n        throw new Error(\"invalid boundary type\");\n    }\n  }\n\n  // One more render may be dispatched after this.\n  pause(): void {\n    // TODO: error if already paused?\n    if (this.animating) {\n      this.animating = false;\n      this.dispatchAction(TimelineAction.Pausing);\n      this.scheduler.requestAnimFrame();\n    }\n  }\n\n  playPause(): void {\n    if (this.animating) {\n      this.pause();\n    } else {\n      if (this.timestamp >= this.maxTimestamp()) {\n        this.timestamp = 0;\n      }\n      this.experimentalPlay(Direction.Forwards, BoundaryType.EntireTimeline);\n    }\n  }\n\n  setTimestamp(timestamp: MillisecondTimestamp): void {\n    this.animating = false;\n    const oldTimestamp = this.timestamp;\n    this.timestamp = timestamp;\n    this.lastAnimFrameNow = getNow();\n\n    if (oldTimestamp !== timestamp) {\n      this.dispatchAction(TimelineAction.Jumping);\n      this.scheduler.requestAnimFrame();\n    }\n  }\n\n  jumpToStart(): void {\n    this.setTimestamp(this.minTimestamp());\n  }\n\n  jumpToEnd(): void {\n    this.setTimestamp(this.maxTimestamp());\n  }\n\n  /** @deprecated */\n  experimentalJumpToLastMove(): void {\n    let max: MillisecondTimestamp = 0;\n    for (const cursor of this.cursors) {\n      max = Math.max(\n        max,\n        cursor.experimentalTimestampForStartOfLastMove() ?? 0,\n      );\n    }\n    this.setTimestamp(max);\n  }\n\n  private dispatchAction(event: TimelineAction): void {\n    let locationType = TimestampLocationType.MiddleOfMove; // TODO\n    switch (this.timestamp) {\n      // TODO\n      case this.minTimestamp():\n        locationType = TimestampLocationType.StartOfTimeline;\n        break;\n      case this.maxTimestamp():\n        locationType = TimestampLocationType.EndOfTimeline;\n        break;\n    }\n\n    const actionEvent: TimelineActionEvent = {\n      action: event,\n      locationType,\n    };\n    for (const listener of this.actionListeners) {\n      listener.onTimelineAction(actionEvent);\n    }\n  }\n}\n", "import { CSSSource } from \"../element/ManagedCustomElement\";\n\nexport const buttonGridCSS = new CSSSource(`\n.wrapper {\n  width: 100%;\n  height: 100%;\n\n  display: grid;\n  grid-template-columns: repeat(6, 1fr);\n}\n`);\n\nexport const buttonCSS = new CSSSource(`\n.wrapper {\n  width: 100%;\n  height: 100%;\n}\n\nbutton {\n  width: 100%;\n  height: 100%;\n  border: none;\n  \n  background-position: center;\n  background-repeat: no-repeat;\n  background-size: contain;\n\n  background-color: rgba(196, 196, 196, 0.75);\n}\n\nbutton:enabled {\n  background-color: rgba(196, 196, 196, 0.75)\n}\n\nbutton:disabled {\n  background-color: rgba(0, 0, 0, 0.4);\n  opacity: 0.25;\n}\n\nbutton:enabled:hover {\n  background-color: rgba(255, 255, 255, 0.75);\n  box-shadow: 0 0 1em rgba(0, 0, 0, 0.25);\n  cursor: pointer;\n}\n\n/* TODO: fullscreen icons have too much padding?? */\nbutton.svg-skip-to-start {\n  background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzNTg0IiBoZWlnaHQ9IjM1ODQiIHZpZXdCb3g9IjAgMCAzNTg0IDM1ODQiPjxwYXRoIGQ9Ik0yNjQzIDEwMzdxMTktMTkgMzItMTN0MTMgMzJ2MTQ3MnEwIDI2LTEzIDMydC0zMi0xM2wtNzEwLTcxMHEtOS05LTEzLTE5djcxMHEwIDI2LTEzIDMydC0zMi0xM2wtNzEwLTcxMHEtOS05LTEzLTE5djY3OHEwIDI2LTE5IDQ1dC00NSAxOUg5NjBxLTI2IDAtNDUtMTl0LTE5LTQ1VjEwODhxMC0yNiAxOS00NXQ0NS0xOWgxMjhxMjYgMCA0NSAxOXQxOSA0NXY2NzhxNC0xMSAxMy0xOWw3MTAtNzEwcTE5LTE5IDMyLTEzdDEzIDMydjcxMHE0LTExIDEzLTE5eiIvPjwvc3ZnPg==\");\n}\n\nbutton.svg-skip-to-end {\n  background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzNTg0IiBoZWlnaHQ9IjM1ODQiIHZpZXdCb3g9IjAgMCAzNTg0IDM1ODQiPjxwYXRoIGQ9Ik05NDEgMjU0N3EtMTkgMTktMzIgMTN0LTEzLTMyVjEwNTZxMC0yNiAxMy0zMnQzMiAxM2w3MTAgNzEwcTggOCAxMyAxOXYtNzEwcTAtMjYgMTMtMzJ0MzIgMTNsNzEwIDcxMHE4IDggMTMgMTl2LTY3OHEwLTI2IDE5LTQ1dDQ1LTE5aDEyOHEyNiAwIDQ1IDE5dDE5IDQ1djE0MDhxMCAyNi0xOSA0NXQtNDUgMTloLTEyOHEtMjYgMC00NS0xOXQtMTktNDV2LTY3OHEtNSAxMC0xMyAxOWwtNzEwIDcxMHEtMTkgMTktMzIgMTN0LTEzLTMydi03MTBxLTUgMTAtMTMgMTl6Ii8+PC9zdmc+\");\n}\n\nbutton.svg-step-forward {\n  background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzNTg0IiBoZWlnaHQ9IjM1ODQiIHZpZXdCb3g9IjAgMCAzNTg0IDM1ODQiPjxwYXRoIGQ9Ik0yNjg4IDE1NjhxMCAyNi0xOSA0NWwtNTEyIDUxMnEtMTkgMTktNDUgMTl0LTQ1LTE5cS0xOS0xOS0xOS00NXYtMjU2aC0yMjRxLTk4IDAtMTc1LjUgNnQtMTU0IDIxLjVxLTc2LjUgMTUuNS0xMzMgNDIuNXQtMTA1LjUgNjkuNXEtNDkgNDIuNS04MCAxMDF0LTQ4LjUgMTM4LjVxLTE3LjUgODAtMTcuNSAxODEgMCA1NSA1IDEyMyAwIDYgMi41IDIzLjV0Mi41IDI2LjVxMCAxNS04LjUgMjV0LTIzLjUgMTBxLTE2IDAtMjgtMTctNy05LTEzLTIydC0xMy41LTMwcS03LjUtMTctMTAuNS0yNC0xMjctMjg1LTEyNy00NTEgMC0xOTkgNTMtMzMzIDE2Mi00MDMgODc1LTQwM2gyMjR2LTI1NnEwLTI2IDE5LTQ1dDQ1LTE5cTI2IDAgNDUgMTlsNTEyIDUxMnExOSAxOSAxOSA0NXoiLz48L3N2Zz4=\");\n}\n\nbutton.svg-step-backward {\n  background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzNTg0IiBoZWlnaHQ9IjM1ODQiIHZpZXdCb3g9IjAgMCAzNTg0IDM1ODQiPjxwYXRoIGQ9Ik0yNjg4IDIwNDhxMCAxNjYtMTI3IDQ1MS0zIDctMTAuNSAyNHQtMTMuNSAzMHEtNiAxMy0xMyAyMi0xMiAxNy0yOCAxNy0xNSAwLTIzLjUtMTB0LTguNS0yNXEwLTkgMi41LTI2LjV0Mi41LTIzLjVxNS02OCA1LTEyMyAwLTEwMS0xNy41LTE4MXQtNDguNS0xMzguNXEtMzEtNTguNS04MC0xMDF0LTEwNS41LTY5LjVxLTU2LjUtMjctMTMzLTQyLjV0LTE1NC0yMS41cS03Ny41LTYtMTc1LjUtNmgtMjI0djI1NnEwIDI2LTE5IDQ1dC00NSAxOXEtMjYgMC00NS0xOWwtNTEyLTUxMnEtMTktMTktMTktNDV0MTktNDVsNTEyLTUxMnExOS0xOSA0NS0xOXQ0NSAxOXExOSAxOSAxOSA0NXYyNTZoMjI0cTcxMyAwIDg3NSA0MDMgNTMgMTM0IDUzIDMzM3oiLz48L3N2Zz4=\");\n}\n\nbutton.svg-pause {\n  background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzNTg0IiBoZWlnaHQ9IjM1ODQiIHZpZXdCb3g9IjAgMCAzNTg0IDM1ODQiPjxwYXRoIGQ9Ik0yNTYwIDEwODh2MTQwOHEwIDI2LTE5IDQ1dC00NSAxOWgtNTEycS0yNiAwLTQ1LTE5dC0xOS00NVYxMDg4cTAtMjYgMTktNDV0NDUtMTloNTEycTI2IDAgNDUgMTl0MTkgNDV6bS04OTYgMHYxNDA4cTAgMjYtMTkgNDV0LTQ1IDE5aC01MTJxLTI2IDAtNDUtMTl0LTE5LTQ1VjEwODhxMC0yNiAxOS00NXQ0NS0xOWg1MTJxMjYgMCA0NSAxOXQxOSA0NXoiLz48L3N2Zz4=\");\n}\n\nbutton.svg-play {\n  background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzNTg0IiBoZWlnaHQ9IjM1ODQiIHZpZXdCb3g9IjAgMCAzNTg0IDM1ODQiPjxwYXRoIGQ9Ik0yNDcyLjUgMTgyM2wtMTMyOCA3MzhxLTIzIDEzLTM5LjUgM3QtMTYuNS0zNlYxMDU2cTAtMjYgMTYuNS0zNnQzOS41IDNsMTMyOCA3MzhxMjMgMTMgMjMgMzF0LTIzIDMxeiIvPjwvc3ZnPg==\");\n}\n\nbutton.svg-enter-fullscreen {\n  background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjgiIHZpZXdCb3g9IjAgMCAyOCAyOCIgd2lkdGg9IjI4Ij48cGF0aCBkPSJNMiAyaDI0djI0SDJ6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTkgMTZIN3Y1aDV2LTJIOXYtM3ptLTItNGgyVjloM1Y3SDd2NXptMTIgN2gtM3YyaDV2LTVoLTJ2M3pNMTYgN3YyaDN2M2gyVjdoLTV6Ii8+PC9zdmc+\");\n}\n\nbutton.svg-exit-fullscreen {\n  background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjgiIHZpZXdCb3g9IjAgMCAyOCAyOCIgd2lkdGg9IjI4Ij48cGF0aCBkPSJNMiAyaDI0djI0SDJ6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTcgMThoM3YzaDJ2LTVIN3Yyem0zLThIN3YyaDVWN2gtMnYzem02IDExaDJ2LTNoM3YtMmgtNXY1em0yLTExVjdoLTJ2NWg1di0yaC0zeiIvPjwvc3ZnPg==\");\n}\n`);\n", "import { TimeRange } from \"../../animation/alg/AlgCursor\";\nimport {\n  BoundaryType,\n  Direction,\n  MillisecondTimestamp,\n} from \"../../animation/alg/CursorTypes\";\nimport {\n  Timeline,\n  TimelineAction,\n  TimelineActionEvent,\n  TimestampLocationType,\n} from \"../../animation/Timeline\";\nimport { ManagedCustomElement } from \"../element/ManagedCustomElement\";\nimport { customElementsShim } from \"../element/node-custom-element-shims\";\nimport { buttonCSS, buttonGridCSS } from \"./buttons.css\";\nimport { TwistyControlElement } from \"./TwistyControlElement.ts\";\n\ntype TimelineCommand =\n  | \"fullscreen\"\n  | \"jump-to-start\"\n  | \"play-pause\" // TODO: toggle-play?\n  // | \"play\"\n  // | \"play-backwards\"\n  | \"play-step-backwards\"\n  | \"play-step\"\n  | \"jump-to-end\";\n\n// TODO: combine this with disabled status and label in a state machine?\ntype ButtonIconName =\n  | \"skip-to-start\"\n  | \"skip-to-end\"\n  | \"step-forward\"\n  | \"step-backward\"\n  | \"pause\"\n  | \"play\"\n  | \"enter-fullscreen\"\n  | \"exit-fullscreen\";\n\nclass TwistyControlButton\n  extends ManagedCustomElement\n  implements TwistyControlElement {\n  private timeline: Timeline;\n  private timelineCommand: TimelineCommand;\n  private currentIconName: string | null = null;\n  protected button: HTMLButtonElement = document.createElement(\"button\");\n  constructor(\n    timeline?: Timeline,\n    timelineCommand?: TimelineCommand,\n    private fullscreenElement?: Element, // TODO: reflect as an element attribute?\n  ) {\n    super();\n\n    if (!timeline) {\n      console.log(\"Must have timeline!\"); // TODO\n    }\n    this.timeline = timeline!;\n    if (!timelineCommand) {\n      console.log(\"Must have timelineCommand!\"); // TODO\n    }\n    this.timelineCommand = timelineCommand!;\n\n    this.addCSS(buttonCSS);\n    this.setIcon(this.initialIcon());\n    this.setHoverTitle(this.initialHoverTitle());\n    this.addElement(this.button);\n    this.addEventListener(\"click\", this.onPress.bind(this));\n\n    switch (this.timelineCommand!) {\n      case \"fullscreen\":\n        if (!document.fullscreenEnabled) {\n          this.button.disabled = true;\n        }\n        break;\n      case \"jump-to-start\":\n      case \"play-step-backwards\":\n        this.button.disabled = true;\n        break;\n    }\n\n    this.timeline!.addActionListener(this);\n    switch (this.timelineCommand!) {\n      case \"play-pause\":\n      case \"play-step-backwards\":\n      case \"play-step\":\n        this.timeline!.addTimestampListener(this);\n        break;\n    }\n\n    this.autoSetTimelineBasedDisabled();\n  }\n\n  // TODO: Can we avoid duplicate calculations?\n  private autoSetTimelineBasedDisabled(): void {\n    switch (this.timelineCommand!) {\n      case \"jump-to-start\":\n      case \"play-pause\":\n      case \"play-step-backwards\":\n      case \"play-step\":\n      case \"jump-to-end\": {\n        const timeRange = this.timeline.timeRange();\n        if (timeRange.start === timeRange.end) {\n          this.button.disabled = true;\n          return;\n        }\n        switch (this.timelineCommand!) {\n          case \"jump-to-start\":\n          case \"play-step-backwards\":\n            this.button.disabled =\n              this.timeline.timestamp < this.timeline.maxTimestamp();\n            break;\n          case \"jump-to-end\":\n          case \"play-step\":\n            this.button.disabled =\n              this.timeline.timestamp > this.timeline.minTimestamp();\n            break;\n          default:\n            this.button.disabled = false;\n        }\n        break;\n      }\n    }\n  }\n\n  setIcon(buttonIconName: ButtonIconName): void {\n    if (this.currentIconName === buttonIconName) {\n      return;\n    }\n    if (this.currentIconName) {\n      this.button.classList.remove(`svg-${this.currentIconName}`);\n    }\n    this.button.classList.add(`svg-${buttonIconName}`);\n    this.currentIconName = buttonIconName;\n  }\n\n  private initialIcon(): ButtonIconName {\n    const map: Record<TimelineCommand, ButtonIconName> = {\n      \"jump-to-start\": \"skip-to-start\",\n      \"play-pause\": \"play\",\n      \"play-step\": \"step-forward\",\n      \"play-step-backwards\": \"step-backward\",\n      \"jump-to-end\": \"skip-to-end\",\n      \"fullscreen\": \"enter-fullscreen\",\n    };\n    return map[this.timelineCommand];\n  }\n\n  private initialHoverTitle(): string {\n    const map: Record<TimelineCommand, string> = {\n      \"jump-to-start\": \"Restart\",\n      \"play-pause\": \"Play\",\n      \"play-step\": \"Step forward\",\n      \"play-step-backwards\": \"Step backward\",\n      \"jump-to-end\": \"Skip to End\",\n      \"fullscreen\": \"Enter fullscreen\",\n    };\n    return map[this.timelineCommand];\n  }\n\n  private setHoverTitle(title: string): void {\n    this.button.title = title;\n  }\n\n  onPress(): void {\n    switch (this.timelineCommand!) {\n      case \"fullscreen\":\n        if (document.fullscreenElement === this.fullscreenElement) {\n          document.exitFullscreen();\n          // this.setIcon(\"enter-fullscreen\");\n        } else {\n          this.setIcon(\"exit-fullscreen\");\n          this.fullscreenElement!.requestFullscreen().then(() => {\n            const onFullscreen = (): void => {\n              if (document.fullscreenElement !== this.fullscreenElement) {\n                this.setIcon(\"enter-fullscreen\");\n                window.removeEventListener(\"fullscreenchange\", onFullscreen);\n              }\n            };\n            window.addEventListener(\"fullscreenchange\", onFullscreen);\n          });\n        }\n        break;\n      case \"jump-to-start\":\n        this.timeline.setTimestamp(0);\n        break;\n      case \"jump-to-end\":\n        this.timeline.jumpToEnd();\n        break;\n      case \"play-pause\":\n        this.timeline.playPause();\n        break;\n      case \"play-step\":\n        this.timeline.experimentalPlay(Direction.Forwards, BoundaryType.Move);\n        break;\n      case \"play-step-backwards\":\n        this.timeline.experimentalPlay(Direction.Backwards, BoundaryType.Move);\n        break;\n    }\n  }\n\n  onTimelineAction(actionEvent: TimelineActionEvent): void {\n    switch (this.timelineCommand!) {\n      case \"jump-to-start\":\n        // TODO: what if you're already playing?\n        this.button.disabled =\n          actionEvent.locationType === TimestampLocationType.StartOfTimeline &&\n          actionEvent.action !== TimelineAction.StartingToPlay;\n        break;\n      case \"jump-to-end\":\n        this.button.disabled =\n          actionEvent.locationType === TimestampLocationType.EndOfTimeline &&\n          actionEvent.action !== TimelineAction.StartingToPlay;\n        break;\n      case \"play-pause\":\n        // Always enabled, since we will jump to the start if needed.\n        switch (actionEvent.action) {\n          case TimelineAction.Pausing:\n            this.setIcon(\"play\");\n            this.setHoverTitle(\"Play\");\n            break;\n          case TimelineAction.StartingToPlay:\n            this.setIcon(\"pause\");\n            this.setHoverTitle(\"Pause\");\n            break;\n          // TODO: does jumping mean pause?\n        }\n        break;\n      case \"play-step\":\n        // TODO: refine this\n        this.button.disabled =\n          actionEvent.locationType === TimestampLocationType.EndOfTimeline &&\n          actionEvent.action !== TimelineAction.StartingToPlay;\n        break;\n      case \"play-step-backwards\":\n        // TODO: refine this\n        this.button.disabled =\n          actionEvent.locationType === TimestampLocationType.StartOfTimeline &&\n          actionEvent.action !== TimelineAction.StartingToPlay;\n        break;\n    }\n  }\n\n  onTimelineTimestampChange(_timestamp: MillisecondTimestamp): void {\n    // Nothing\n  }\n\n  onTimeRangeChange(_timeRange: TimeRange): void {\n    // TODO\n    this.autoSetTimelineBasedDisabled();\n  }\n}\n\ncustomElementsShim.define(\"twisty-control-button\", TwistyControlButton);\n\n// <twisty-control-button-grid>\n// Usually a horizontal line.\nexport class TwistyControlButtonPanel\n  extends ManagedCustomElement\n  implements TwistyControlElement {\n  constructor(timeline?: Timeline, fullscreenElement?: Element) {\n    super();\n    this.addCSS(buttonGridCSS);\n\n    // this.addElement(new TwistyControlButton(timeline!, fullscreenElement!));\n    this.addElement(\n      new TwistyControlButton(timeline!, \"fullscreen\", fullscreenElement),\n    );\n    this.addElement(new TwistyControlButton(timeline!, \"jump-to-start\"));\n    this.addElement(new TwistyControlButton(timeline!, \"play-step-backwards\"));\n    this.addElement(new TwistyControlButton(timeline!, \"play-pause\"));\n    this.addElement(new TwistyControlButton(timeline!, \"play-step\"));\n    this.addElement(new TwistyControlButton(timeline!, \"jump-to-end\"));\n    /*...*/\n  }\n}\n\ncustomElementsShim.define(\n  \"twisty-control-button-panel\",\n  TwistyControlButtonPanel,\n);\n", "import { CSSSource } from \"../element/ManagedCustomElement\";\n\nexport const twistyScrubberCSS = new CSSSource(`\n:host(twisty-scrubber) {\n  width: 384px;\n  height: 16px;\n  contain: content;\n  display: grid;\n\n  background: rgba(196, 196, 196, 0.5);\n}\n\ninput {\n  margin: 0; width: 100%;\n}\n`);\n", "// <twisty-scrubber>\n\nimport { TimeRange } from \"../../animation/alg/AlgCursor\";\nimport { MillisecondTimestamp } from \"../../animation/alg/CursorTypes\";\nimport { Timeline, TimelineTimestampListener } from \"../../animation/Timeline\";\nimport { ManagedCustomElement } from \"../element/ManagedCustomElement\";\nimport { customElementsShim } from \"../element/node-custom-element-shims\";\nimport { TwistyControlElement } from \"./TwistyControlElement.ts\";\nimport { twistyScrubberCSS } from \"./TwistyScrubber.css\";\n\n// Usually a horizontal line.\nexport class TwistyScrubber\n  extends ManagedCustomElement\n  implements TwistyControlElement, TimelineTimestampListener {\n  private timeline: Timeline;\n  range: HTMLInputElement = document.createElement(\"input\"); // type=\"range\"\n  constructor(timeline?: Timeline) {\n    super();\n    this.timeline = timeline!; // TODO\n\n    this.addCSS(twistyScrubberCSS);\n\n    this.timeline!.addTimestampListener(this);\n    this.range.type = \"range\";\n\n    this.range.step = (1).toString();\n    this.range.min = this.timeline!.minTimestamp().toString();\n    this.range.max = this.timeline!.maxTimestamp().toString();\n    this.range.value = this.timeline.timestamp.toString();\n    this.range.addEventListener(\"input\", this.onInput.bind(this));\n\n    this.addElement(this.range);\n  }\n\n  onTimelineTimestampChange(timestamp: MillisecondTimestamp): void {\n    this.range.value = timestamp.toString();\n  }\n\n  onTimeRangeChange(timeRange: TimeRange): void {\n    this.range.min = timeRange.start.toString();\n    this.range.max = timeRange.end.toString();\n  }\n\n  private onInput(): void {\n    this.timeline!.setTimestamp(parseInt(this.range.value, 10));\n  }\n}\n\ncustomElementsShim.define(\"twisty-scrubber\", TwistyScrubber);\n", "import { CSSSource } from \"./element/ManagedCustomElement\";\n\n// TODO: figure out why `:host(twisty-player):fullscreen { background-color: white }` doesn't work.\nexport const twistyPlayerCSS = new CSSSource(`\n:host(twisty-player) {\n  width: 384px;\n  height: 256px;\n  contain: content;\n  display: grid;\n  box-sizing: border-box;\n  border: 1px solid rgba(0, 0, 0, 0.1);\n}\n\n.wrapper {\n  display: grid;\n  grid-template-rows: 7fr 1em 1fr;\n  overflow: hidden;\n}\n\n.wrapper.controls-none {\n  grid-template-rows: 7fr;\n}\n\n.wrapper.controls-none twisty-scrubber,\n.wrapper.controls-none twisty-control-button-panel {\n  display: none;\n}\n\ntwisty-viewer-wrapper {\n  overflow: hidden;\n}\n\ntwisty-scrubber {\n  width: 100%;\n}\n\n.wrapper.checkered {\n  background-color: #EAEAEA;\n  background-image: linear-gradient(45deg, #DDD 25%, transparent 25%, transparent 75%, #DDD 75%, #DDD),\n    linear-gradient(45deg, #DDD 25%, transparent 25%, transparent 75%, #DDD 75%, #DDD);\n  background-size: 32px 32px;\n  background-position: 0 0, 16px 16px;\n}\n`);\n", "import { CSSSource } from \"../element/ManagedCustomElement\";\n\n// TODO: Can we do this without so much nesting, and styling all the nested elems?\nexport const twisty2DSVGCSS = new CSSSource(`\n.wrapper,\n.svg-wrapper,\ntwisty-2d-svg,\nsvg {\n  width: 100%;\n  height: 100%;\n  display: grid;\n  min-height: 0;\n}\n`);\n", "import { BlockMove } from \"../../../alg\";\nimport {\n  Combine,\n  KPuzzleDefinition,\n  Puzzles,\n  stateForBlockMove,\n  SVG,\n  Transformation,\n} from \"../../../kpuzzle\";\nimport {\n  PositionDispatcher,\n  PositionListener,\n} from \"../../animation/alg/AlgCursor\";\nimport { RenderScheduler } from \"../../animation/RenderScheduler\";\nimport { ManagedCustomElement } from \"../element/ManagedCustomElement\";\nimport { twisty2DSVGCSS } from \"./Twisty2DSVGView.css\";\nimport { TwistyViewerElement } from \"./TwistyViewerElement\";\nimport { PuzzlePosition } from \"../../animation/alg/CursorTypes\";\nimport { customElementsShim } from \"../element/node-custom-element-shims\";\n\n// <twisty-2d-svg>\nexport class Twisty2DSVG\n  extends ManagedCustomElement\n  implements TwistyViewerElement, PositionListener {\n  private definition: KPuzzleDefinition;\n  private svg: SVG;\n  private scheduler = new RenderScheduler(this.render.bind(this));\n  constructor(\n    cursor?: PositionDispatcher,\n    def: KPuzzleDefinition = Puzzles[\"3x3x3\"],\n  ) {\n    super();\n    this.addCSS(twisty2DSVGCSS);\n\n    this.definition = def;\n    this.svg = new SVG(this.definition);\n    this.addElement(this.svg.element);\n    cursor!.addPositionListener(this);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars-experimental\n  onPositionChange(position: PuzzlePosition): void {\n    if (position.movesInProgress.length > 0) {\n      const move = position.movesInProgress[0].move as BlockMove;\n\n      const def = this.definition;\n      const partialMove = new BlockMove(\n        move.outerLayer,\n        move.innerLayer,\n        move.family,\n        move.amount * position.movesInProgress[0].direction,\n      );\n      const newState = Combine(\n        def,\n        position.state as Transformation,\n        stateForBlockMove(def, partialMove),\n      );\n      // TODO: move to render()\n      this.svg.draw(\n        this.definition,\n        position.state as Transformation,\n        newState,\n        position.movesInProgress[0].fraction,\n      );\n    } else {\n      this.svg.draw(this.definition, position.state as Transformation);\n    }\n  }\n\n  scheduleRender(): void {\n    this.scheduler.requestAnimFrame();\n  }\n\n  private render(): void {\n    /*...*/\n  }\n}\n\ncustomElementsShim.define(\"twisty-2d-svg\", Twisty2DSVG);\n", "import { Vector3 } from \"three\";\nimport { countMoves } from \"../../../app/twizzle/move-counter\"; // TODO\nimport { BlockMove, experimentalAppendBlockMove, Sequence } from \"../../alg\";\nimport { parse } from \"../../alg/parser/parser\";\nimport { KPuzzleDefinition, Puzzles } from \"../../kpuzzle\";\nimport {\n  getPuzzleGeometryByName,\n  PuzzleGeometry,\n  StickerDat,\n} from \"../../puzzle-geometry\";\nimport { Cube3D } from \"../3D/puzzles/Cube3D\";\nimport { PG3D } from \"../3D/puzzles/PG3D\";\nimport { Twisty3DPuzzle } from \"../3D/puzzles/Twisty3DPuzzle\";\nimport { Twisty3DScene } from \"../3D/Twisty3DScene\";\nimport { AlgCursor } from \"../animation/alg/AlgCursor\";\nimport {\n  Timeline,\n  TimelineAction,\n  TimelineActionEvent,\n  TimestampLocationType,\n} from \"../animation/Timeline\";\nimport { TwistyControlButtonPanel } from \"./controls/buttons\";\nimport { TwistyControlElement } from \"./controls/TwistyControlElement.ts\";\nimport { TwistyScrubber } from \"./controls/TwistyScrubber\";\nimport { ClassListManager } from \"./element/ClassListManager\";\nimport { ManagedCustomElement } from \"./element/ManagedCustomElement\";\nimport { customElementsShim } from \"./element/node-custom-element-shims\";\nimport { twistyPlayerCSS } from \"./TwistyPlayer.css\";\nimport {\n  BackgroundTheme,\n  centeredCameraPosition,\n  ControlsLocation,\n  cubeCameraPosition,\n  ExperimentalStickering,\n  HintFaceletStyle,\n  PuzzleID,\n  TwistyPlayerConfig,\n  TwistyPlayerInitialConfig,\n  VisualizationFormat,\n} from \"./TwistyPlayerConfig\";\nimport { Twisty2DSVG } from \"./viewers/Twisty2DSVG\";\nimport { Twisty3DCanvas } from \"./viewers/Twisty3DCanvas\";\nimport { TwistyViewerElement } from \"./viewers/TwistyViewerElement\";\nimport {\n  BackViewLayout,\n  TwistyViewerWrapper,\n} from \"./viewers/TwistyViewerWrapper\";\n\nexport interface LegacyExperimentalPG3DViewConfig {\n  def: KPuzzleDefinition;\n  stickerDat: StickerDat;\n  experimentalPolarVantages?: boolean;\n  showFoundation?: boolean;\n}\n\nfunction createPG(puzzleName: string): PuzzleGeometry {\n  const pg = getPuzzleGeometryByName(puzzleName, [\n    \"allmoves\",\n    \"true\",\n    \"orientcenters\",\n    \"true\",\n  ]);\n  return pg;\n}\n\nfunction is3DVisualization(visualizationFormat: VisualizationFormat): boolean {\n  return [\"3D\", \"PG3D\"].includes(visualizationFormat);\n}\n\n// <twisty-player>\nexport class TwistyPlayer extends ManagedCustomElement {\n  #config: TwistyPlayerConfig;\n\n  timeline: Timeline;\n  cursor: AlgCursor;\n  scene: Twisty3DScene | null = null;\n  twisty3D: Twisty3DPuzzle | null = null;\n\n  viewerElems: TwistyViewerElement[] = []; // TODO: can we represent the intermediate state better?\n  controlElems: TwistyControlElement[] = []; // TODO: can we represent the intermediate state better?\n\n  #hackyPendingFinalMoveCoalesce: boolean = false;\n\n  #viewerWrapper: TwistyViewerWrapper;\n  public legacyExperimentalCoalesceModFunc: (mv: BlockMove) => number = (\n    _mv: BlockMove,\n  ): number => 0;\n\n  #controlsClassListManager: ClassListManager<\n    ControlsLocation\n  > = new ClassListManager(this, \"controls-\", [\"none\", \"bottom-row\"]);\n\n  /** @deprecated */\n  public legacyExperimentalPG3D: PG3D | null = null;\n  /** @deprecated */\n  private legacyExperimentalPG3DViewConfig: LegacyExperimentalPG3DViewConfig | null;\n  // TODO: support config from DOM.\n  constructor(\n    initialConfig: TwistyPlayerInitialConfig = {},\n    legacyExperimentalPG3DViewConfig: LegacyExperimentalPG3DViewConfig | null = null,\n  ) {\n    super();\n    this.addCSS(twistyPlayerCSS);\n    this.#config = new TwistyPlayerConfig(this, initialConfig);\n\n    // We also do this in connectedCallback, but for now we also do it here so\n    // that there is some visual change even if the rest of construction or\n    // initialization fails.\n    this.contentWrapper.classList.add(\"checkered\");\n\n    this.legacyExperimentalPG3DViewConfig = legacyExperimentalPG3DViewConfig;\n  }\n\n  set alg(seq: Sequence) {\n    // TODO: do validation for other algs as well.\n    if (seq?.type !== \"sequence\") {\n      // TODO: document `.setAttribute(\"experimental-start-setup\", \"R U R'\")` as a workaround.\n      console.warn(\n        \"`alg` for a `TwistyPlayer` was set using a string. It should be set using a `Sequence`!\",\n      );\n      seq = parse((seq as unknown) as string) as Sequence;\n    }\n    this.#config.attributes[\"alg\"].setValue(seq);\n    this.cursor?.setAlg(seq); // TODO: can we ensure the cursor already exists?\n  }\n\n  get alg(): Sequence {\n    return this.#config.attributes[\"alg\"].value;\n  }\n\n  set experimentalStartSetup(seq: Sequence) {\n    // TODO: do validation for other algs as well.\n    if (seq?.type !== \"sequence\") {\n      // TODO: document `.setAttribute(\"experimental-start-setup\", \"R U R'\")` as a workaround.\n      console.warn(\n        \"`experimentalStartSetup` for a `TwistyPlayer` was set using a string. It should be set using a `Sequence`!\",\n      );\n      seq = parse((seq as unknown) as string) as Sequence;\n    }\n    this.#config.attributes[\"experimental-start-setup\"].setValue(seq);\n    if (this.cursor) {\n      this.cursor.setStartState(this.cursor.algToState(seq)); // TODO\n    }\n  }\n\n  get experimentalStartSetup(): Sequence {\n    return this.#config.attributes[\"experimental-start-setup\"].value;\n  }\n\n  set puzzle(puzzle: PuzzleID) {\n    if (this.#config.attributes[\"puzzle\"].setValue(puzzle)) {\n      this.setPuzzle(puzzle);\n    }\n  }\n\n  get puzzle(): PuzzleID {\n    return this.#config.attributes[\"puzzle\"].value as PuzzleID;\n  }\n\n  set visualization(visualization: VisualizationFormat) {\n    if (this.#config.attributes[\"visualization\"].setValue(visualization)) {\n      this.setPuzzle(this.puzzle);\n    }\n  }\n\n  get visualization(): VisualizationFormat {\n    return this.#config.attributes[\"visualization\"]\n      .value as VisualizationFormat;\n  }\n\n  set hintFacelets(hintFacelets: HintFaceletStyle) {\n    // TODO: implement this for PG3D.\n    if (this.#config.attributes[\"hint-facelets\"].setValue(hintFacelets)) {\n      if (this.twisty3D instanceof Cube3D) {\n        this.twisty3D.experimentalUpdateOptions({ hintFacelets });\n      }\n    }\n  }\n\n  get hintFacelets(): HintFaceletStyle {\n    return this.#config.attributes[\"hint-facelets\"].value as HintFaceletStyle;\n  }\n\n  // TODO: Implement for PG3D\n  /** @deprecated */\n  get experimentalStickering(): ExperimentalStickering {\n    return this.#config.attributes[\"experimental-stickering\"]\n      .value as ExperimentalStickering;\n  }\n\n  // TODO: Implement for PG3D\n  /** @deprecated */\n  set experimentalStickering(experimentalStickering: ExperimentalStickering) {\n    if (\n      this.#config.attributes[\"experimental-stickering\"].setValue(\n        experimentalStickering,\n      )\n    ) {\n      if (this.twisty3D instanceof Cube3D) {\n        this.twisty3D.experimentalUpdateOptions({\n          experimentalStickering,\n        });\n      }\n    }\n  }\n\n  set background(background: BackgroundTheme) {\n    if (this.#config.attributes[\"background\"].setValue(background)) {\n      this.contentWrapper.classList.toggle(\n        \"checkered\",\n        background === \"checkered\",\n      );\n    }\n  }\n\n  get background(): BackgroundTheme {\n    return this.#config.attributes[\"background\"].value as BackgroundTheme;\n  }\n\n  set controls(controls: ControlsLocation) {\n    this.#controlsClassListManager.setValue(controls);\n  }\n\n  get controls(): ControlsLocation {\n    return this.#config.attributes[\"controls\"].value as ControlsLocation;\n  }\n\n  set backView(backView: BackViewLayout) {\n    if (backView !== \"none\" && this.viewerElems.length === 1) {\n      this.createBackViewer();\n    }\n    if (backView === \"none\" && this.viewerElems.length > 1) {\n      this.removeBackViewerElem();\n    }\n    if (this.#viewerWrapper && this.#viewerWrapper.setBackView(backView)) {\n      for (const viewer of this.viewerElems as Twisty3DCanvas[]) {\n        viewer.makeInvisibleUntilRender(); // TODO: can we do this more elegantly?\n      }\n    }\n  }\n\n  get backView(): BackViewLayout {\n    return this.#config.attributes[\"back-view\"].value as BackViewLayout;\n  }\n\n  set cameraPosition(cameraPosition: Vector3 | null) {\n    this.#config.attributes[\"camera-position\"].setValue(cameraPosition);\n    if (\n      this.viewerElems &&\n      [\"3D\", \"PG3D\"].includes(this.#config.attributes[\"visualization\"].value)\n    ) {\n      (this.viewerElems[0] as Twisty3DCanvas)?.camera.position.copy(\n        this.effectiveCameraPosition,\n      );\n      this.viewerElems[0]?.scheduleRender();\n      // Back view may or may not exist.\n      (this.viewerElems[1] as Twisty3DCanvas)?.camera.position\n        .copy(this.effectiveCameraPosition)\n        .multiplyScalar(-1);\n      this.viewerElems[1]?.scheduleRender();\n    }\n  }\n\n  get cameraPosition(): Vector3 | null {\n    return this.#config.attributes[\"camera-position\"].value;\n  }\n\n  get effectiveCameraPosition(): Vector3 {\n    return this.cameraPosition ?? this.defaultCameraPosition;\n  }\n\n  // TODO\n  get defaultCameraPosition(): Vector3 {\n    return this.puzzle[1] === \"x\" ? cubeCameraPosition : centeredCameraPosition;\n  }\n\n  static get observedAttributes(): string[] {\n    return TwistyPlayerConfig.observedAttributes;\n  }\n\n  attributeChangedCallback(\n    attributeName: string,\n    oldValue: string,\n    newValue: string,\n  ): void {\n    this.#config.attributeChangedCallback(attributeName, oldValue, newValue);\n  }\n\n  // TODO: It seems this called after the `attributeChangedCallback`s for initial values. Can we rely on this?\n  protected connectedCallback(): void {\n    this.timeline = new Timeline();\n    this.timeline.addActionListener(this);\n\n    this.contentWrapper.classList.toggle(\n      \"checkered\",\n      this.background === \"checkered\",\n    );\n\n    // TODO: specify exactly when back views are possible.\n    // TODO: Are there any SVGs where we'd want a separate back view?\n    const setBackView: boolean = this.backView && this.visualization !== \"2D\";\n    const backView: BackViewLayout = setBackView\n      ? (this.backView as BackViewLayout)\n      : \"none\";\n    this.#viewerWrapper = new TwistyViewerWrapper({\n      backView,\n    });\n    this.addElement(this.#viewerWrapper);\n\n    this.createViewers(\n      this.timeline,\n      this.alg,\n      this.visualization,\n      this.puzzle,\n      this.backView !== \"none\",\n    );\n    const scrubber = new TwistyScrubber(this.timeline);\n    const controlButtonGrid = new TwistyControlButtonPanel(this.timeline, this);\n\n    this.controlElems = [scrubber, controlButtonGrid];\n\n    this.#controlsClassListManager.setValue(this.controls);\n\n    this.addElement(this.controlElems[0]);\n    this.addElement(this.controlElems[1]);\n  }\n\n  protected createViewers(\n    timeline: Timeline,\n    alg: Sequence,\n    visualization: VisualizationFormat,\n    puzzleName: string,\n    backView: boolean,\n  ): void {\n    switch (visualization) {\n      case \"2D\": {\n        try {\n          this.cursor = new AlgCursor(\n            timeline,\n            Puzzles[puzzleName],\n            alg,\n            this.experimentalStartSetup,\n          );\n        } catch (e) {\n          // TODO: Deduplicate fallback.\n          this.cursor = new AlgCursor(\n            timeline,\n            Puzzles[puzzleName],\n            new Sequence([]),\n            this.experimentalStartSetup,\n          );\n        }\n        this.cursor.setStartState(\n          this.cursor.algToState(this.experimentalStartSetup),\n        );\n\n        this.timeline.addCursor(this.cursor);\n        if (this.experimentalStartSetup.nestedUnits.length === 0) {\n          // TODO: find better way to configure when to start where (e.g. initialTimestamp: \"start\" | \"end\" | \"setup\")\n          this.timeline.jumpToEnd();\n        }\n        const mainViewer = new Twisty2DSVG(this.cursor, Puzzles[puzzleName]);\n        this.viewerElems = [mainViewer];\n        this.#viewerWrapper.addElement(mainViewer);\n        return;\n      }\n      case \"3D\":\n        if (puzzleName === \"3x3x3\") {\n          // TODO: fold 3D and PG3D into this.\n          try {\n            this.cursor = new AlgCursor(\n              timeline,\n              Puzzles[puzzleName],\n              alg,\n              this.experimentalStartSetup,\n            );\n          } catch (e) {\n            // TODO: Deduplicate fallback.\n            this.cursor = new AlgCursor(\n              timeline,\n              Puzzles[puzzleName],\n              new Sequence([]),\n              this.experimentalStartSetup,\n            );\n          }\n          this.cursor.setStartState(\n            this.cursor.algToState(this.experimentalStartSetup),\n          );\n          this.scene = new Twisty3DScene();\n          this.twisty3D = new Cube3D(\n            this.cursor,\n            this.scene.scheduleRender.bind(this.scene),\n            {\n              hintFacelets: this.hintFacelets,\n              experimentalStickering: this.experimentalStickering,\n            },\n          );\n          this.scene.addTwisty3DPuzzle(this.twisty3D);\n          const mainViewer = new Twisty3DCanvas(this.scene, {\n            cameraPosition: this.effectiveCameraPosition,\n          });\n          this.#viewerWrapper.addElement(mainViewer);\n          this.viewerElems = [mainViewer];\n          if (backView) {\n            this.createBackViewer();\n            // const partner = new Twisty3DCanvas(this.scene, {\n            //   // cameraPosition, // TODO\n            //   negateCameraPosition: true,\n            // });\n            // this.viewerElems.push(partner);\n            // mainViewer.setMirror(partner);\n          }\n          this.timeline.addCursor(this.cursor);\n          if (this.experimentalStartSetup.nestedUnits.length === 0) {\n            // TODO: find better way to configure when to start where (e.g. initialTimestamp: \"start\" | \"end\" | \"setup\")\n            this.timeline.jumpToEnd();\n          }\n          return;\n        }\n      // fallthrough for 3D when not 3x3x3\n      case \"PG3D\": {\n        const [kpuzzleDef, stickerDat] = this.pgHelper(puzzleName);\n\n        try {\n          this.cursor = new AlgCursor(\n            timeline,\n            kpuzzleDef,\n            alg,\n            this.experimentalStartSetup,\n          );\n        } catch (e) {\n          // TODO: Deduplicate fallback.\n          this.cursor = new AlgCursor(\n            timeline,\n            kpuzzleDef,\n            new Sequence([]),\n            this.experimentalStartSetup,\n          );\n        }\n\n        this.scene = new Twisty3DScene();\n        const pg3d = new PG3D(\n          this.cursor,\n          this.scene.scheduleRender.bind(this.scene),\n          kpuzzleDef,\n          stickerDat,\n          this.legacyExperimentalPG3DViewConfig?.showFoundation ?? true,\n        );\n        this.twisty3D = pg3d;\n        this.legacyExperimentalPG3D = pg3d;\n        this.scene.addTwisty3DPuzzle(this.twisty3D);\n        const mainViewer = new Twisty3DCanvas(this.scene, {\n          cameraPosition: this.effectiveCameraPosition,\n        });\n        this.viewerElems = [mainViewer];\n        this.#viewerWrapper.addElement(mainViewer);\n        if (backView) {\n          this.createBackViewer();\n        }\n        this.timeline.addCursor(this.cursor);\n        if (this.experimentalStartSetup.nestedUnits.length === 0) {\n          // TODO: find better way to configure when to start where (e.g. initialTimestamp: \"start\" | \"end\" | \"setup\")\n          this.timeline.jumpToEnd();\n        }\n        return;\n      }\n      default:\n        throw new Error(\"Unknown visualization\");\n    }\n  }\n\n  // TODO: Distribute this code better.\n  private pgHelper(puzzleName: string): [KPuzzleDefinition, StickerDat] {\n    let kpuzzleDef: KPuzzleDefinition;\n    let stickerDat: StickerDat;\n    if (this.legacyExperimentalPG3DViewConfig) {\n      kpuzzleDef = this.legacyExperimentalPG3DViewConfig.def;\n      stickerDat = this.legacyExperimentalPG3DViewConfig.stickerDat;\n      // experimentalPolarVantages ?: boolean;\n      // sideBySide ?: boolean;\n      // showFoundation ?: boolean;;\n    } else {\n      const pg = createPG(puzzleName);\n      stickerDat = pg.get3d();\n      kpuzzleDef = pg.writekpuzzle();\n    }\n    return [kpuzzleDef, stickerDat];\n  }\n\n  private createBackViewer(): void {\n    if (!is3DVisualization(this.visualization)) {\n      throw new Error(\"Back viewer requires a 3D visualization\");\n    }\n\n    const backViewer = new Twisty3DCanvas(this.scene!, {\n      cameraPosition: this.effectiveCameraPosition,\n      negateCameraPosition: true,\n    });\n    this.viewerElems.push(backViewer);\n    (this.viewerElems[0] as Twisty3DCanvas).setMirror(backViewer);\n    this.#viewerWrapper.addElement(backViewer);\n  }\n\n  private removeBackViewerElem(): void {\n    // TODO: Validate visualization.\n    if (this.viewerElems.length !== 2) {\n      throw new Error(\"Tried to remove non-existent back view!\");\n    }\n    this.#viewerWrapper.removeElement(this.viewerElems.pop()!);\n  }\n\n  setPuzzle(\n    puzzleName: string,\n    legacyExperimentalPG3DViewConfig?: LegacyExperimentalPG3DViewConfig,\n  ): void {\n    this.puzzle = puzzleName as PuzzleID;\n    this.legacyExperimentalPG3DViewConfig =\n      legacyExperimentalPG3DViewConfig ?? null;\n    switch (this.visualization) {\n      // TODO: Swap out both 3D implementations with each other.\n      case \"PG3D\": {\n        const scene = this.scene!;\n        scene.remove(this.twisty3D!);\n        this.cursor.removePositionListener(this.twisty3D!);\n        const [def, dat /*, _*/] = this.pgHelper(this.puzzle);\n        this.cursor.setPuzzle(def, undefined, this.experimentalStartSetup);\n        const pg3d = new PG3D(\n          this.cursor,\n          scene.scheduleRender.bind(scene),\n          def,\n          dat,\n          this.legacyExperimentalPG3DViewConfig?.showFoundation,\n        );\n        scene.addTwisty3DPuzzle(pg3d);\n        this.twisty3D = pg3d;\n        this.legacyExperimentalPG3D = pg3d;\n        for (const viewer of this.viewerElems) {\n          viewer.scheduleRender();\n        }\n        return;\n      }\n\n      // this.#cursor.set\n      // return;\n    }\n\n    // Fallback\n    const oldCursor = this.cursor;\n    for (const oldViewer of this.viewerElems) {\n      this.#viewerWrapper.removeElement(oldViewer);\n    }\n    this.createViewers(\n      this.timeline,\n      this.alg,\n      this.visualization,\n      puzzleName,\n      this.backView !== \"none\",\n    );\n    this.timeline.removeCursor(oldCursor);\n    this.timeline.removeTimestampListener(oldCursor);\n  }\n\n  // TODO: Handle playing the new move vs. just modying the alg.\n  // Note: setting `coalesce`\n  experimentalAddMove(\n    move: BlockMove,\n    coalesce: boolean = false,\n    coalesceDelayed: boolean = false,\n  ): void {\n    if (this.#hackyPendingFinalMoveCoalesce) {\n      this.hackyCoalescePending();\n    }\n    const oldNumMoves = countMoves(this.alg); // TODO\n    const newAlg = experimentalAppendBlockMove(\n      this.alg,\n      move,\n      coalesce && !coalesceDelayed,\n      this.legacyExperimentalCoalesceModFunc(move),\n    );\n    if (coalesce && coalesceDelayed) {\n      this.#hackyPendingFinalMoveCoalesce = true;\n    }\n\n    this.alg = newAlg;\n    // TODO\n    if (oldNumMoves <= countMoves(newAlg)) {\n      this.timeline.experimentalJumpToLastMove();\n    } else {\n      this.timeline.jumpToEnd();\n    }\n    this.timeline.play();\n  }\n\n  onTimelineAction(actionEvent: TimelineActionEvent): void {\n    if (\n      actionEvent.action === TimelineAction.Pausing &&\n      actionEvent.locationType === TimestampLocationType.EndOfTimeline &&\n      this.#hackyPendingFinalMoveCoalesce\n    ) {\n      this.hackyCoalescePending();\n      this.timeline.jumpToEnd();\n    }\n  }\n\n  private hackyCoalescePending(): void {\n    const units = this.alg.nestedUnits;\n    const length = units.length;\n    const pending = this.#hackyPendingFinalMoveCoalesce;\n    this.#hackyPendingFinalMoveCoalesce = false;\n    if (pending && length > 1 && units[length - 1].type === \"blockMove\") {\n      const finalMove = units[length - 1] as BlockMove;\n      const newAlg = experimentalAppendBlockMove(\n        new Sequence(units.slice(0, length - 1)),\n        finalMove,\n        true,\n        this.legacyExperimentalCoalesceModFunc(finalMove),\n      );\n      this.alg = newAlg;\n    }\n  }\n\n  fullscreen(): void {\n    this.requestFullscreen();\n  }\n}\n\ncustomElementsShim.define(\"twisty-player\", TwistyPlayer);\n", "import { BlockMove, expand, Sequence, TraversalUp } from \"../../../alg\";\nimport { PuzzleWrapper, State } from \"../../3D/puzzles/KPuzzleWrapper\";\nimport { AlgIndexer, countAnimatedMoves } from \"./AlgIndexer\";\nimport { Duration, Timestamp, DefaultDurationForAmount } from \"./CursorTypes\";\nimport { AlgDuration } from \"./AlgDuration\";\n\nexport class SimpleAlgIndexer<P extends PuzzleWrapper>\n  implements AlgIndexer<P> {\n  private moves: Sequence;\n  // TODO: Allow custom `durationFn`.\n  private durationFn: TraversalUp<Duration> = new AlgDuration(\n    DefaultDurationForAmount,\n  );\n\n  constructor(private puzzle: P, alg: Sequence) {\n    this.moves = expand(alg);\n    // TODO: Avoid assuming all base moves are block moves.\n  }\n\n  public getMove(index: number): BlockMove {\n    return this.moves.nestedUnits[index] as BlockMove;\n  }\n\n  public indexToMoveStartTimestamp(index: number): Timestamp {\n    const seq = new Sequence(this.moves.nestedUnits.slice(0, index));\n    return this.durationFn.traverse(seq);\n  }\n\n  public timestampToIndex(timestamp: Timestamp): number {\n    let cumulativeTime = 0;\n    let i;\n    for (i = 0; i < this.numMoves(); i++) {\n      cumulativeTime += this.durationFn.traverseBlockMove(this.getMove(i));\n      if (cumulativeTime >= timestamp) {\n        return i;\n      }\n    }\n    return i;\n  }\n\n  public stateAtIndex(index: number): State<P> {\n    return this.puzzle.combine(\n      this.puzzle.startState(),\n      this.transformAtIndex(index),\n    );\n  }\n\n  public transformAtIndex(index: number): State<P> {\n    let state = this.puzzle.identity();\n    for (const move of this.moves.nestedUnits.slice(0, index)) {\n      state = this.puzzle.combine(\n        state,\n        this.puzzle.stateFromMove(move as BlockMove),\n      );\n    }\n    return state;\n  }\n\n  public algDuration(): Duration {\n    return this.durationFn.traverse(this.moves);\n  }\n\n  public numMoves(): number {\n    // TODO: Cache internally once performance matters.\n    return countAnimatedMoves(this.moves);\n  }\n\n  public moveDuration(index: number): number {\n    return this.durationFn.traverseBlockMove(this.getMove(index));\n  }\n}\n", "import { BlockMove } from \"../../../alg\";\nimport { experimentalBlockMoveQuantumName } from \"../../../alg/traversal\";\nimport { Timestamp, Duration } from \"../alg/CursorTypes\";\n\ninterface Event {\n  timeStamp: Timestamp;\n  move: BlockMove;\n}\n\nexport interface TimelineEntry {\n  event: Event;\n  start: Timestamp;\n  end: Timestamp;\n}\n\ntype Timeline = TimelineEntry[];\n\nfunction isSameAxis(move1: BlockMove, move2: BlockMove): boolean {\n  const familyRoots =\n    move1.family[0].toLowerCase() + move2.family[0].toLowerCase();\n  // console.log(familyRoots);\n  return ![\n    \"uu\",\n    \"ud\",\n    \"du\",\n    \"dd\",\n    \"ll\",\n    \"lr\",\n    \"rl\",\n    \"rr\",\n    \"ff\",\n    \"fb\",\n    \"bf\",\n    \"bb\",\n  ].includes(familyRoots);\n}\n\nexport function toAxes(\n  events: Event[],\n  diameterMs: Duration,\n): TimelineEntry[][] {\n  const axes: TimelineEntry[][] = [];\n  const axisMoveTracker = new Map();\n  let lastEntry: TimelineEntry | null = null;\n  for (const event of events) {\n    if (!lastEntry) {\n      lastEntry = {\n        event,\n        start: event.timeStamp - diameterMs / 2,\n        end: event.timeStamp + diameterMs / 2,\n      };\n      axes.push([lastEntry]);\n      axisMoveTracker.set(\n        experimentalBlockMoveQuantumName(lastEntry.event.move),\n        lastEntry,\n      );\n      continue;\n    }\n    const newEntry: TimelineEntry = {\n      event,\n      start: event.timeStamp - diameterMs / 2,\n      end: event.timeStamp + diameterMs / 2,\n    };\n    if (isSameAxis(lastEntry.event.move, event.move)) {\n      const quarterName = experimentalBlockMoveQuantumName(newEntry.event.move);\n      // console.log(quarterName);\n      const prev = axisMoveTracker.get(quarterName);\n      // console.log(\"prev\", prev);\n      if (\n        prev &&\n        prev.end > newEntry.start &&\n        Math.sign(prev.event.move.amount) ===\n          Math.sign(newEntry.event.move.amount)\n      ) {\n        prev.event.move = new BlockMove(\n          prev.event.move.outerLayer,\n          prev.event.move.innerLayer,\n          prev.event.move.family,\n          prev.event.move.amount + newEntry.event.move.amount,\n        );\n      } else {\n        axes[axes.length - 1].push(newEntry);\n        axisMoveTracker.set(quarterName, newEntry);\n      }\n    } else {\n      // console.log(\"--\", algPartToStringForTesting(newEntry.event.move));\n      axes.push([newEntry]);\n      axisMoveTracker.clear();\n      axisMoveTracker.set(\n        experimentalBlockMoveQuantumName(newEntry.event.move),\n        newEntry,\n      );\n      if (newEntry.start < lastEntry.end) {\n        const midpoint = (newEntry.start + lastEntry.end) / 2;\n        newEntry.start = midpoint;\n        lastEntry.end = midpoint;\n      }\n    }\n    lastEntry = newEntry;\n  }\n  return axes;\n}\n\n// TODO: turn into an optional param\nconst defaultDiameterMs: Duration = 200;\n\nexport function toTimeline(\n  events: Event[],\n  diameterMs: number = defaultDiameterMs,\n): Timeline {\n  const axes: TimelineEntry[][] = toAxes(events, diameterMs);\n  // console.log(axes);\n  return axes.flat();\n}\n\n/*\n\nInput: list of {move: {base, amount}}, centerTime} events sorted by centerTime of halfway through \"quarter\" turns.\nOutput list of {move, centerTime, start, end}\nOptions:\n  - radius # milliseconds\n  - maxImbalance # maximum ratio of (centerTime - end)/(centerTime - start)\n\neventsToTimeline(events):\n  frontier = empty set # only needed for performance, not correctness\n  for e of events:\n    add event to timeline with range {start: e.centerTime - radius, end: e.centerTime + radius}\n    for each event d of the frontier:\n      if d.base == e.base && sign(d.amount) == sign(e.amount): # d and e have the same base move in the same direction:\n        coalesce(d, e)\n        continue outer loop\n      if d.end > e.start and conflicts(d, e):\n        d.end   = min(e.end, (d.centerTime + e.centerTime) / 2)\n        e.start = max(e.end, (d.centerTime + e.centerTime) / 2)\n        remove d from the frontier\n      if d.centerTime < e.centerTime - radius\n        drop d from the frontier # optimization: too old to overlap with future events\n    e.end = min(e.end, e.centerTime + maxImbalance * (e.centerTime - e.start))\n    add e to the frontier\n\ncoalesce(d, e):\n  {\n    start: d.start\n    centerTime: weighted_avg(\n      d.centerTime with weight abs(d.amount)\n      e.centerTime with weight abs(e.amount)\n    )\n    end: e.end\n  }\n\nconflicts(d, e):\n  if d.base == e.base && sign(d.amount) != sign(e.amount):\n    return true\n  # else, depends on the puzzle\n\nThoughts:\n- Alternative to max imbalance: animate first and second part separately?\n- Fingertrick mode: allow an optional overlap amount between any two conflicting moves (possibly depending on the moves)\n\nProperties:\n- An event's start time will never change after it is added.\n- An event might take up less time than it \"can\".\n  - i.e. its start and/or end time could be extended after the algorithm finishes, without overlapping with conflicting moves.\n  - This is an acceptable compromise for simplicity.\n- As written, moves are only removed from the frontier opportunistically. This shouldn't be a problem.\n\n*/\n"],
  "mappings": "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",
  "names": []
}
