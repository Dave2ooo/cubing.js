{
  "version": 3,
  "sources": ["../../src/bluetooth/transformer.ts", "../../src/bluetooth/bluetooth-puzzle.ts", "../../src/bluetooth/debug.ts", "../../src/bluetooth/gan.ts", "../../src/bluetooth/unsafe-raw-aes.ts", "../../src/bluetooth/unsafe-raw-aes.ts", "../../src/bluetooth/gan.ts", "../../src/bluetooth/giiker.ts", "../../src/bluetooth/giiker.ts", "../../src/bluetooth/gocube.ts", "../../src/bluetooth/gocube.ts", "../../src/bluetooth/connect.ts", "../../src/bluetooth/keyboard.ts"],
  "sourcesContent": ["import { Quaternion, Vector3 } from \"three\";\nimport { MoveEvent, OrientationEvent } from \"./bluetooth-puzzle\";\n\n// TODO: Combine orientation and moves into a single event to handle quaternion remapping.\nexport interface StreamTransformer {\n  // Modifies the input.\n  transformMove(moveEvent: MoveEvent): void;\n\n  // Modifies the input.\n  transformOrientation(orientationEvent: OrientationEvent): void;\n}\n\nfunction maxAxis(v: Vector3): string {\n  const maxVal = Math.max(Math.abs(v.x), Math.abs(v.y), Math.abs(v.z));\n  switch (maxVal) {\n    case v.x:\n      return \"x\";\n    case -v.x:\n      return \"-x\";\n    case v.y:\n      return \"y\";\n    case -v.y:\n      return \"-y\";\n    case v.z:\n      return \"z\";\n    case -v.z:\n      return \"-z\";\n    default:\n      throw new Error(\"Uh-oh.\");\n  }\n}\n\nconst s2 = Math.sqrt(0.5);\n\nconst m: { [s: string]: Quaternion } = {\n  \"y z\": new Quaternion(0, 0, 0, 1),\n  \"-z y\": new Quaternion(s2, 0, 0, s2),\n  \"x z\": new Quaternion(0, 0, -s2, s2),\n  \"-x z\": new Quaternion(0, 0, s2, s2),\n};\n\nexport class BasicRotationTransformer implements StreamTransformer {\n  // private reorientQuat = new Quaternion();\n\n  public transformMove(_moveEvent: MoveEvent): void {\n    // Nothing to do.\n  }\n\n  public transformOrientation(orientationEvent: OrientationEvent): void {\n    const { x, y, z, w } = orientationEvent.quaternion;\n    const quat = new Quaternion(x, y, z, w);\n\n    const U = new Vector3(0, 1, 0);\n    const F = new Vector3(0, 0, 1);\n    const maxU = maxAxis(U.applyQuaternion(quat));\n    const maxF = maxAxis(F.applyQuaternion(quat));\n\n    const oriQuat = m[`${maxU} ${maxF}`] || m[\"y z\"];\n\n    console.log(quat);\n    console.log(oriQuat);\n    const q2 = quat.premultiply(oriQuat);\n\n    // console.log(maxAxis(U.applyQuaternion(quat)), maxAxis(F.applyQuaternion(quat)));\n    console.log(q2);\n\n    orientationEvent.quaternion = quat;\n\n    console.log(orientationEvent.quaternion);\n  }\n}\n", "import { BlockMove } from \"../alg\";\nimport { Transformation } from \"../kpuzzle\";\nimport { BasicRotationTransformer, StreamTransformer } from \"./transformer\";\n\n/******** BluetoothPuzzle ********/\n\n// TODO: Make compatible with Twisty.\nexport type PuzzleState = Transformation;\n\n// TODO: Use actual `CustomEvent`s?\n// https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent\nexport interface MoveEvent {\n  latestMove: BlockMove;\n  timeStamp: number;\n  debug?: Record<string, unknown>;\n  state?: PuzzleState;\n  quaternion?: any; // TODO: Unused\n}\n\n// TODO: Only use the `quaternion` field in the `MoveEvent`?\nexport interface OrientationEvent {\n  quaternion: {\n    x: number;\n    y: number;\n    z: number;\n    w: number;\n  };\n  timeStamp: number;\n  debug?: Record<string, unknown>;\n}\n\nexport interface BluetoothConfig {\n  filters: BluetoothRequestDeviceFilter[];\n  optionalServices: BluetoothServiceUUID[];\n}\n\n// TODO: Expose device name (and/or globally unique identifier)?\nexport abstract class BluetoothPuzzle {\n  public transformers: StreamTransformer[] = [];\n  protected listeners: Array<(e: MoveEvent) => void> = []; // TODO: type\n  protected orientationListeners: Array<(e: OrientationEvent) => void> = []; // TODO: type\n\n  public abstract name(): string | undefined;\n\n  // TODO: require subclasses to implement this?\n  public async getState(): Promise<PuzzleState> {\n    throw new Error(\"cannot get state\");\n  }\n\n  public addMoveListener(listener: (e: MoveEvent) => void): void {\n    this.listeners.push(listener);\n  }\n\n  public addOrientationListener(listener: (e: OrientationEvent) => void): void {\n    this.orientationListeners.push(listener);\n  }\n\n  public experimentalAddBasicRotationTransformer(): void {\n    this.transformers.push(new BasicRotationTransformer());\n  }\n\n  protected dispatchMove(moveEvent: MoveEvent): void {\n    for (const transformer of this.transformers) {\n      transformer.transformMove(moveEvent);\n    }\n    for (const l of this.listeners) {\n      l(moveEvent);\n    }\n  }\n\n  protected dispatchOrientation(orientationEvent: OrientationEvent): void {\n    for (const transformer of this.transformers) {\n      transformer.transformOrientation(orientationEvent);\n    }\n    const { x, y, z, w } = orientationEvent.quaternion;\n    // TODO: can we avoid mutating the source event?\n    orientationEvent.quaternion = {\n      x,\n      y,\n      z,\n      w,\n    };\n    for (const l of this.orientationListeners) {\n      // TODO: Convert quaternion.\n      l(orientationEvent);\n    }\n  }\n}\n", "let DEBUG_LOGGING_ENABLED = false;\n\nexport function enableDebugLogging(enable: boolean): void {\n  DEBUG_LOGGING_ENABLED = enable;\n}\n\n// TODO: Remove this.\nexport function debugLog(...args: any[]): void {\n  if (!DEBUG_LOGGING_ENABLED) {\n    return;\n  }\n\n  if (console.info) {\n    console.info(...args);\n  } else {\n    console.log(...args);\n  }\n}\n", "/* tslint:disable no-bitwise */\n\nimport { Quaternion } from \"three\";\nimport { BareBlockMove, BlockMove } from \"../alg\";\nimport { KPuzzle, Puzzles } from \"../kpuzzle\";\nimport {\n  BluetoothConfig,\n  BluetoothPuzzle,\n  PuzzleState,\n} from \"./bluetooth-puzzle\";\nimport { debugLog } from \"./debug\";\nimport { importKey, unsafeDecryptBlock } from \"./unsafe-raw-aes\";\n\n// This needs to be short enough to capture 6 moves (OBQTM).\nconst DEFAULT_INTERVAL_MS = 150;\n// Number of latest moves provided by the Gan 356i.\nconst MAX_LATEST_MOVES = 6;\n\nconst ganMoveToBlockMove: { [i: number]: BlockMove } = {\n  0x00: BareBlockMove(\"U\"),\n  0x02: BareBlockMove(\"U\", -1),\n  0x03: BareBlockMove(\"R\"),\n  0x05: BareBlockMove(\"R\", -1),\n  0x06: BareBlockMove(\"F\"),\n  0x08: BareBlockMove(\"F\", -1),\n  0x09: BareBlockMove(\"D\"),\n  0x0b: BareBlockMove(\"D\", -1),\n  0x0c: BareBlockMove(\"L\"),\n  0x0e: BareBlockMove(\"L\", -1),\n  0x0f: BareBlockMove(\"B\"),\n  0x11: BareBlockMove(\"B\", -1),\n};\n\nlet homeQuatInverse: Quaternion | null = null;\n\nfunction probablyDecodedCorrectly(data: Uint8Array): boolean {\n  return (\n    data[13] < 0x12 &&\n    data[14] < 0x12 &&\n    data[15] < 0x12 &&\n    data[16] < 0x12 &&\n    data[17] < 0x12 &&\n    data[18] < 0x12\n  );\n}\n\nconst key10 = new Uint8Array([\n  198,\n  202,\n  21,\n  223,\n  79,\n  110,\n  19,\n  182,\n  119,\n  13,\n  230,\n  89,\n  58,\n  175,\n  186,\n  162,\n]);\nconst key11 = new Uint8Array([\n  67,\n  226,\n  91,\n  214,\n  125,\n  220,\n  120,\n  216,\n  7,\n  96,\n  163,\n  218,\n  130,\n  60,\n  1,\n  241,\n]);\n\n// Clean-room reverse-engineered\nasync function decryptState(\n  data: Uint8Array,\n  aesKey: CryptoKey | null,\n): Promise<Uint8Array> {\n  if (aesKey === null) {\n    return data;\n  }\n\n  const copy = new Uint8Array(data);\n  copy.set(new Uint8Array(await unsafeDecryptBlock(aesKey, copy.slice(3))), 3);\n  copy.set(\n    new Uint8Array(await unsafeDecryptBlock(aesKey, copy.slice(0, 16))),\n    0,\n  );\n\n  if (probablyDecodedCorrectly(copy)) {\n    return copy;\n  }\n\n  throw new Error(\"Invalid Gan cube state\");\n}\n\nclass PhysicalState {\n  public static async read(\n    characteristic: BluetoothRemoteGATTCharacteristic,\n    aesKey: CryptoKey | null,\n  ): Promise<PhysicalState> {\n    const value = await decryptState(\n      new Uint8Array((await characteristic.readValue()).buffer),\n      aesKey,\n    );\n    const timeStamp = Date.now();\n    // console.log(value);\n    return new PhysicalState(new DataView(value.buffer), timeStamp);\n  }\n\n  private arr: Uint8Array;\n  private arrLen = 19;\n  private constructor(private dataView: DataView, public timeStamp: number) {\n    this.arr = new Uint8Array(dataView.buffer);\n    if (this.arr.length !== this.arrLen) {\n      throw new Error(\"Unexpected array length\");\n    }\n  }\n\n  public rotQuat(): Quaternion {\n    let x = this.dataView.getInt16(0, true) / 16384;\n    let y = this.dataView.getInt16(2, true) / 16384;\n    let z = this.dataView.getInt16(4, true) / 16384;\n    [x, y, z] = [-y, z, -x];\n    const wSquared = 1 - (x * x + y * y + z * z);\n    const w = wSquared > 0 ? Math.sqrt(wSquared) : 0;\n    const quat = new Quaternion(x, y, z, w);\n\n    if (!homeQuatInverse) {\n      homeQuatInverse = quat.clone().inverse();\n    }\n\n    return quat.clone().multiply(homeQuatInverse.clone());\n  }\n\n  // Loops from 255 to 0.\n  public moveCounter(): number {\n    return this.arr[12];\n  }\n\n  public numMovesSince(previousMoveCounter: number): number {\n    return (this.moveCounter() - previousMoveCounter) & 0xff;\n  }\n\n  // Due to the design of the Gan356i protocol, it's common to query for the\n  // latest physical state and find 0 moves have been performed since the last\n  // query. Therefore, it's useful to allow 0 as an argument.\n  public latestMoves(n: number): BlockMove[] {\n    if (n < 0 || n > MAX_LATEST_MOVES) {\n      throw new Error(`Must ask for 0 to 6 latest moves. (Asked for ${n})`);\n    }\n    return Array.from(this.arr.slice(19 - n, 19)).map(\n      (i) => ganMoveToBlockMove[i],\n    );\n  }\n\n  public debugInfo(): { arr: Uint8Array } {\n    return {\n      arr: this.arr,\n    };\n  }\n}\n\n// TODO: Short IDs\nconst UUIDs = {\n  ganCubeService: \"0000fff0-0000-1000-8000-00805f9b34fb\",\n  physicalStateCharacteristic: \"0000fff5-0000-1000-8000-00805f9b34fb\",\n  actualAngleAndBatteryCharacteristic: \"0000fff7-0000-1000-8000-00805f9b34fb\",\n  faceletStatus1Characteristic: \"0000fff2-0000-1000-8000-00805f9b34fb\",\n  faceletStatus2Characteristic: \"0000fff3-0000-1000-8000-00805f9b34fb\",\n  infoService: \"0000180a-0000-1000-8000-00805f9b34fb\",\n  systemIDCharacteristic: \"00002a23-0000-1000-8000-00805f9b34fb\",\n  versionCharacteristic: \"00002a28-0000-1000-8000-00805f9b34fb\",\n};\n\nconst commands: { [cmd: string]: BufferSource } = {\n  reset: new Uint8Array([\n    0x00,\n    0x00,\n    0x24,\n    0x00,\n    0x49,\n    0x92,\n    0x24,\n    0x49,\n    0x6d,\n    0x92,\n    0xdb,\n    0xb6,\n    0x49,\n    0x92,\n    0xb6,\n    0x24,\n    0x6d,\n    0xdb,\n  ]),\n};\n\n// // TODO: Move this into a factory?\nexport const ganConfig: BluetoothConfig = {\n  filters: [{ namePrefix: \"GAN\" }],\n  optionalServices: [UUIDs.ganCubeService, UUIDs.infoService],\n};\n\nfunction buf2hex(buffer: ArrayBuffer): string {\n  // buffer is an ArrayBuffer\n  return Array.prototype.map\n    .call(new Uint8Array(buffer), (x: number) =>\n      (\"00\" + x.toString(16)).slice(-2),\n    )\n    .join(\" \");\n}\n\nconst reidEdgeOrder = \"UF UR UB UL DF DR DB DL FR FL BR BL\".split(\" \");\nconst reidCornerOrder = \"UFR URB UBL ULF DRF DFL DLB DBR\".split(\" \");\n\ninterface PieceInfo {\n  piece: number;\n  orientation: number;\n}\n\nfunction rotateLeft(s: string, i: number): string {\n  return s.slice(i) + s.slice(0, i);\n}\n\nconst pieceMap: { [s: string]: PieceInfo } = {};\n// TODO: Condense the for loops.\nreidEdgeOrder.forEach((edge, idx) => {\n  for (let i = 0; i < 2; i++) {\n    pieceMap[rotateLeft(edge, i)] = { piece: idx, orientation: i };\n  }\n});\nreidCornerOrder.forEach((corner, idx) => {\n  for (let i = 0; i < 3; i++) {\n    pieceMap[rotateLeft(corner, i)] = { piece: idx, orientation: i };\n  }\n});\n\nconst gan356iCornerMappings = [\n  [0, 21, 15],\n  [5, 13, 47],\n  [7, 45, 39],\n  [2, 37, 23],\n  [29, 10, 16],\n  [31, 18, 32],\n  [26, 34, 40],\n  [24, 42, 8],\n];\n\nconst gan356iEdgeMappings = [\n  [1, 22],\n  [3, 14],\n  [6, 46],\n  [4, 38],\n  [30, 17],\n  [27, 9],\n  [25, 41],\n  [28, 33],\n  [19, 12],\n  [20, 35],\n  [44, 11],\n  [43, 36],\n];\nconst faceOrder = \"URFDLB\";\n\nasync function getKey(\n  server: BluetoothRemoteGATTServer,\n): Promise<CryptoKey | null> {\n  const infoService = await server.getPrimaryService(UUIDs.infoService);\n\n  const versionCharacteristic = await infoService.getCharacteristic(\n    UUIDs.versionCharacteristic,\n  );\n  const versionBuffer = new Uint8Array(\n    (await versionCharacteristic.readValue()).buffer,\n  );\n\n  const versionValue =\n    (((versionBuffer[0] << 8) + versionBuffer[1]) << 8) + versionBuffer[2];\n  if (versionValue < 0x01_00_08) {\n    return null;\n  }\n\n  const keyXor = versionValue < 0x01_01_00 ? key10 : key11;\n\n  const systemIDCharacteristic = await infoService.getCharacteristic(\n    UUIDs.systemIDCharacteristic,\n  );\n  const systemID = new Uint8Array(\n    (await systemIDCharacteristic.readValue()).buffer,\n  ).reverse();\n\n  const key = new Uint8Array(keyXor);\n  for (let i = 0; i < systemID.length; i++) {\n    key[i] = (key[i] + systemID[i]) % 256;\n  }\n\n  return importKey(key);\n}\n\nexport class GanCube extends BluetoothPuzzle {\n  // We have to perform async operations before we call the constructor.\n  public static async connect(\n    server: BluetoothRemoteGATTServer,\n  ): Promise<GanCube> {\n    const ganCubeService = await server.getPrimaryService(UUIDs.ganCubeService);\n    debugLog(\"Service:\", ganCubeService);\n\n    const physicalStateCharacteristic = await ganCubeService.getCharacteristic(\n      UUIDs.physicalStateCharacteristic,\n    );\n    debugLog(\"Characteristic:\", physicalStateCharacteristic);\n\n    const aesKey = await getKey(server);\n\n    const initialMoveCounter = (\n      await PhysicalState.read(physicalStateCharacteristic, aesKey)\n    ).moveCounter();\n    debugLog(\"Initial Move Counter:\", initialMoveCounter);\n    const cube = new GanCube(\n      ganCubeService,\n      server,\n      physicalStateCharacteristic,\n      initialMoveCounter,\n      aesKey,\n    );\n    return cube;\n  }\n\n  public INTERVAL_MS: number = DEFAULT_INTERVAL_MS;\n  private intervalHandle: number | null = null;\n  private kpuzzle: KPuzzle = new KPuzzle(Puzzles[\"3x3x3\"]);\n  private cachedFaceletStatus1Characteristic: Promise<\n    BluetoothRemoteGATTCharacteristic\n  >;\n\n  private cachedFaceletStatus2Characteristic: Promise<\n    BluetoothRemoteGATTCharacteristic\n  >;\n\n  private cachedActualAngleAndBatteryCharacteristic: Promise<\n    BluetoothRemoteGATTCharacteristic\n  >;\n\n  private constructor(\n    private service: BluetoothRemoteGATTService,\n    private server: BluetoothRemoteGATTServer,\n    private physicalStateCharacteristic: BluetoothRemoteGATTCharacteristic,\n    private lastMoveCounter: number,\n    private aesKey: CryptoKey | null,\n  ) {\n    super();\n    this.startTrackingMoves();\n  }\n\n  public name(): string | undefined {\n    return this.server.device.name;\n  }\n\n  public startTrackingMoves(): void {\n    // `window.setInterval` instead of `setInterval`:\n    // https://github.com/Microsoft/TypeScript/issues/842#issuecomment-252445883\n    this.intervalHandle = window.setInterval(\n      this.intervalHandler.bind(this),\n      this.INTERVAL_MS,\n    );\n  }\n\n  public stopTrackingMoves(): void {\n    if (!this.intervalHandle) {\n      throw new Error(\"Not tracking moves!\");\n    }\n    clearInterval(this.intervalHandle);\n    this.intervalHandle = null;\n  }\n\n  // TODO: Can we ever receive async responses out of order?\n  public async intervalHandler(): Promise<void> {\n    const physicalState = await PhysicalState.read(\n      this.physicalStateCharacteristic,\n      this.aesKey,\n    );\n    let numInterveningMoves = physicalState.numMovesSince(this.lastMoveCounter);\n    // console.log(numInterveningMoves);\n    if (numInterveningMoves > MAX_LATEST_MOVES) {\n      debugLog(\n        `Too many moves! Dropping ${\n          numInterveningMoves - MAX_LATEST_MOVES\n        } moves`,\n      );\n      numInterveningMoves = MAX_LATEST_MOVES;\n    }\n    for (const move of physicalState.latestMoves(numInterveningMoves)) {\n      // console.log(move);\n      this.kpuzzle.applyBlockMove(move);\n      this.dispatchMove({\n        latestMove: move,\n        timeStamp: physicalState.timeStamp,\n        debug: physicalState.debugInfo(),\n        state: this.kpuzzle.state,\n        // quaternion: physicalState.rotQuat(),\n      });\n    }\n    this.dispatchOrientation({\n      timeStamp: physicalState.timeStamp,\n      quaternion: physicalState.rotQuat(),\n    });\n    this.lastMoveCounter = physicalState.moveCounter();\n  }\n\n  public async getBattery(): Promise<number> {\n    return new Uint8Array(\n      await this.readActualAngleAndBatteryCharacteristic(),\n    )[7];\n  }\n\n  public async getState(): Promise<PuzzleState> {\n    const arr: Uint8Array = await decryptState(\n      new Uint8Array(await this.readFaceletStatus1Characteristic()),\n      this.aesKey,\n    );\n    const stickers: number[] = [];\n    for (let i = 0; i < 18; i += 3) {\n      let v = (((arr[i ^ 1] << 8) + arr[(i + 1) ^ 1]) << 8) + arr[(i + 2) ^ 1];\n      for (let j = 0; j < 8; j++) {\n        stickers.push(v & 7);\n        v >>= 3;\n      }\n    }\n\n    const state: PuzzleState = {\n      CORNERS: {\n        permutation: [],\n        orientation: [],\n      },\n      EDGES: {\n        permutation: [],\n        orientation: [],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 0, 0, 0, 0],\n      },\n    };\n\n    for (const cornerMapping of gan356iCornerMappings) {\n      const pieceInfo: PieceInfo =\n        pieceMap[cornerMapping.map((i) => faceOrder[stickers[i]]).join(\"\")];\n      state.CORNERS.permutation.push(pieceInfo.piece);\n      state.CORNERS.orientation.push(pieceInfo.orientation);\n    }\n\n    for (const edgeMapping of gan356iEdgeMappings) {\n      const pieceInfo: PieceInfo =\n        pieceMap[edgeMapping.map((i) => faceOrder[stickers[i]]).join(\"\")];\n      state.EDGES.permutation.push(pieceInfo.piece);\n      state.EDGES.orientation.push(pieceInfo.orientation);\n    }\n\n    return state;\n  }\n\n  public async faceletStatus1Characteristic(): Promise<\n    BluetoothRemoteGATTCharacteristic\n  > {\n    this.cachedFaceletStatus1Characteristic =\n      this.cachedFaceletStatus1Characteristic ||\n      this.service.getCharacteristic(UUIDs.faceletStatus1Characteristic);\n    return this.cachedFaceletStatus1Characteristic;\n  }\n\n  public async faceletStatus2Characteristic(): Promise<\n    BluetoothRemoteGATTCharacteristic\n  > {\n    this.cachedFaceletStatus2Characteristic =\n      this.cachedFaceletStatus2Characteristic ||\n      this.service.getCharacteristic(UUIDs.faceletStatus2Characteristic);\n    return this.cachedFaceletStatus2Characteristic;\n  }\n\n  public async actualAngleAndBatteryCharacteristic(): Promise<\n    BluetoothRemoteGATTCharacteristic\n  > {\n    this.cachedActualAngleAndBatteryCharacteristic =\n      this.cachedActualAngleAndBatteryCharacteristic ||\n      this.service.getCharacteristic(UUIDs.actualAngleAndBatteryCharacteristic);\n    return this.cachedActualAngleAndBatteryCharacteristic;\n  }\n\n  public async reset(): Promise<void> {\n    const faceletStatus1Characteristic = await this.faceletStatus1Characteristic();\n    await faceletStatus1Characteristic.writeValue(commands.reset);\n  }\n\n  public async readFaceletStatus1Characteristic(): Promise<ArrayBuffer> {\n    const faceletStatus1Characteristic = await this.faceletStatus1Characteristic();\n    return (await faceletStatus1Characteristic.readValue()).buffer;\n  }\n\n  public async readFaceletStatus2Characteristic(): Promise<string> {\n    const faceletStatus2Characteristic = await this.faceletStatus2Characteristic();\n    return buf2hex((await faceletStatus2Characteristic.readValue()).buffer);\n  }\n\n  public async readActualAngleAndBatteryCharacteristic(): Promise<ArrayBuffer> {\n    const actualAngleAndBatteryCharacteristic = await this.actualAngleAndBatteryCharacteristic();\n    return (await actualAngleAndBatteryCharacteristic.readValue()).buffer;\n  }\n\n  // TODO\n  // private onphysicalStateCharacteristicChanged(event: any): void {\n  //   var val = event.target.value;\n  //   debugLog(val);\n  // }\n}\n", "const blockSize = 16;\nconst zeros = new Uint8Array(blockSize);\nconst paddingBlockPlaintext = new Uint8Array(\n  new Array(blockSize).fill(blockSize),\n);\nconst AES_CBC = \"AES-CBC\";\n\nexport async function importKey(keyBytes: ArrayBuffer): Promise<CryptoKey> {\n  return await crypto.subtle.importKey(\"raw\", keyBytes, AES_CBC, true, [\n    \"encrypt\",\n    \"decrypt\",\n  ]);\n}\n\nasync function unsafeEncryptBlockWithIV(\n  key: CryptoKey,\n  plaintextBlock: ArrayBuffer,\n  iv: ArrayBuffer,\n): Promise<ArrayBuffer> {\n  return (\n    await window.crypto.subtle.encrypt(\n      {\n        name: AES_CBC,\n        iv,\n      },\n      key,\n      plaintextBlock,\n    )\n  ).slice(0, blockSize);\n}\n\nexport async function unsafeEncryptBlock(\n  key: CryptoKey,\n  plaintextBlock: ArrayBuffer,\n): Promise<ArrayBuffer> {\n  return (await unsafeEncryptBlockWithIV(key, plaintextBlock, zeros)).slice(\n    0,\n    blockSize,\n  );\n}\n\nexport async function unsafeDecryptBlock(\n  key: CryptoKey,\n  ciphertextBlock: ArrayBuffer,\n): Promise<ArrayBuffer> {\n  const paddingBlock = await unsafeEncryptBlockWithIV(\n    key,\n    paddingBlockPlaintext,\n    ciphertextBlock,\n  );\n\n  const cbcCiphertext = new Uint8Array(2 * blockSize);\n  cbcCiphertext.set(new Uint8Array(ciphertextBlock), 0);\n  cbcCiphertext.set(new Uint8Array(paddingBlock), blockSize);\n\n  return (\n    await window.crypto.subtle.decrypt(\n      {\n        name: AES_CBC,\n        iv: zeros,\n      },\n      key,\n      cbcCiphertext,\n    )\n  ).slice(0, blockSize);\n}\n", "const blockSize = 16;\nconst zeros = new Uint8Array(blockSize);\nconst paddingBlockPlaintext = new Uint8Array(\n  new Array(blockSize).fill(blockSize),\n);\nconst AES_CBC = \"AES-CBC\";\n\nexport async function importKey(keyBytes: ArrayBuffer): Promise<CryptoKey> {\n  return await crypto.subtle.importKey(\"raw\", keyBytes, AES_CBC, true, [\n    \"encrypt\",\n    \"decrypt\",\n  ]);\n}\n\nasync function unsafeEncryptBlockWithIV(\n  key: CryptoKey,\n  plaintextBlock: ArrayBuffer,\n  iv: ArrayBuffer,\n): Promise<ArrayBuffer> {\n  return (\n    await window.crypto.subtle.encrypt(\n      {\n        name: AES_CBC,\n        iv,\n      },\n      key,\n      plaintextBlock,\n    )\n  ).slice(0, blockSize);\n}\n\nexport async function unsafeEncryptBlock(\n  key: CryptoKey,\n  plaintextBlock: ArrayBuffer,\n): Promise<ArrayBuffer> {\n  return (await unsafeEncryptBlockWithIV(key, plaintextBlock, zeros)).slice(\n    0,\n    blockSize,\n  );\n}\n\nexport async function unsafeDecryptBlock(\n  key: CryptoKey,\n  ciphertextBlock: ArrayBuffer,\n): Promise<ArrayBuffer> {\n  const paddingBlock = await unsafeEncryptBlockWithIV(\n    key,\n    paddingBlockPlaintext,\n    ciphertextBlock,\n  );\n\n  const cbcCiphertext = new Uint8Array(2 * blockSize);\n  cbcCiphertext.set(new Uint8Array(ciphertextBlock), 0);\n  cbcCiphertext.set(new Uint8Array(paddingBlock), blockSize);\n\n  return (\n    await window.crypto.subtle.decrypt(\n      {\n        name: AES_CBC,\n        iv: zeros,\n      },\n      key,\n      cbcCiphertext,\n    )\n  ).slice(0, blockSize);\n}\n", "/* tslint:disable no-bitwise */\n\nimport { Quaternion } from \"three\";\nimport { BareBlockMove, BlockMove } from \"../alg\";\nimport { KPuzzle, Puzzles } from \"../kpuzzle\";\nimport {\n  BluetoothConfig,\n  BluetoothPuzzle,\n  PuzzleState,\n} from \"./bluetooth-puzzle\";\nimport { debugLog } from \"./debug\";\nimport { importKey, unsafeDecryptBlock } from \"./unsafe-raw-aes\";\n\n// This needs to be short enough to capture 6 moves (OBQTM).\nconst DEFAULT_INTERVAL_MS = 150;\n// Number of latest moves provided by the Gan 356i.\nconst MAX_LATEST_MOVES = 6;\n\nconst ganMoveToBlockMove: { [i: number]: BlockMove } = {\n  0x00: BareBlockMove(\"U\"),\n  0x02: BareBlockMove(\"U\", -1),\n  0x03: BareBlockMove(\"R\"),\n  0x05: BareBlockMove(\"R\", -1),\n  0x06: BareBlockMove(\"F\"),\n  0x08: BareBlockMove(\"F\", -1),\n  0x09: BareBlockMove(\"D\"),\n  0x0b: BareBlockMove(\"D\", -1),\n  0x0c: BareBlockMove(\"L\"),\n  0x0e: BareBlockMove(\"L\", -1),\n  0x0f: BareBlockMove(\"B\"),\n  0x11: BareBlockMove(\"B\", -1),\n};\n\nlet homeQuatInverse: Quaternion | null = null;\n\nfunction probablyDecodedCorrectly(data: Uint8Array): boolean {\n  return (\n    data[13] < 0x12 &&\n    data[14] < 0x12 &&\n    data[15] < 0x12 &&\n    data[16] < 0x12 &&\n    data[17] < 0x12 &&\n    data[18] < 0x12\n  );\n}\n\nconst key10 = new Uint8Array([\n  198,\n  202,\n  21,\n  223,\n  79,\n  110,\n  19,\n  182,\n  119,\n  13,\n  230,\n  89,\n  58,\n  175,\n  186,\n  162,\n]);\nconst key11 = new Uint8Array([\n  67,\n  226,\n  91,\n  214,\n  125,\n  220,\n  120,\n  216,\n  7,\n  96,\n  163,\n  218,\n  130,\n  60,\n  1,\n  241,\n]);\n\n// Clean-room reverse-engineered\nasync function decryptState(\n  data: Uint8Array,\n  aesKey: CryptoKey | null,\n): Promise<Uint8Array> {\n  if (aesKey === null) {\n    return data;\n  }\n\n  const copy = new Uint8Array(data);\n  copy.set(new Uint8Array(await unsafeDecryptBlock(aesKey, copy.slice(3))), 3);\n  copy.set(\n    new Uint8Array(await unsafeDecryptBlock(aesKey, copy.slice(0, 16))),\n    0,\n  );\n\n  if (probablyDecodedCorrectly(copy)) {\n    return copy;\n  }\n\n  throw new Error(\"Invalid Gan cube state\");\n}\n\nclass PhysicalState {\n  public static async read(\n    characteristic: BluetoothRemoteGATTCharacteristic,\n    aesKey: CryptoKey | null,\n  ): Promise<PhysicalState> {\n    const value = await decryptState(\n      new Uint8Array((await characteristic.readValue()).buffer),\n      aesKey,\n    );\n    const timeStamp = Date.now();\n    // console.log(value);\n    return new PhysicalState(new DataView(value.buffer), timeStamp);\n  }\n\n  private arr: Uint8Array;\n  private arrLen = 19;\n  private constructor(private dataView: DataView, public timeStamp: number) {\n    this.arr = new Uint8Array(dataView.buffer);\n    if (this.arr.length !== this.arrLen) {\n      throw new Error(\"Unexpected array length\");\n    }\n  }\n\n  public rotQuat(): Quaternion {\n    let x = this.dataView.getInt16(0, true) / 16384;\n    let y = this.dataView.getInt16(2, true) / 16384;\n    let z = this.dataView.getInt16(4, true) / 16384;\n    [x, y, z] = [-y, z, -x];\n    const wSquared = 1 - (x * x + y * y + z * z);\n    const w = wSquared > 0 ? Math.sqrt(wSquared) : 0;\n    const quat = new Quaternion(x, y, z, w);\n\n    if (!homeQuatInverse) {\n      homeQuatInverse = quat.clone().inverse();\n    }\n\n    return quat.clone().multiply(homeQuatInverse.clone());\n  }\n\n  // Loops from 255 to 0.\n  public moveCounter(): number {\n    return this.arr[12];\n  }\n\n  public numMovesSince(previousMoveCounter: number): number {\n    return (this.moveCounter() - previousMoveCounter) & 0xff;\n  }\n\n  // Due to the design of the Gan356i protocol, it's common to query for the\n  // latest physical state and find 0 moves have been performed since the last\n  // query. Therefore, it's useful to allow 0 as an argument.\n  public latestMoves(n: number): BlockMove[] {\n    if (n < 0 || n > MAX_LATEST_MOVES) {\n      throw new Error(`Must ask for 0 to 6 latest moves. (Asked for ${n})`);\n    }\n    return Array.from(this.arr.slice(19 - n, 19)).map(\n      (i) => ganMoveToBlockMove[i],\n    );\n  }\n\n  public debugInfo(): { arr: Uint8Array } {\n    return {\n      arr: this.arr,\n    };\n  }\n}\n\n// TODO: Short IDs\nconst UUIDs = {\n  ganCubeService: \"0000fff0-0000-1000-8000-00805f9b34fb\",\n  physicalStateCharacteristic: \"0000fff5-0000-1000-8000-00805f9b34fb\",\n  actualAngleAndBatteryCharacteristic: \"0000fff7-0000-1000-8000-00805f9b34fb\",\n  faceletStatus1Characteristic: \"0000fff2-0000-1000-8000-00805f9b34fb\",\n  faceletStatus2Characteristic: \"0000fff3-0000-1000-8000-00805f9b34fb\",\n  infoService: \"0000180a-0000-1000-8000-00805f9b34fb\",\n  systemIDCharacteristic: \"00002a23-0000-1000-8000-00805f9b34fb\",\n  versionCharacteristic: \"00002a28-0000-1000-8000-00805f9b34fb\",\n};\n\nconst commands: { [cmd: string]: BufferSource } = {\n  reset: new Uint8Array([\n    0x00,\n    0x00,\n    0x24,\n    0x00,\n    0x49,\n    0x92,\n    0x24,\n    0x49,\n    0x6d,\n    0x92,\n    0xdb,\n    0xb6,\n    0x49,\n    0x92,\n    0xb6,\n    0x24,\n    0x6d,\n    0xdb,\n  ]),\n};\n\n// // TODO: Move this into a factory?\nexport const ganConfig: BluetoothConfig = {\n  filters: [{ namePrefix: \"GAN\" }],\n  optionalServices: [UUIDs.ganCubeService, UUIDs.infoService],\n};\n\nfunction buf2hex(buffer: ArrayBuffer): string {\n  // buffer is an ArrayBuffer\n  return Array.prototype.map\n    .call(new Uint8Array(buffer), (x: number) =>\n      (\"00\" + x.toString(16)).slice(-2),\n    )\n    .join(\" \");\n}\n\nconst reidEdgeOrder = \"UF UR UB UL DF DR DB DL FR FL BR BL\".split(\" \");\nconst reidCornerOrder = \"UFR URB UBL ULF DRF DFL DLB DBR\".split(\" \");\n\ninterface PieceInfo {\n  piece: number;\n  orientation: number;\n}\n\nfunction rotateLeft(s: string, i: number): string {\n  return s.slice(i) + s.slice(0, i);\n}\n\nconst pieceMap: { [s: string]: PieceInfo } = {};\n// TODO: Condense the for loops.\nreidEdgeOrder.forEach((edge, idx) => {\n  for (let i = 0; i < 2; i++) {\n    pieceMap[rotateLeft(edge, i)] = { piece: idx, orientation: i };\n  }\n});\nreidCornerOrder.forEach((corner, idx) => {\n  for (let i = 0; i < 3; i++) {\n    pieceMap[rotateLeft(corner, i)] = { piece: idx, orientation: i };\n  }\n});\n\nconst gan356iCornerMappings = [\n  [0, 21, 15],\n  [5, 13, 47],\n  [7, 45, 39],\n  [2, 37, 23],\n  [29, 10, 16],\n  [31, 18, 32],\n  [26, 34, 40],\n  [24, 42, 8],\n];\n\nconst gan356iEdgeMappings = [\n  [1, 22],\n  [3, 14],\n  [6, 46],\n  [4, 38],\n  [30, 17],\n  [27, 9],\n  [25, 41],\n  [28, 33],\n  [19, 12],\n  [20, 35],\n  [44, 11],\n  [43, 36],\n];\nconst faceOrder = \"URFDLB\";\n\nasync function getKey(\n  server: BluetoothRemoteGATTServer,\n): Promise<CryptoKey | null> {\n  const infoService = await server.getPrimaryService(UUIDs.infoService);\n\n  const versionCharacteristic = await infoService.getCharacteristic(\n    UUIDs.versionCharacteristic,\n  );\n  const versionBuffer = new Uint8Array(\n    (await versionCharacteristic.readValue()).buffer,\n  );\n\n  const versionValue =\n    (((versionBuffer[0] << 8) + versionBuffer[1]) << 8) + versionBuffer[2];\n  if (versionValue < 0x01_00_08) {\n    return null;\n  }\n\n  const keyXor = versionValue < 0x01_01_00 ? key10 : key11;\n\n  const systemIDCharacteristic = await infoService.getCharacteristic(\n    UUIDs.systemIDCharacteristic,\n  );\n  const systemID = new Uint8Array(\n    (await systemIDCharacteristic.readValue()).buffer,\n  ).reverse();\n\n  const key = new Uint8Array(keyXor);\n  for (let i = 0; i < systemID.length; i++) {\n    key[i] = (key[i] + systemID[i]) % 256;\n  }\n\n  return importKey(key);\n}\n\nexport class GanCube extends BluetoothPuzzle {\n  // We have to perform async operations before we call the constructor.\n  public static async connect(\n    server: BluetoothRemoteGATTServer,\n  ): Promise<GanCube> {\n    const ganCubeService = await server.getPrimaryService(UUIDs.ganCubeService);\n    debugLog(\"Service:\", ganCubeService);\n\n    const physicalStateCharacteristic = await ganCubeService.getCharacteristic(\n      UUIDs.physicalStateCharacteristic,\n    );\n    debugLog(\"Characteristic:\", physicalStateCharacteristic);\n\n    const aesKey = await getKey(server);\n\n    const initialMoveCounter = (\n      await PhysicalState.read(physicalStateCharacteristic, aesKey)\n    ).moveCounter();\n    debugLog(\"Initial Move Counter:\", initialMoveCounter);\n    const cube = new GanCube(\n      ganCubeService,\n      server,\n      physicalStateCharacteristic,\n      initialMoveCounter,\n      aesKey,\n    );\n    return cube;\n  }\n\n  public INTERVAL_MS: number = DEFAULT_INTERVAL_MS;\n  private intervalHandle: number | null = null;\n  private kpuzzle: KPuzzle = new KPuzzle(Puzzles[\"3x3x3\"]);\n  private cachedFaceletStatus1Characteristic: Promise<\n    BluetoothRemoteGATTCharacteristic\n  >;\n\n  private cachedFaceletStatus2Characteristic: Promise<\n    BluetoothRemoteGATTCharacteristic\n  >;\n\n  private cachedActualAngleAndBatteryCharacteristic: Promise<\n    BluetoothRemoteGATTCharacteristic\n  >;\n\n  private constructor(\n    private service: BluetoothRemoteGATTService,\n    private server: BluetoothRemoteGATTServer,\n    private physicalStateCharacteristic: BluetoothRemoteGATTCharacteristic,\n    private lastMoveCounter: number,\n    private aesKey: CryptoKey | null,\n  ) {\n    super();\n    this.startTrackingMoves();\n  }\n\n  public name(): string | undefined {\n    return this.server.device.name;\n  }\n\n  public startTrackingMoves(): void {\n    // `window.setInterval` instead of `setInterval`:\n    // https://github.com/Microsoft/TypeScript/issues/842#issuecomment-252445883\n    this.intervalHandle = window.setInterval(\n      this.intervalHandler.bind(this),\n      this.INTERVAL_MS,\n    );\n  }\n\n  public stopTrackingMoves(): void {\n    if (!this.intervalHandle) {\n      throw new Error(\"Not tracking moves!\");\n    }\n    clearInterval(this.intervalHandle);\n    this.intervalHandle = null;\n  }\n\n  // TODO: Can we ever receive async responses out of order?\n  public async intervalHandler(): Promise<void> {\n    const physicalState = await PhysicalState.read(\n      this.physicalStateCharacteristic,\n      this.aesKey,\n    );\n    let numInterveningMoves = physicalState.numMovesSince(this.lastMoveCounter);\n    // console.log(numInterveningMoves);\n    if (numInterveningMoves > MAX_LATEST_MOVES) {\n      debugLog(\n        `Too many moves! Dropping ${\n          numInterveningMoves - MAX_LATEST_MOVES\n        } moves`,\n      );\n      numInterveningMoves = MAX_LATEST_MOVES;\n    }\n    for (const move of physicalState.latestMoves(numInterveningMoves)) {\n      // console.log(move);\n      this.kpuzzle.applyBlockMove(move);\n      this.dispatchMove({\n        latestMove: move,\n        timeStamp: physicalState.timeStamp,\n        debug: physicalState.debugInfo(),\n        state: this.kpuzzle.state,\n        // quaternion: physicalState.rotQuat(),\n      });\n    }\n    this.dispatchOrientation({\n      timeStamp: physicalState.timeStamp,\n      quaternion: physicalState.rotQuat(),\n    });\n    this.lastMoveCounter = physicalState.moveCounter();\n  }\n\n  public async getBattery(): Promise<number> {\n    return new Uint8Array(\n      await this.readActualAngleAndBatteryCharacteristic(),\n    )[7];\n  }\n\n  public async getState(): Promise<PuzzleState> {\n    const arr: Uint8Array = await decryptState(\n      new Uint8Array(await this.readFaceletStatus1Characteristic()),\n      this.aesKey,\n    );\n    const stickers: number[] = [];\n    for (let i = 0; i < 18; i += 3) {\n      let v = (((arr[i ^ 1] << 8) + arr[(i + 1) ^ 1]) << 8) + arr[(i + 2) ^ 1];\n      for (let j = 0; j < 8; j++) {\n        stickers.push(v & 7);\n        v >>= 3;\n      }\n    }\n\n    const state: PuzzleState = {\n      CORNERS: {\n        permutation: [],\n        orientation: [],\n      },\n      EDGES: {\n        permutation: [],\n        orientation: [],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 0, 0, 0, 0],\n      },\n    };\n\n    for (const cornerMapping of gan356iCornerMappings) {\n      const pieceInfo: PieceInfo =\n        pieceMap[cornerMapping.map((i) => faceOrder[stickers[i]]).join(\"\")];\n      state.CORNERS.permutation.push(pieceInfo.piece);\n      state.CORNERS.orientation.push(pieceInfo.orientation);\n    }\n\n    for (const edgeMapping of gan356iEdgeMappings) {\n      const pieceInfo: PieceInfo =\n        pieceMap[edgeMapping.map((i) => faceOrder[stickers[i]]).join(\"\")];\n      state.EDGES.permutation.push(pieceInfo.piece);\n      state.EDGES.orientation.push(pieceInfo.orientation);\n    }\n\n    return state;\n  }\n\n  public async faceletStatus1Characteristic(): Promise<\n    BluetoothRemoteGATTCharacteristic\n  > {\n    this.cachedFaceletStatus1Characteristic =\n      this.cachedFaceletStatus1Characteristic ||\n      this.service.getCharacteristic(UUIDs.faceletStatus1Characteristic);\n    return this.cachedFaceletStatus1Characteristic;\n  }\n\n  public async faceletStatus2Characteristic(): Promise<\n    BluetoothRemoteGATTCharacteristic\n  > {\n    this.cachedFaceletStatus2Characteristic =\n      this.cachedFaceletStatus2Characteristic ||\n      this.service.getCharacteristic(UUIDs.faceletStatus2Characteristic);\n    return this.cachedFaceletStatus2Characteristic;\n  }\n\n  public async actualAngleAndBatteryCharacteristic(): Promise<\n    BluetoothRemoteGATTCharacteristic\n  > {\n    this.cachedActualAngleAndBatteryCharacteristic =\n      this.cachedActualAngleAndBatteryCharacteristic ||\n      this.service.getCharacteristic(UUIDs.actualAngleAndBatteryCharacteristic);\n    return this.cachedActualAngleAndBatteryCharacteristic;\n  }\n\n  public async reset(): Promise<void> {\n    const faceletStatus1Characteristic = await this.faceletStatus1Characteristic();\n    await faceletStatus1Characteristic.writeValue(commands.reset);\n  }\n\n  public async readFaceletStatus1Characteristic(): Promise<ArrayBuffer> {\n    const faceletStatus1Characteristic = await this.faceletStatus1Characteristic();\n    return (await faceletStatus1Characteristic.readValue()).buffer;\n  }\n\n  public async readFaceletStatus2Characteristic(): Promise<string> {\n    const faceletStatus2Characteristic = await this.faceletStatus2Characteristic();\n    return buf2hex((await faceletStatus2Characteristic.readValue()).buffer);\n  }\n\n  public async readActualAngleAndBatteryCharacteristic(): Promise<ArrayBuffer> {\n    const actualAngleAndBatteryCharacteristic = await this.actualAngleAndBatteryCharacteristic();\n    return (await actualAngleAndBatteryCharacteristic.readValue()).buffer;\n  }\n\n  // TODO\n  // private onphysicalStateCharacteristicChanged(event: any): void {\n  //   var val = event.target.value;\n  //   debugLog(val);\n  // }\n}\n", "/* tslint:disable no-bitwise */\n\nimport { BareBlockMove, BlockMove } from \"../alg\";\nimport { Transformation } from \"../kpuzzle\";\nimport {\n  BluetoothConfig,\n  BluetoothPuzzle,\n  PuzzleState,\n} from \"./bluetooth-puzzle\";\nimport { debugLog } from \"./debug\";\n\nconst MESSAGE_LENGTH = 20;\n\nconst UUIDs = {\n  cubeService: \"0000aadb-0000-1000-8000-00805f9b34fb\",\n  cubeCharacteristic: \"0000aadc-0000-1000-8000-00805f9b34fb\",\n};\n\n// TODO: Move this into a factory?\nexport const giiKERConfig: BluetoothConfig = {\n  filters: [\n    // Known prefixes: GiC, GiS (3x3x3), Gi2 (2x2x2)\n    // Suspected prefixes GiY, Gi3\n    { namePrefix: \"Gi\" },\n    { services: [\"0000aadb-0000-1000-8000-00805f9b34fb\"] },\n    { services: [\"0000aaaa-0000-1000-8000-00805f9b34fb\"] },\n    { services: [\"0000fe95-0000-1000-8000-00805f9b34fb\"] },\n  ],\n  optionalServices: [\n    // \"00001530-1212-efde-1523-785feabcd123\",\n    // \"0000aaaa-0000-1000-8000-00805f9b34fb\",\n    UUIDs.cubeService,\n    // \"0000180f-0000-1000-8000-00805f9b34fb\",\n    // \"0000180a-0000-1000-8000-00805f9b34fb\"\n  ],\n};\n\n// TODO: Expose for testing.\nfunction giikerMoveToBlockMove(face: number, amount: number): BlockMove {\n  switch (amount) {\n    case 3:\n      amount = -1;\n      break;\n    case 9:\n      debugLog(\"Encountered 9\", face, amount);\n      amount = -2;\n      break;\n  }\n\n  const family = [\"?\", \"B\", \"D\", \"L\", \"U\", \"R\", \"F\"][face];\n  return BareBlockMove(family, amount);\n}\n\nexport { giikerMoveToBlockMove as giikerMoveToBlockMoveForTesting };\n\nfunction giikerStateStr(giikerState: number[]): string {\n  let str = \"\";\n  str += giikerState.slice(0, 8).join(\".\");\n  str += \"\\n\";\n  str += giikerState.slice(8, 16).join(\".\");\n  str += \"\\n\";\n  str += giikerState.slice(16, 28).join(\".\");\n  str += \"\\n\";\n  str += giikerState.slice(28, 32).join(\".\");\n  str += \"\\n\";\n  str += giikerState.slice(32, 40).join(\".\");\n  return str;\n}\n\n// TODO\n// const Reid333Orbits = {\n//   \"EDGES\":   {\"numPieces\": 12, \"orientations\": 2},\n//   \"CORNERS\": {\"numPieces\": 8,  \"orientations\": 3},\n//   \"CENTERS\": {\"numPieces\": 6,  \"orientations\": 4}\n// };\n\nconst Reid333SolvedCenters = {\n  permutation: [0, 1, 2, 3, 4, 5],\n  orientation: [0, 0, 0, 0, 0, 0],\n};\n\nconst epGiiKERtoReid333: number[] = [4, 8, 0, 9, 5, 1, 3, 7, 6, 10, 2, 11];\nconst epReid333toGiiKER: number[] = [2, 5, 10, 6, 0, 4, 8, 7, 1, 3, 9, 11];\n\nconst preEO: number[] = [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0];\nconst postEO: number[] = [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0];\n\nconst cpGiiKERtoReid333: number[] = [4, 0, 3, 5, 7, 1, 2, 6];\nconst cpReid333toGiiKER: number[] = [1, 5, 6, 2, 0, 3, 7, 4];\n\nconst preCO: number[] = [1, 2, 1, 2, 2, 1, 2, 1];\nconst postCO: number[] = [2, 1, 2, 1, 1, 2, 1, 2];\n\nconst coFlip: number[] = [-1, 1, -1, 1, 1, -1, 1, -1];\n\nfunction getNibble(val: Uint8Array, i: number): number {\n  if (i % 2 === 1) {\n    return val[(i / 2) | 0] % 16;\n  }\n  return 0 | (val[(i / 2) | 0] / 16);\n}\n\nfunction probablyEncrypted(data: Uint8Array): boolean {\n  return data[18] === 0xa7;\n}\n\nconst lookup = [\n  176,\n  81,\n  104,\n  224,\n  86,\n  137,\n  237,\n  119,\n  38,\n  26,\n  193,\n  161,\n  210,\n  126,\n  150,\n  81,\n  93,\n  13,\n  236,\n  249,\n  89,\n  235,\n  88,\n  24,\n  113,\n  81,\n  214,\n  131,\n  130,\n  199,\n  2,\n  169,\n  39,\n  165,\n  171,\n  41,\n];\n\nfunction decryptState(data: Uint8Array): Uint8Array {\n  const offset1 = getNibble(data, 38);\n  const offset2 = getNibble(data, 39);\n  const output = new Uint8Array(MESSAGE_LENGTH);\n  for (let i = 0; i < MESSAGE_LENGTH; i++) {\n    output[i] = data[i] + lookup[offset1 + i] + lookup[offset2 + i];\n  }\n  return output;\n}\n\n// TODO: Support caching which decoding strategy worked last time.\nasync function decodeState(data: Uint8Array): Promise<Uint8Array> {\n  if (!probablyEncrypted(data)) {\n    return data;\n  }\n  return await decryptState(data);\n  // TODO: Check that the decrypted state is a valid staet.\n}\n\nexport class GiiKERCube extends BluetoothPuzzle {\n  public static async connect(\n    server: BluetoothRemoteGATTServer,\n  ): Promise<GiiKERCube> {\n    const cubeService = await server.getPrimaryService(UUIDs.cubeService);\n    debugLog(\"Service:\", cubeService);\n\n    const cubeCharacteristic = await cubeService.getCharacteristic(\n      UUIDs.cubeCharacteristic,\n    );\n    debugLog(\"Characteristic:\", cubeCharacteristic);\n\n    // TODO: Can we safely save the async promise instead of waiting for the response?\n\n    const originalValue = await decodeState(\n      new Uint8Array((await cubeCharacteristic.readValue()).buffer),\n    );\n    debugLog(\"Original value:\", originalValue);\n    const cube = new GiiKERCube(server, cubeCharacteristic, originalValue);\n\n    await cubeCharacteristic.startNotifications();\n    cubeCharacteristic.addEventListener(\n      \"characteristicvaluechanged\",\n      cube.onCubeCharacteristicChanged.bind(cube),\n    );\n\n    return cube;\n  }\n\n  private constructor(\n    private server: BluetoothRemoteGATTServer,\n    private cubeCharacteristic: BluetoothRemoteGATTCharacteristic,\n    private originalValue?: Uint8Array | null,\n  ) {\n    super();\n  }\n\n  public name(): string | undefined {\n    return this.server.device.name;\n  }\n\n  public async getState(): Promise<PuzzleState> {\n    return this.toReid333(\n      new Uint8Array((await this.cubeCharacteristic.readValue()).buffer),\n    );\n  }\n\n  private getBit(val: Uint8Array, i: number): number {\n    const n = (i / 8) | 0;\n    const shift = 7 - (i % 8);\n    return (val[n] >> shift) & 1;\n  }\n\n  private toReid333(val: Uint8Array): Transformation {\n    const state = {\n      EDGES: {\n        permutation: new Array(12),\n        orientation: new Array(12),\n      },\n      CORNERS: {\n        permutation: new Array(8),\n        orientation: new Array(8),\n      },\n      CENTERS: Reid333SolvedCenters,\n    };\n\n    for (let i = 0; i < 12; i++) {\n      const gi = epReid333toGiiKER[i];\n      state.EDGES.permutation[i] =\n        epGiiKERtoReid333[getNibble(val, gi + 16) - 1];\n      state.EDGES.orientation[i] =\n        this.getBit(val, gi + 112) ^\n        preEO[state.EDGES.permutation[i]] ^\n        postEO[i];\n    }\n    for (let i = 0; i < 8; i++) {\n      const gi = cpReid333toGiiKER[i];\n      state.CORNERS.permutation[i] = cpGiiKERtoReid333[getNibble(val, gi) - 1];\n      state.CORNERS.orientation[i] =\n        (getNibble(val, gi + 8) * coFlip[gi] +\n          preCO[state.CORNERS.permutation[i]] +\n          postCO[i]) %\n        3;\n    }\n    return state;\n  }\n\n  private async onCubeCharacteristicChanged(event: any): Promise<void> {\n    const val = await decodeState(new Uint8Array(event.target.value.buffer));\n    debugLog(val);\n    debugLog(val);\n\n    if (this.isRepeatedInitialValue(val)) {\n      debugLog(\"Skipping repeated initial value.\");\n      return;\n    }\n\n    const giikerState = [];\n    for (let i = 0; i < MESSAGE_LENGTH; i++) {\n      giikerState.push(Math.floor(val[i] / 16));\n      giikerState.push(val[i] % 16);\n    }\n    debugLog(giikerState);\n    const str = giikerStateStr(giikerState);\n    debugLog(str);\n\n    this.dispatchMove({\n      latestMove: giikerMoveToBlockMove(giikerState[32], giikerState[33]),\n      timeStamp: event.timeStamp,\n      debug: {\n        stateStr: str,\n      },\n      state: this.toReid333(val),\n    });\n  }\n\n  private isRepeatedInitialValue(val: Uint8Array): boolean {\n    if (typeof this.originalValue === \"undefined\") {\n      // TODO: Test this branch.\n      throw new Error(\"GiiKERCube has uninitialized original value.\");\n    }\n\n    if (this.originalValue === null) {\n      return false;\n    }\n\n    const originalValue = this.originalValue;\n    // Reset the value here, so we can return early below.\n    this.originalValue = null;\n\n    debugLog(\"Comparing against original value.\");\n    for (let i = 0; i < MESSAGE_LENGTH - 2; i++) {\n      if (originalValue[i] !== val[i]) {\n        debugLog(\"Different at index \", i);\n        return false;\n      }\n    }\n    return true;\n  }\n}\n", "/* tslint:disable no-bitwise */\n\nimport { BareBlockMove, BlockMove } from \"../alg\";\nimport { Transformation } from \"../kpuzzle\";\nimport {\n  BluetoothConfig,\n  BluetoothPuzzle,\n  PuzzleState,\n} from \"./bluetooth-puzzle\";\nimport { debugLog } from \"./debug\";\n\nconst MESSAGE_LENGTH = 20;\n\nconst UUIDs = {\n  cubeService: \"0000aadb-0000-1000-8000-00805f9b34fb\",\n  cubeCharacteristic: \"0000aadc-0000-1000-8000-00805f9b34fb\",\n};\n\n// TODO: Move this into a factory?\nexport const giiKERConfig: BluetoothConfig = {\n  filters: [\n    // Known prefixes: GiC, GiS (3x3x3), Gi2 (2x2x2)\n    // Suspected prefixes GiY, Gi3\n    { namePrefix: \"Gi\" },\n    { services: [\"0000aadb-0000-1000-8000-00805f9b34fb\"] },\n    { services: [\"0000aaaa-0000-1000-8000-00805f9b34fb\"] },\n    { services: [\"0000fe95-0000-1000-8000-00805f9b34fb\"] },\n  ],\n  optionalServices: [\n    // \"00001530-1212-efde-1523-785feabcd123\",\n    // \"0000aaaa-0000-1000-8000-00805f9b34fb\",\n    UUIDs.cubeService,\n    // \"0000180f-0000-1000-8000-00805f9b34fb\",\n    // \"0000180a-0000-1000-8000-00805f9b34fb\"\n  ],\n};\n\n// TODO: Expose for testing.\nfunction giikerMoveToBlockMove(face: number, amount: number): BlockMove {\n  switch (amount) {\n    case 3:\n      amount = -1;\n      break;\n    case 9:\n      debugLog(\"Encountered 9\", face, amount);\n      amount = -2;\n      break;\n  }\n\n  const family = [\"?\", \"B\", \"D\", \"L\", \"U\", \"R\", \"F\"][face];\n  return BareBlockMove(family, amount);\n}\n\nexport { giikerMoveToBlockMove as giikerMoveToBlockMoveForTesting };\n\nfunction giikerStateStr(giikerState: number[]): string {\n  let str = \"\";\n  str += giikerState.slice(0, 8).join(\".\");\n  str += \"\\n\";\n  str += giikerState.slice(8, 16).join(\".\");\n  str += \"\\n\";\n  str += giikerState.slice(16, 28).join(\".\");\n  str += \"\\n\";\n  str += giikerState.slice(28, 32).join(\".\");\n  str += \"\\n\";\n  str += giikerState.slice(32, 40).join(\".\");\n  return str;\n}\n\n// TODO\n// const Reid333Orbits = {\n//   \"EDGES\":   {\"numPieces\": 12, \"orientations\": 2},\n//   \"CORNERS\": {\"numPieces\": 8,  \"orientations\": 3},\n//   \"CENTERS\": {\"numPieces\": 6,  \"orientations\": 4}\n// };\n\nconst Reid333SolvedCenters = {\n  permutation: [0, 1, 2, 3, 4, 5],\n  orientation: [0, 0, 0, 0, 0, 0],\n};\n\nconst epGiiKERtoReid333: number[] = [4, 8, 0, 9, 5, 1, 3, 7, 6, 10, 2, 11];\nconst epReid333toGiiKER: number[] = [2, 5, 10, 6, 0, 4, 8, 7, 1, 3, 9, 11];\n\nconst preEO: number[] = [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0];\nconst postEO: number[] = [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0];\n\nconst cpGiiKERtoReid333: number[] = [4, 0, 3, 5, 7, 1, 2, 6];\nconst cpReid333toGiiKER: number[] = [1, 5, 6, 2, 0, 3, 7, 4];\n\nconst preCO: number[] = [1, 2, 1, 2, 2, 1, 2, 1];\nconst postCO: number[] = [2, 1, 2, 1, 1, 2, 1, 2];\n\nconst coFlip: number[] = [-1, 1, -1, 1, 1, -1, 1, -1];\n\nfunction getNibble(val: Uint8Array, i: number): number {\n  if (i % 2 === 1) {\n    return val[(i / 2) | 0] % 16;\n  }\n  return 0 | (val[(i / 2) | 0] / 16);\n}\n\nfunction probablyEncrypted(data: Uint8Array): boolean {\n  return data[18] === 0xa7;\n}\n\nconst lookup = [\n  176,\n  81,\n  104,\n  224,\n  86,\n  137,\n  237,\n  119,\n  38,\n  26,\n  193,\n  161,\n  210,\n  126,\n  150,\n  81,\n  93,\n  13,\n  236,\n  249,\n  89,\n  235,\n  88,\n  24,\n  113,\n  81,\n  214,\n  131,\n  130,\n  199,\n  2,\n  169,\n  39,\n  165,\n  171,\n  41,\n];\n\nfunction decryptState(data: Uint8Array): Uint8Array {\n  const offset1 = getNibble(data, 38);\n  const offset2 = getNibble(data, 39);\n  const output = new Uint8Array(MESSAGE_LENGTH);\n  for (let i = 0; i < MESSAGE_LENGTH; i++) {\n    output[i] = data[i] + lookup[offset1 + i] + lookup[offset2 + i];\n  }\n  return output;\n}\n\n// TODO: Support caching which decoding strategy worked last time.\nasync function decodeState(data: Uint8Array): Promise<Uint8Array> {\n  if (!probablyEncrypted(data)) {\n    return data;\n  }\n  return await decryptState(data);\n  // TODO: Check that the decrypted state is a valid staet.\n}\n\nexport class GiiKERCube extends BluetoothPuzzle {\n  public static async connect(\n    server: BluetoothRemoteGATTServer,\n  ): Promise<GiiKERCube> {\n    const cubeService = await server.getPrimaryService(UUIDs.cubeService);\n    debugLog(\"Service:\", cubeService);\n\n    const cubeCharacteristic = await cubeService.getCharacteristic(\n      UUIDs.cubeCharacteristic,\n    );\n    debugLog(\"Characteristic:\", cubeCharacteristic);\n\n    // TODO: Can we safely save the async promise instead of waiting for the response?\n\n    const originalValue = await decodeState(\n      new Uint8Array((await cubeCharacteristic.readValue()).buffer),\n    );\n    debugLog(\"Original value:\", originalValue);\n    const cube = new GiiKERCube(server, cubeCharacteristic, originalValue);\n\n    await cubeCharacteristic.startNotifications();\n    cubeCharacteristic.addEventListener(\n      \"characteristicvaluechanged\",\n      cube.onCubeCharacteristicChanged.bind(cube),\n    );\n\n    return cube;\n  }\n\n  private constructor(\n    private server: BluetoothRemoteGATTServer,\n    private cubeCharacteristic: BluetoothRemoteGATTCharacteristic,\n    private originalValue?: Uint8Array | null,\n  ) {\n    super();\n  }\n\n  public name(): string | undefined {\n    return this.server.device.name;\n  }\n\n  public async getState(): Promise<PuzzleState> {\n    return this.toReid333(\n      new Uint8Array((await this.cubeCharacteristic.readValue()).buffer),\n    );\n  }\n\n  private getBit(val: Uint8Array, i: number): number {\n    const n = (i / 8) | 0;\n    const shift = 7 - (i % 8);\n    return (val[n] >> shift) & 1;\n  }\n\n  private toReid333(val: Uint8Array): Transformation {\n    const state = {\n      EDGES: {\n        permutation: new Array(12),\n        orientation: new Array(12),\n      },\n      CORNERS: {\n        permutation: new Array(8),\n        orientation: new Array(8),\n      },\n      CENTERS: Reid333SolvedCenters,\n    };\n\n    for (let i = 0; i < 12; i++) {\n      const gi = epReid333toGiiKER[i];\n      state.EDGES.permutation[i] =\n        epGiiKERtoReid333[getNibble(val, gi + 16) - 1];\n      state.EDGES.orientation[i] =\n        this.getBit(val, gi + 112) ^\n        preEO[state.EDGES.permutation[i]] ^\n        postEO[i];\n    }\n    for (let i = 0; i < 8; i++) {\n      const gi = cpReid333toGiiKER[i];\n      state.CORNERS.permutation[i] = cpGiiKERtoReid333[getNibble(val, gi) - 1];\n      state.CORNERS.orientation[i] =\n        (getNibble(val, gi + 8) * coFlip[gi] +\n          preCO[state.CORNERS.permutation[i]] +\n          postCO[i]) %\n        3;\n    }\n    return state;\n  }\n\n  private async onCubeCharacteristicChanged(event: any): Promise<void> {\n    const val = await decodeState(new Uint8Array(event.target.value.buffer));\n    debugLog(val);\n    debugLog(val);\n\n    if (this.isRepeatedInitialValue(val)) {\n      debugLog(\"Skipping repeated initial value.\");\n      return;\n    }\n\n    const giikerState = [];\n    for (let i = 0; i < MESSAGE_LENGTH; i++) {\n      giikerState.push(Math.floor(val[i] / 16));\n      giikerState.push(val[i] % 16);\n    }\n    debugLog(giikerState);\n    const str = giikerStateStr(giikerState);\n    debugLog(str);\n\n    this.dispatchMove({\n      latestMove: giikerMoveToBlockMove(giikerState[32], giikerState[33]),\n      timeStamp: event.timeStamp,\n      debug: {\n        stateStr: str,\n      },\n      state: this.toReid333(val),\n    });\n  }\n\n  private isRepeatedInitialValue(val: Uint8Array): boolean {\n    if (typeof this.originalValue === \"undefined\") {\n      // TODO: Test this branch.\n      throw new Error(\"GiiKERCube has uninitialized original value.\");\n    }\n\n    if (this.originalValue === null) {\n      return false;\n    }\n\n    const originalValue = this.originalValue;\n    // Reset the value here, so we can return early below.\n    this.originalValue = null;\n\n    debugLog(\"Comparing against original value.\");\n    for (let i = 0; i < MESSAGE_LENGTH - 2; i++) {\n      if (originalValue[i] !== val[i]) {\n        debugLog(\"Different at index \", i);\n        return false;\n      }\n    }\n    return true;\n  }\n}\n", "import { Quaternion } from \"three\";\nimport { BareBlockMove, BlockMove, Sequence } from \"../alg\";\nimport { BluetoothConfig, BluetoothPuzzle } from \"./bluetooth-puzzle\";\nimport { debugLog } from \"./debug\";\n\nconst UUIDs = {\n  goCubeService: \"6e400001-b5a3-f393-e0a9-e50e24dcca9e\",\n  goCubeStateCharacteristic: \"6e400003-b5a3-f393-e0a9-e50e24dcca9e\",\n};\n\n// TODO: Move this into a factory?\nexport const goCubeConfig: BluetoothConfig = {\n  filters: [{ namePrefix: \"GoCube\" }, { namePrefix: \"Rubik\" }],\n  optionalServices: [UUIDs.goCubeService],\n};\n\n// https://stackoverflow.com/a/40031979\nfunction buf2hex(buffer: ArrayBuffer): string {\n  // buffer is an ArrayBuffer\n  return Array.prototype.map\n    .call(new Uint8Array(buffer), (x: number) =>\n      (\"00\" + x.toString(16)).slice(-2),\n    )\n    .join(\"\");\n}\n\nfunction bufferToString(buffer: ArrayBuffer): string {\n  const byteView = new Uint8Array(buffer);\n  let str = \"\";\n  for (const charCode of byteView) {\n    str += String.fromCharCode(charCode);\n  }\n  return str;\n}\n\nconst moveMap: BlockMove[] = [\n  BareBlockMove(\"B\", 1),\n  BareBlockMove(\"B\", -1),\n  BareBlockMove(\"F\", 1),\n  BareBlockMove(\"F\", -1),\n  BareBlockMove(\"U\", 1),\n  BareBlockMove(\"U\", -1),\n  BareBlockMove(\"D\", 1),\n  BareBlockMove(\"D\", -1),\n  BareBlockMove(\"R\", 1),\n  BareBlockMove(\"R\", -1),\n  BareBlockMove(\"L\", 1),\n  BareBlockMove(\"L\", -1),\n];\n\nexport class GoCube extends BluetoothPuzzle {\n  // We have to perform async operations before we call the constructor.\n  public static async connect(\n    server: BluetoothRemoteGATTServer,\n  ): Promise<GoCube> {\n    const service = await server.getPrimaryService(UUIDs.goCubeService);\n    debugLog({ service });\n    const goCubeStateCharacteristic = await service.getCharacteristic(\n      UUIDs.goCubeStateCharacteristic,\n    );\n    debugLog({ goCubeStateCharacteristic });\n\n    const cube = new GoCube(server, goCubeStateCharacteristic);\n\n    await goCubeStateCharacteristic.startNotifications();\n    goCubeStateCharacteristic.addEventListener(\n      \"characteristicvaluechanged\",\n      cube.onCubeCharacteristicChanged.bind(cube),\n    );\n\n    return cube;\n  }\n\n  // public async getState(): Promise<PuzzleState> {\n  //   return new Promise((resolve, reject) => {\n  //     this.resolve = (value: any) => {\n  //       resolve(buf2hex(value.buffer) as any);\n  //     };\n  //     this.goCubeStateCharacteristic.startNotifications();\n  //   });\n  // }\n\n  private recorded: any[][] = [];\n\n  private homeQuatInverse: Quaternion | null = null;\n  private lastRawQuat: Quaternion = new Quaternion(0, 0, 0, 1);\n  private currentQuat: Quaternion = new Quaternion(0, 0, 0, 1);\n  private lastTarget: Quaternion = new Quaternion(0, 0, 0, 1);\n  private alg: Sequence = new Sequence([]);\n\n  private constructor(\n    private server: BluetoothRemoteGATTServer,\n    public goCubeStateCharacteristic: BluetoothRemoteGATTCharacteristic,\n  ) {\n    super();\n  }\n\n  public reset(): void {\n    this.resetAlg();\n    this.resetOrientation();\n  }\n\n  public resetAlg(algo?: Sequence): void {\n    this.alg = algo || new Sequence([]);\n  }\n\n  public resetOrientation(): void {\n    this.homeQuatInverse = this.lastRawQuat.clone().inverse();\n    this.currentQuat = new Quaternion(0, 0, 0, 1);\n    this.lastTarget = new Quaternion(0, 0, 0, 1);\n  }\n\n  public name(): string | undefined {\n    return this.server.device.name;\n  }\n\n  private onCubeCharacteristicChanged(event: any): void {\n    const buffer: DataView = event.target.value;\n    this.recorded.push([event.timeStamp, buf2hex(buffer.buffer)]);\n    if (buffer.byteLength === 8) {\n      const move = moveMap[buffer.getUint8(3)];\n      this.alg = new Sequence(this.alg.nestedUnits.concat([move]));\n      this.dispatchMove({\n        latestMove: moveMap[buffer.getUint8(3)],\n        timeStamp: event.timeStamp,\n        debug: {\n          stateStr: buf2hex(buffer.buffer),\n        },\n      });\n    } else {\n      const coords = bufferToString(\n        buffer.buffer.slice(3, buffer.byteLength - 3),\n      )\n        .split(\"#\")\n        .map((s) => parseInt(s, 10) / 16384);\n      const quat = new Quaternion(coords[0], coords[1], coords[2], coords[3]);\n\n      this.lastRawQuat = quat.clone();\n\n      if (!this.homeQuatInverse) {\n        this.homeQuatInverse = quat.clone().inverse();\n      }\n\n      const targetQuat = quat.clone().multiply(this.homeQuatInverse.clone());\n      targetQuat.y = -targetQuat.y; // GoCube axis fix.\n\n      this.lastTarget.slerp(targetQuat, 0.5);\n      this.currentQuat.rotateTowards(this.lastTarget, rotateTowardsRate);\n\n      this.dispatchOrientation({\n        quaternion: this.currentQuat,\n        timeStamp: event.timeStamp,\n      });\n    }\n  }\n}\n\nconst rotateTowardsRate = 0.5;\n", "import { Quaternion } from \"three\";\nimport { BareBlockMove, BlockMove, Sequence } from \"../alg\";\nimport { BluetoothConfig, BluetoothPuzzle } from \"./bluetooth-puzzle\";\nimport { debugLog } from \"./debug\";\n\nconst UUIDs = {\n  goCubeService: \"6e400001-b5a3-f393-e0a9-e50e24dcca9e\",\n  goCubeStateCharacteristic: \"6e400003-b5a3-f393-e0a9-e50e24dcca9e\",\n};\n\n// TODO: Move this into a factory?\nexport const goCubeConfig: BluetoothConfig = {\n  filters: [{ namePrefix: \"GoCube\" }, { namePrefix: \"Rubik\" }],\n  optionalServices: [UUIDs.goCubeService],\n};\n\n// https://stackoverflow.com/a/40031979\nfunction buf2hex(buffer: ArrayBuffer): string {\n  // buffer is an ArrayBuffer\n  return Array.prototype.map\n    .call(new Uint8Array(buffer), (x: number) =>\n      (\"00\" + x.toString(16)).slice(-2),\n    )\n    .join(\"\");\n}\n\nfunction bufferToString(buffer: ArrayBuffer): string {\n  const byteView = new Uint8Array(buffer);\n  let str = \"\";\n  for (const charCode of byteView) {\n    str += String.fromCharCode(charCode);\n  }\n  return str;\n}\n\nconst moveMap: BlockMove[] = [\n  BareBlockMove(\"B\", 1),\n  BareBlockMove(\"B\", -1),\n  BareBlockMove(\"F\", 1),\n  BareBlockMove(\"F\", -1),\n  BareBlockMove(\"U\", 1),\n  BareBlockMove(\"U\", -1),\n  BareBlockMove(\"D\", 1),\n  BareBlockMove(\"D\", -1),\n  BareBlockMove(\"R\", 1),\n  BareBlockMove(\"R\", -1),\n  BareBlockMove(\"L\", 1),\n  BareBlockMove(\"L\", -1),\n];\n\nexport class GoCube extends BluetoothPuzzle {\n  // We have to perform async operations before we call the constructor.\n  public static async connect(\n    server: BluetoothRemoteGATTServer,\n  ): Promise<GoCube> {\n    const service = await server.getPrimaryService(UUIDs.goCubeService);\n    debugLog({ service });\n    const goCubeStateCharacteristic = await service.getCharacteristic(\n      UUIDs.goCubeStateCharacteristic,\n    );\n    debugLog({ goCubeStateCharacteristic });\n\n    const cube = new GoCube(server, goCubeStateCharacteristic);\n\n    await goCubeStateCharacteristic.startNotifications();\n    goCubeStateCharacteristic.addEventListener(\n      \"characteristicvaluechanged\",\n      cube.onCubeCharacteristicChanged.bind(cube),\n    );\n\n    return cube;\n  }\n\n  // public async getState(): Promise<PuzzleState> {\n  //   return new Promise((resolve, reject) => {\n  //     this.resolve = (value: any) => {\n  //       resolve(buf2hex(value.buffer) as any);\n  //     };\n  //     this.goCubeStateCharacteristic.startNotifications();\n  //   });\n  // }\n\n  private recorded: any[][] = [];\n\n  private homeQuatInverse: Quaternion | null = null;\n  private lastRawQuat: Quaternion = new Quaternion(0, 0, 0, 1);\n  private currentQuat: Quaternion = new Quaternion(0, 0, 0, 1);\n  private lastTarget: Quaternion = new Quaternion(0, 0, 0, 1);\n  private alg: Sequence = new Sequence([]);\n\n  private constructor(\n    private server: BluetoothRemoteGATTServer,\n    public goCubeStateCharacteristic: BluetoothRemoteGATTCharacteristic,\n  ) {\n    super();\n  }\n\n  public reset(): void {\n    this.resetAlg();\n    this.resetOrientation();\n  }\n\n  public resetAlg(algo?: Sequence): void {\n    this.alg = algo || new Sequence([]);\n  }\n\n  public resetOrientation(): void {\n    this.homeQuatInverse = this.lastRawQuat.clone().inverse();\n    this.currentQuat = new Quaternion(0, 0, 0, 1);\n    this.lastTarget = new Quaternion(0, 0, 0, 1);\n  }\n\n  public name(): string | undefined {\n    return this.server.device.name;\n  }\n\n  private onCubeCharacteristicChanged(event: any): void {\n    const buffer: DataView = event.target.value;\n    this.recorded.push([event.timeStamp, buf2hex(buffer.buffer)]);\n    if (buffer.byteLength === 8) {\n      const move = moveMap[buffer.getUint8(3)];\n      this.alg = new Sequence(this.alg.nestedUnits.concat([move]));\n      this.dispatchMove({\n        latestMove: moveMap[buffer.getUint8(3)],\n        timeStamp: event.timeStamp,\n        debug: {\n          stateStr: buf2hex(buffer.buffer),\n        },\n      });\n    } else {\n      const coords = bufferToString(\n        buffer.buffer.slice(3, buffer.byteLength - 3),\n      )\n        .split(\"#\")\n        .map((s) => parseInt(s, 10) / 16384);\n      const quat = new Quaternion(coords[0], coords[1], coords[2], coords[3]);\n\n      this.lastRawQuat = quat.clone();\n\n      if (!this.homeQuatInverse) {\n        this.homeQuatInverse = quat.clone().inverse();\n      }\n\n      const targetQuat = quat.clone().multiply(this.homeQuatInverse.clone());\n      targetQuat.y = -targetQuat.y; // GoCube axis fix.\n\n      this.lastTarget.slerp(targetQuat, 0.5);\n      this.currentQuat.rotateTowards(this.lastTarget, rotateTowardsRate);\n\n      this.dispatchOrientation({\n        quaternion: this.currentQuat,\n        timeStamp: event.timeStamp,\n      });\n    }\n  }\n}\n\nconst rotateTowardsRate = 0.5;\n", "import { BluetoothPuzzle } from \"./bluetooth-puzzle\";\nimport { debugLog } from \"./debug\";\nimport { ganConfig, GanCube } from \"./gan\";\nimport { giiKERConfig, GiiKERCube } from \"./giiker\";\nimport { GoCube, goCubeConfig } from \"./gocube\";\n\n/******** requestOptions ********/\n\nexport interface BluetoothConfig {\n  filters: BluetoothRequestDeviceFilter[];\n  optionalServices: BluetoothServiceUUID[];\n}\n\nfunction requestOptions(\n  acceptAllDevices: boolean = false,\n): RequestDeviceOptions {\n  const options = acceptAllDevices\n    ? {\n        acceptAllDevices: true,\n        optionalServices: [] as BluetoothServiceUUID[],\n      }\n    : {\n        filters: [] as BluetoothRequestDeviceFilter[],\n        optionalServices: [] as BluetoothServiceUUID[],\n      };\n  for (const config of [ganConfig, giiKERConfig, goCubeConfig]) {\n    if (!acceptAllDevices) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      options.filters = options.filters!.concat(config.filters);\n    }\n    options.optionalServices = options.optionalServices.concat(\n      config.optionalServices,\n    );\n  }\n  debugLog({ requestOptions: options });\n  return options;\n}\n\n/******** connect() ********/\n\ninterface BluetoothConnectOptions {\n  acceptAllDevices?: boolean;\n}\n\n// We globally track the number of connection failures,\n// in order to offer the user recourse (accept all devices) if they're having issues.\n// This allows us to future-proof situations where a device might not show up in\n// the chooser, but works if we connect.\nlet consecutiveFailures = 0;\nconst MAX_FAILURES_BEFORE_ACCEPT_ALL_FALLBACK = 2;\n\n// TODO: Debug options to allow connecting to any device?\nexport async function connect(\n  options: BluetoothConnectOptions = {},\n): Promise<BluetoothPuzzle> {\n  debugLog(\"Attempting to pair.\");\n  let device;\n  try {\n    let acceptAllDevices = options.acceptAllDevices;\n    if (\n      !acceptAllDevices &&\n      consecutiveFailures >= MAX_FAILURES_BEFORE_ACCEPT_ALL_FALLBACK\n    ) {\n      console.info(\n        `The last ${MAX_FAILURES_BEFORE_ACCEPT_ALL_FALLBACK} Bluetooth puzzle connection attempts failed. This time, the Bluetooth prompt will show all possible devices.`,\n      );\n      acceptAllDevices = true;\n    }\n    device = await navigator.bluetooth.requestDevice(\n      requestOptions(acceptAllDevices),\n    );\n    consecutiveFailures = 0;\n  } catch (e) {\n    consecutiveFailures++;\n    throw new Error(e);\n  }\n  debugLog(\"Device:\", device);\n\n  if (typeof device.gatt === \"undefined\") {\n    return Promise.reject(\"Device did not have a GATT server.\");\n  }\n\n  const server = await device.gatt.connect();\n  debugLog(\"Server:\", server);\n\n  const name = server.device?.name || \"\";\n\n  // TODO by reading supported matched filters or provided services.\n  if (name && name.startsWith(\"GAN\")) {\n    return await GanCube.connect(server);\n  } else if ((name && name.startsWith(\"GoCube\")) || name.startsWith(\"Rubik\")) {\n    return await GoCube.connect(server);\n  } else {\n    return await GiiKERCube.connect(server);\n  }\n}\n", "import { keyToMove } from \"../alg\";\nimport { KPuzzle, Puzzles } from \"../kpuzzle\";\nimport { BluetoothPuzzle, PuzzleState } from \"./bluetooth-puzzle\";\n\nconst def = Puzzles[\"3x3x3\"];\n\nexport class KeyboardPuzzle extends BluetoothPuzzle {\n  public puzzle: KPuzzle = new KPuzzle(def);\n  // TODO: Decide on the right arguments.\n  constructor(target: Element) {\n    super();\n    // TODO: Filter out repeated keydown?\n    target.addEventListener(\"keydown\", this.onKeyDown.bind(this));\n  }\n\n  public name(): string | undefined {\n    return \"Keyboard Input\";\n  }\n\n  public async getState(): Promise<PuzzleState> {\n    return this.puzzle.state;\n  }\n\n  private onKeyDown(e: KeyboardEvent): void {\n    if (e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) {\n      return;\n    }\n\n    const move = keyToMove(e);\n    if (move) {\n      this.puzzle.applyBlockMove(move);\n      this.dispatchMove({\n        latestMove: move,\n        timeStamp: e.timeStamp,\n        state: this.puzzle.state,\n      });\n      e.preventDefault();\n    }\n  }\n}\n\n// TODO: Type\nexport async function debugKeyboardConnect(\n  target: any = window,\n): Promise<KeyboardPuzzle> {\n  return new KeyboardPuzzle(target);\n}\n"],
  "mappings": "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",
  "names": []
}
