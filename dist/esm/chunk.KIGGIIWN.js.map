{
  "version": 3,
  "sources": ["../../src/alg/parser/parser-pegjs.js", "../../src/alg/debug.ts", "../../src/alg/algorithm/alg-part.ts", "../../src/alg/algorithm/block-move.ts", "../../src/alg/traversal.ts", "../../src/alg/example.ts", "../../src/alg/validation.ts", "../../src/alg/parser/parser.js", "../../src/alg/keyboard.ts"],
  "sourcesContent": ["// Generated by PEG.js v0.11.0-master.f69239d, https://pegjs.org/\n\n\"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function C() { this.constructor = child; }\n  C.prototype = parent.prototype;\n  child.prototype = new C();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message = message;\n  this.expected = expected;\n  this.found = found;\n  this.location = location;\n  this.name = \"SyntaxError\";\n\n  // istanbul ignore next\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function(expectation) {\n      return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n    },\n\n    class: function(expectation) {\n      var escapedParts = expectation.parts.map(function(part) {\n        return Array.isArray(part)\n          ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n          : classEscape(part);\n      });\n\n      return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n    },\n\n    any: function() {\n      return \"any character\";\n    },\n\n    end: function() {\n      return \"end of input\";\n    },\n\n    other: function(expectation) {\n      return expectation.description;\n    },\n\n    not: function(expectation) {\n      return \"not \" + describeExpectation(expectation.expected);\n    }\n  };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\"/g,  \"\\\\\\\"\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\\]/g, \"\\\\]\")\n      .replace(/\\^/g, \"\\\\^\")\n      .replace(/-/g,  \"\\\\-\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = expected.map(describeExpectation);\n    var i, j;\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== undefined ? options : {};\n\n  var peg$FAILED = {};\n\n  var peg$startRuleFunctions = { start: peg$parsestart };\n  var peg$startRuleFunction = peg$parsestart;\n\n  var peg$c0 = \"'\";\n  var peg$c1 = \"R++\";\n  var peg$c2 = \"R--\";\n  var peg$c3 = \"D++\";\n  var peg$c4 = \"D--\";\n  var peg$c5 = \"-\";\n  var peg$c6 = \"[\";\n  var peg$c7 = \"]\";\n  var peg$c8 = \"(\";\n  var peg$c9 = \")\";\n  var peg$c10 = \"//\";\n  var peg$c11 = \".\";\n\n  var peg$r0 = /^[0-9]/;\n  var peg$r1 = /^[_A-Za-z]/;\n  var peg$r2 = /^[,:]/;\n  var peg$r3 = /^[^\\n\\r]/;\n  var peg$r4 = /^[\\n\\r]/;\n  var peg$r5 = /^[ ]/;\n\n  var peg$e0 = peg$classExpectation([[\"0\", \"9\"]], false, false);\n  var peg$e1 = peg$literalExpectation(\"'\", false);\n  var peg$e2 = peg$literalExpectation(\"R++\", false);\n  var peg$e3 = peg$literalExpectation(\"R--\", false);\n  var peg$e4 = peg$literalExpectation(\"D++\", false);\n  var peg$e5 = peg$literalExpectation(\"D--\", false);\n  var peg$e6 = peg$classExpectation([\"_\", [\"A\", \"Z\"], [\"a\", \"z\"]], false, false);\n  var peg$e7 = peg$literalExpectation(\"-\", false);\n  var peg$e8 = peg$literalExpectation(\"[\", false);\n  var peg$e9 = peg$classExpectation([\",\", \":\"], false, false);\n  var peg$e10 = peg$literalExpectation(\"]\", false);\n  var peg$e11 = peg$literalExpectation(\"(\", false);\n  var peg$e12 = peg$literalExpectation(\")\", false);\n  var peg$e13 = peg$literalExpectation(\"//\", false);\n  var peg$e14 = peg$classExpectation([\"\\n\", \"\\r\"], true, false);\n  var peg$e15 = peg$classExpectation([\"\\n\", \"\\r\"], false, false);\n  var peg$e16 = peg$literalExpectation(\".\", false);\n  var peg$e17 = peg$classExpectation([\" \"], false, false);\n\n  var peg$f0 = function(characters) { return parseInt(characters.join(\"\"), 10); };\n  var peg$f1 = function(repetition) { return -repetition; };\n  var peg$f2 = function() { return -1; };\n  var peg$f3 = function(megaminx_scramble_move) { return megaminx_scramble_move };\n  var peg$f4 = function(characters) { return typeof(characters) === \"string\" ? characters : characters.join(\"\"); };\n  var peg$f5 = function(family) { return {type: \"blockMove\", family: family}; };\n  var peg$f6 = function(innerLayer, family) { return {type: \"blockMove\", family: family, innerLayer: innerLayer}; };\n  var peg$f7 = function(outerLayer, innerLayer, family) { return {type: \"blockMove\", family: family, outerLayer: outerLayer, innerLayer: innerLayer}; };\n  var peg$f8 = function(a, separator, b) { return {\"type\": separator === \",\" ? \"commutator\" : \"conjugate\", \"A\": a, \"B\": b}; };\n  var peg$f9 = function(nestedSequence) { return {\"type\": \"group\", \"nestedSequence\": nestedSequence}; };\n  var peg$f10 = function(repeatable_unit, amount) { repeatable_unit.amount = amount; return repeatable_unit; };\n  var peg$f11 = function(repeatable_unit) { repeatable_unit.amount = 1; return repeatable_unit; };\n  var peg$f12 = function(body) { return {type: \"comment\", comment: body.join(\"\")}; };\n  var peg$f13 = function() { return {\"type\": \"newLine\"}; };\n  var peg$f14 = function() { return {\"type\": \"pause\"}; };\n  var peg$f15 = function(segment_part, segment) { return [segment_part].concat(segment); };\n  var peg$f16 = function(segment_part) { return [segment_part]; };\n  var peg$f17 = function(segment, unit_list) { return segment.concat(unit_list); };\n  var peg$f18 = function(unit_list) { return {\"type\": \"sequence\", \"nestedUnits\": unit_list}; };\n  var peg$f19 = function() { return {\"type\": \"sequence\", \"nestedUnits\": []}; };\n\n  var peg$currPos = 0;\n  var peg$savedPos = 0;\n  var peg$posDetailsCache = [{ line: 1, column: 1 }];\n  var peg$expected = [];\n  var peg$silentFails = 0;\n\n  var peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$savedPos;\n  }\n\n  function range() {\n    return [peg$savedPos, peg$currPos];\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos];\n    var p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  var peg$VALIDFILENAME = typeof options.filename === \"string\" && options.filename.length > 0;\n  function peg$computeLocation(startPos, endPos) {\n    var loc = {};\n\n    if ( peg$VALIDFILENAME ) loc.filename = options.filename;\n\n    var startPosDetails = peg$computePosDetails(startPos);\n    loc.start = {\n      offset: startPos,\n      line: startPosDetails.line,\n      column: startPosDetails.column\n    };\n\n    var endPosDetails = peg$computePosDetails(endPos);\n    loc.end = {\n      offset: endPos,\n      line: endPosDetails.line,\n      column: endPosDetails.column\n    };\n\n    return loc;\n  }\n\n  function peg$begin() {\n    peg$expected.push({ pos: peg$currPos, variants: [] });\n  }\n\n  function peg$expect(expected) {\n    var top = peg$expected[peg$expected.length - 1];\n\n    if (peg$currPos < top.pos) { return; }\n\n    if (peg$currPos > top.pos) {\n      top.pos = peg$currPos;\n      top.variants = [];\n    }\n\n    top.variants.push(expected);\n  }\n\n  function peg$end(invert) {\n    var expected = peg$expected.pop();\n    var top = peg$expected[peg$expected.length - 1];\n    var variants = expected.variants;\n\n    if (top.pos !== expected.pos) { return; }\n\n    if (invert) {\n      variants = variants.map(function(e) {\n        return e.type === \"not\" ? e.expected : { type: \"not\", expected: e };\n      });\n    }\n\n    Array.prototype.push.apply(top.variants, variants);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$buildError() {\n    var expected = peg$expected[0];\n    var failPos = expected.pos;\n\n    return peg$buildStructuredError(\n      expected.variants,\n      failPos < input.length ? input.charAt(failPos) : null,\n      failPos < input.length\n        ? peg$computeLocation(failPos, failPos + 1)\n        : peg$computeLocation(failPos, failPos)\n    );\n  }\n\n  function peg$parsestart() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$parseSEQUENCE();\n\n    return s0;\n  }\n\n  function peg$parseNUMBER() {\n    var s0, s1, s2;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = [];\n    rule$expects(peg$e0);\n    if (peg$r0.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        rule$expects(peg$e0);\n        if (peg$r0.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f0(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseAMOUNT() {\n    var s0, s1, s2;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseNUMBER();\n    if (s1 !== peg$FAILED) {\n      rule$expects(peg$e1);\n      if (input.charCodeAt(peg$currPos) === 39) {\n        s2 = peg$c0;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f1(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseNUMBER();\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        rule$expects(peg$e1);\n        if (input.charCodeAt(peg$currPos) === 39) {\n          s1 = peg$c0;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f2();\n        }\n        s0 = s1;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseFAMILY() {\n    var s0, s1, s2;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e2);\n    if (input.substr(peg$currPos, 3) === peg$c1) {\n      s1 = peg$c1;\n      peg$currPos += 3;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      rule$expects(peg$e3);\n      if (input.substr(peg$currPos, 3) === peg$c2) {\n        s1 = peg$c2;\n        peg$currPos += 3;\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 === peg$FAILED) {\n        rule$expects(peg$e4);\n        if (input.substr(peg$currPos, 3) === peg$c3) {\n          s1 = peg$c3;\n          peg$currPos += 3;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 === peg$FAILED) {\n          rule$expects(peg$e5);\n          if (input.substr(peg$currPos, 3) === peg$c4) {\n            s1 = peg$c4;\n            peg$currPos += 3;\n          } else {\n            s1 = peg$FAILED;\n          }\n        }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f3(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = [];\n      rule$expects(peg$e6);\n      if (peg$r1.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          rule$expects(peg$e6);\n          if (peg$r1.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f4(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseBLOCK_MOVE() {\n    var s0, s1, s2, s3, s4;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseFAMILY();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f5(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseNUMBER();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseFAMILY();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f6(s1, s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseNUMBER();\n        if (s1 !== peg$FAILED) {\n          rule$expects(peg$e7);\n          if (input.charCodeAt(peg$currPos) === 45) {\n            s2 = peg$c5;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseNUMBER();\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parseFAMILY();\n              if (s4 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s0 = peg$f7(s1, s3, s4);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseREPEATABLE_UNIT() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$parseBLOCK_MOVE();\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      rule$expects(peg$e8);\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s1 = peg$c6;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseSEQUENCE();\n        if (s2 !== peg$FAILED) {\n          rule$expects(peg$e9);\n          if (peg$r2.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseSEQUENCE();\n            if (s4 !== peg$FAILED) {\n              rule$expects(peg$e10);\n              if (input.charCodeAt(peg$currPos) === 93) {\n                s5 = peg$c7;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s0 = peg$f8(s2, s3, s4);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        rule$expects(peg$e11);\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s1 = peg$c8;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseSEQUENCE();\n          if (s2 !== peg$FAILED) {\n            rule$expects(peg$e12);\n            if (input.charCodeAt(peg$currPos) === 41) {\n              s3 = peg$c9;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n            }\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f9(s2);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseREPEATED_UNIT() {\n    var s0, s1, s2;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseREPEATABLE_UNIT();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseAMOUNT();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f10(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseREPEATABLE_UNIT();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f11(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseCOMMENT() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e13);\n    if (input.substr(peg$currPos, 2) === peg$c10) {\n      s1 = peg$c10;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      rule$expects(peg$e14);\n      if (peg$r3.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        rule$expects(peg$e14);\n        if (peg$r3.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n        }\n      }\n      peg$savedPos = s0;\n      s0 = peg$f12(s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseANNOTATION() {\n    var s0, s1;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e15);\n    if (peg$r4.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f13();\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      rule$expects(peg$e16);\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s1 = peg$c11;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f14();\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseCOMMENT();\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseSEGMENT_PART() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$parseREPEATED_UNIT();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseANNOTATION();\n    }\n\n    return s0;\n  }\n\n  function peg$parseSEGMENT() {\n    var s0, s1, s2;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseSEGMENT_PART();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseSEGMENT();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f15(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseSEGMENT_PART();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f16(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseUNIT_LIST() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseSEGMENT();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      rule$expects(peg$e17);\n      if (peg$r5.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          rule$expects(peg$e17);\n          if (peg$r5.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n          }\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseUNIT_LIST();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f17(s1, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseSEGMENT();\n    }\n\n    return s0;\n  }\n\n  function peg$parseSEQUENCE() {\n    var s0, s1, s2, s3, s4;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = [];\n    rule$expects(peg$e17);\n    if (peg$r5.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n    }\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      rule$expects(peg$e17);\n      if (peg$r5.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n      }\n    }\n    s2 = peg$parseUNIT_LIST();\n    if (s2 !== peg$FAILED) {\n      s3 = [];\n      rule$expects(peg$e17);\n      if (peg$r5.test(input.charAt(peg$currPos))) {\n        s4 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n      }\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        rule$expects(peg$e17);\n        if (peg$r5.test(input.charAt(peg$currPos))) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n        }\n      }\n      peg$savedPos = s0;\n      s0 = peg$f18(s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = [];\n      rule$expects(peg$e17);\n      if (peg$r5.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n      }\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        rule$expects(peg$e17);\n        if (peg$r5.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n        }\n      }\n      peg$savedPos = s0;\n      s1 = peg$f19();\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  peg$begin();\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$expect(peg$endExpectation());\n    }\n\n    throw peg$buildError();\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse: peg$parse\n};\n", "type ReportingLevel = \"none\" | \"warn\" | \"error\";\nlet currentReportingLevel = \"warn\";\n\nconst MAX_NUMBER_OF_TIMES_TO_WARN = 10;\nlet numWarned = 0;\n\n// TODO: Avoid creating the string message if it won't be used (e.g. by taking a function?).\nexport function reportTypeMismatch(msg: string): void {\n  switch (currentReportingLevel) {\n    case \"error\":\n      throw new Error(msg);\n    case \"warn\":\n      numWarned++;\n      if (numWarned < MAX_NUMBER_OF_TIMES_TO_WARN) {\n        if (numWarned + 1 === MAX_NUMBER_OF_TIMES_TO_WARN) {\n          console.warn(msg);\n        }\n      }\n      return;\n  }\n}\n\nexport function setAlgPartTypeMismatchReportingLevel(\n  level: ReportingLevel,\n): void {\n  currentReportingLevel = level;\n}\n", "import { reportTypeMismatch } from \"../debug\";\n\nexport type AlgPartType = string;\n\nexport abstract class AlgPart {\n  public abstract type: AlgPartType;\n}\n\n// type Constructor<T> = Function & { prototype: T }\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function matchesAlgType(a: { type: any }, t: AlgPartType): boolean {\n  return a.type === t;\n}\n\nexport function assertMatchesType<T extends AlgPart>(\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  a: any,\n  t: AlgPartType,\n): T {\n  if (!matchesAlgType(a, t)) {\n    reportTypeMismatch(`Expected \"type\": \"${t}\", saw \"type\": \"${a.type}\".`);\n  }\n  return a;\n}\n\n// Assumes that every `AlgPart` is a `Unit` or a `Sequence`.\nexport function isUnit(a: AlgPart): boolean {\n  if (!(\"type\" in a)) {\n    return false;\n  }\n  return !matchesAlgType(a, \"sequence\");\n}\n\nexport function assertIsUnit(a: AlgPart): Unit {\n  if (!(\"type\" in a)) {\n    reportTypeMismatch(`Expected \"unit\", saw a value that was not an AlgPart.`);\n  }\n  if (matchesAlgType(a, \"sequence\")) {\n    reportTypeMismatch(`Expected unit, saw \"sequence\".`);\n  }\n  return a;\n}\n\nexport abstract class Unit extends AlgPart {}\n\nexport abstract class Move extends Unit {}\nexport abstract class Annotation extends Unit {}\nexport abstract class Container extends Unit {}\n\n// TODO: Reintroduce an Algorithm class, and allow a mutable sequence too?\nexport class Sequence extends AlgPart {\n  public type: string = \"sequence\";\n  constructor(public nestedUnits: Unit[]) {\n    super();\n    for (const n of nestedUnits) {\n      assertIsUnit(n);\n    }\n    Object.freeze(this.nestedUnits);\n    Object.freeze(this);\n  }\n}\n\nexport interface WithAmount {\n  // TODO: Allow `amount` to be `undefined`, to distinguish between R and R1?\n  amount: number;\n}\nexport class Group extends Container implements WithAmount {\n  public type: string = \"group\";\n  constructor(public nestedSequence: Sequence, public amount: number = 1) {\n    super();\n    Object.freeze(this);\n  }\n}\nexport class Commutator extends Container implements WithAmount {\n  public type: string = \"commutator\";\n  constructor(\n    public A: Sequence,\n    public B: Sequence,\n    public amount: number = 1,\n  ) {\n    super();\n    Object.freeze(this);\n  }\n}\nexport class Conjugate extends Container implements WithAmount {\n  public type: string = \"conjugate\";\n  constructor(\n    public A: Sequence,\n    public B: Sequence,\n    public amount: number = 1,\n  ) {\n    super();\n    Object.freeze(this);\n  }\n}\nexport class Pause extends Move {\n  public type: string = \"pause\";\n  constructor() {\n    super();\n    Object.freeze(this);\n  }\n}\nexport class NewLine extends Annotation {\n  public type: string = \"newLine\";\n  constructor() {\n    super();\n    Object.freeze(this);\n  }\n}\n\n// TODO: must be followed by a newline, unless at the end of an alg?\nexport class Comment extends Annotation {\n  public type: string = \"comment\";\n  constructor(public comment: string) {\n    super();\n    Object.freeze(this);\n  }\n}\n\n// TODO\n// export class TimeStamp extends AlgPart implements AlgPart\n", "import { Move } from \"./alg-part\";\n\nexport type MoveFamily = string; // TODO: Convert to an enum with string mappings.\n\n// TODO: Rename to `LetterMove`?\nexport class BlockMove extends Move {\n  public type: string = \"blockMove\";\n\n  // If `outerLayer` is set, `innerLayer` must also be set.\n  public outerLayer?: number;\n  public innerLayer?: number;\n  constructor(\n    outerLayer: number | undefined,\n    innerLayer: number | undefined,\n    public family: MoveFamily,\n    public amount: number = 1,\n  ) {\n    super();\n    if (innerLayer) {\n      this.innerLayer = innerLayer;\n      if (outerLayer) {\n        this.outerLayer = outerLayer;\n      }\n    }\n    if (outerLayer && !innerLayer) {\n      throw new Error(\n        \"Attempted to contruct block move with outer layer but no inner layer\",\n      );\n    }\n    Object.freeze(this);\n  }\n}\n\nexport function BareBlockMove(family: MoveFamily, amount?: number): BlockMove {\n  return new BlockMove(undefined, undefined, family, amount);\n}\n\nexport function LayerBlockMove(\n  innerLayer: number,\n  family: MoveFamily,\n  amount?: number,\n): BlockMove {\n  return new BlockMove(undefined, innerLayer, family, amount);\n}\n\nexport function RangeBlockMove(\n  outerLayer: number,\n  innerLayer: number,\n  family: MoveFamily,\n  amount?: number,\n): BlockMove {\n  return new BlockMove(outerLayer, innerLayer, family, amount);\n}\n", "import {\n  assertIsUnit,\n  assertMatchesType,\n  isUnit,\n  matchesAlgType,\n} from \"./algorithm/alg-part\";\n\nimport {\n  AlgPart,\n  BlockMove,\n  Comment,\n  Commutator,\n  Conjugate,\n  Group,\n  NewLine,\n  Pause,\n  Sequence,\n  Unit,\n  WithAmount,\n} from \"./algorithm\";\n\nfunction dispatch<DataDown, DataUp>(\n  t: TraversalDownUp<DataDown, DataUp>,\n  algPart: AlgPart,\n  dataDown: DataDown,\n): DataUp {\n  switch (algPart.type) {\n    case \"sequence\":\n      assertMatchesType(algPart, \"sequence\");\n      return t.traverseSequence(algPart as Sequence, dataDown);\n    case \"group\":\n      assertMatchesType(algPart, \"group\");\n      return t.traverseGroup(algPart as Group, dataDown);\n    case \"blockMove\":\n      assertMatchesType(algPart, \"blockMove\");\n      return t.traverseBlockMove(algPart as BlockMove, dataDown);\n    case \"commutator\":\n      assertMatchesType(algPart, \"commutator\");\n      return t.traverseCommutator(algPart as Commutator, dataDown);\n    case \"conjugate\":\n      assertMatchesType(algPart, \"conjugate\");\n      return t.traverseConjugate(algPart as Conjugate, dataDown);\n    case \"pause\":\n      assertMatchesType(algPart, \"pause\");\n      return t.traversePause(algPart as Pause, dataDown);\n    case \"newLine\":\n      assertMatchesType(algPart, \"newLine\");\n      return t.traverseNewLine(algPart as NewLine, dataDown);\n    case \"comment\":\n      assertMatchesType(algPart, \"comment\");\n      return t.traverseComment(algPart as Comment, dataDown);\n    default:\n      throw new Error(`Unknown AlgPart type: ${algPart.type}`);\n  }\n}\n\nexport abstract class TraversalDownUp<DataDown, DataUp> {\n  // Immediate subclasses should overwrite this.\n  public traverse(algPart: AlgPart, dataDown: DataDown): DataUp {\n    return dispatch(this, algPart, dataDown);\n  }\n\n  public traverseIntoUnit(algPart: AlgPart, dataDown: DataDown): Unit {\n    return assertIsUnit(this.traverse(algPart, dataDown) as any);\n  }\n\n  public abstract traverseSequence(\n    sequence: Sequence,\n    dataDown: DataDown,\n  ): DataUp;\n\n  public abstract traverseGroup(group: Group, dataDown: DataDown): DataUp;\n  public abstract traverseBlockMove(\n    blockMove: BlockMove,\n    dataDown: DataDown,\n  ): DataUp;\n\n  public abstract traverseCommutator(\n    commutator: Commutator,\n    dataDown: DataDown,\n  ): DataUp;\n\n  public abstract traverseConjugate(\n    conjugate: Conjugate,\n    dataDown: DataDown,\n  ): DataUp;\n\n  public abstract traversePause(pause: Pause, dataDown: DataDown): DataUp;\n  public abstract traverseNewLine(newLine: NewLine, dataDown: DataDown): DataUp;\n  public abstract traverseComment(comment: Comment, dataDown: DataDown): DataUp;\n}\n\nexport abstract class TraversalUp<DataUp> extends TraversalDownUp<\n  undefined,\n  DataUp\n> {\n  public traverse(algPart: AlgPart): DataUp {\n    return dispatch<undefined, DataUp>(this, algPart, undefined);\n  }\n\n  public traverseIntoUnit(algPart: AlgPart): Unit {\n    return assertIsUnit(this.traverse(algPart) as any);\n  }\n\n  public abstract traverseSequence(sequence: Sequence): DataUp;\n  public abstract traverseGroup(group: Group): DataUp;\n  public abstract traverseBlockMove(blockMove: BlockMove): DataUp;\n  public abstract traverseCommutator(commutator: Commutator): DataUp;\n  public abstract traverseConjugate(conjugate: Conjugate): DataUp;\n  public abstract traversePause(pause: Pause): DataUp;\n  public abstract traverseNewLine(newLine: NewLine): DataUp;\n  public abstract traverseComment(comment: Comment): DataUp;\n}\n\n// TODO: Test that inverses are bijections.\nexport class Invert extends TraversalUp<AlgPart> {\n  public traverseSequence(sequence: Sequence): Sequence {\n    // TODO: Handle newLines and comments correctly\n    return new Sequence(\n      sequence.nestedUnits.map((a) => this.traverseIntoUnit(a)).reverse(),\n    );\n  }\n\n  public traverseGroup(group: Group): AlgPart {\n    return new Group(this.traverseSequence(group.nestedSequence), group.amount);\n  }\n\n  public traverseBlockMove(blockMove: BlockMove): AlgPart {\n    return new BlockMove(\n      blockMove.outerLayer,\n      blockMove.innerLayer,\n      blockMove.family,\n      -blockMove.amount,\n    );\n  }\n\n  public traverseCommutator(commutator: Commutator): AlgPart {\n    return new Commutator(commutator.B, commutator.A, commutator.amount);\n  }\n\n  public traverseConjugate(conjugate: Conjugate): AlgPart {\n    return new Conjugate(\n      conjugate.A,\n      this.traverseSequence(conjugate.B),\n      conjugate.amount,\n    );\n  }\n\n  public traversePause(pause: Pause): AlgPart {\n    return pause;\n  }\n\n  public traverseNewLine(newLine: NewLine): AlgPart {\n    return newLine;\n  }\n\n  public traverseComment(comment: Comment): AlgPart {\n    return comment;\n  }\n}\n\nexport class Expand extends TraversalUp<AlgPart> {\n  public traverseSequence(sequence: Sequence): Sequence {\n    return new Sequence(\n      this.flattenSequenceOneLevel(\n        sequence.nestedUnits.map((a) => this.traverse(a)),\n      ),\n    );\n  }\n\n  public traverseGroup(group: Group): AlgPart {\n    // TODO: Pass raw AlgPart[] to sequence.\n    return this.repeat(\n      this.flattenSequenceOneLevel([this.traverse(group.nestedSequence)]),\n      group,\n    );\n  }\n\n  public traverseBlockMove(blockMove: BlockMove): AlgPart {\n    return blockMove;\n  }\n\n  public traverseCommutator(commutator: Commutator): AlgPart {\n    const expandedA = this.traverseSequence(commutator.A);\n    const expandedB = this.traverseSequence(commutator.B);\n    let once: AlgPart[] = [];\n    once = once.concat(\n      expandedA,\n      expandedB,\n      invert(expandedA),\n      invert(expandedB),\n    );\n    return this.repeat(this.flattenSequenceOneLevel(once), commutator);\n  }\n\n  public traverseConjugate(conjugate: Conjugate): AlgPart {\n    const expandedA = this.traverseSequence(conjugate.A);\n    const expandedB = this.traverseSequence(conjugate.B);\n    let once: AlgPart[] = [];\n    once = once.concat(expandedA, expandedB, invert(expandedA));\n    return this.repeat(this.flattenSequenceOneLevel(once), conjugate);\n  }\n\n  public traversePause(pause: Pause): AlgPart {\n    return pause;\n  }\n\n  public traverseNewLine(newLine: NewLine): AlgPart {\n    return newLine;\n  }\n\n  public traverseComment(comment: Comment): AlgPart {\n    return comment;\n  }\n\n  private flattenSequenceOneLevel(algList: AlgPart[]): Unit[] {\n    let flattened: Unit[] = [];\n    for (const part of algList) {\n      if (matchesAlgType(part, \"sequence\")) {\n        flattened = flattened.concat((part as Sequence).nestedUnits);\n      } else if (isUnit(part)) {\n        flattened.push(part);\n      } else {\n        throw new Error(\n          \"expand() encountered an internal error. Did you pass in a valid Algorithm?\",\n        );\n      }\n    }\n    return flattened;\n  }\n\n  private repeat(algList: Unit[], accordingTo: WithAmount): Sequence {\n    const amount = Math.abs(accordingTo.amount);\n    const amountDir = accordingTo.amount > 0 ? 1 : -1; // Mutable\n\n    // TODO: Cleaner inversion\n    let once: Unit[];\n    if (amountDir === -1) {\n      // TODO: Avoid casting to sequence.\n      once = (invert(new Sequence(algList)) as Sequence).nestedUnits;\n    } else {\n      once = algList;\n    }\n\n    let repeated: Unit[] = [];\n    for (let i = 0; i < amount; i++) {\n      repeated = repeated.concat(once);\n    }\n\n    return new Sequence(repeated);\n  }\n}\n\nexport class StructureEquals extends TraversalDownUp<AlgPart, boolean> {\n  public traverseSequence(sequence: Sequence, dataDown: AlgPart): boolean {\n    if (isUnit(dataDown)) {\n      return false;\n    }\n    const dataDownSeq = dataDown as Sequence;\n    if (sequence.nestedUnits.length !== dataDownSeq.nestedUnits.length) {\n      return false;\n    }\n    for (let i = 0; i < sequence.nestedUnits.length; i++) {\n      if (!this.traverse(sequence.nestedUnits[i], dataDownSeq.nestedUnits[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  public traverseGroup(group: Group, dataDown: AlgPart): boolean {\n    return (\n      matchesAlgType(dataDown, \"group\") &&\n      this.traverse(group.nestedSequence, (dataDown as Group).nestedSequence)\n    );\n  }\n\n  public traverseBlockMove(blockMove: BlockMove, dataDown: AlgPart): boolean {\n    // TODO: Handle layers.\n    return (\n      matchesAlgType(dataDown, \"blockMove\") &&\n      blockMove.outerLayer === (dataDown as BlockMove).outerLayer &&\n      blockMove.innerLayer === (dataDown as BlockMove).innerLayer &&\n      blockMove.family === (dataDown as BlockMove).family &&\n      blockMove.amount === (dataDown as BlockMove).amount\n    );\n  }\n\n  public traverseCommutator(\n    commutator: Commutator,\n    dataDown: AlgPart,\n  ): boolean {\n    return (\n      matchesAlgType(dataDown, \"commutator\") &&\n      this.traverse(commutator.A, (dataDown as Commutator).A) &&\n      this.traverse(commutator.B, (dataDown as Commutator).B)\n    );\n  }\n\n  public traverseConjugate(conjugate: Conjugate, dataDown: AlgPart): boolean {\n    return (\n      matchesAlgType(dataDown, \"conjugate\") &&\n      this.traverse(conjugate.A, (dataDown as Conjugate).A) &&\n      this.traverse(conjugate.B, (dataDown as Conjugate).B)\n    );\n  }\n\n  public traversePause(_pause: Pause, dataDown: AlgPart): boolean {\n    return matchesAlgType(dataDown, \"pause\");\n  }\n\n  public traverseNewLine(_newLine: NewLine, dataDown: AlgPart): boolean {\n    return matchesAlgType(dataDown, \"newLine\");\n  }\n\n  public traverseComment(comment: Comment, dataDown: AlgPart): boolean {\n    return (\n      matchesAlgType(dataDown, \"comment\") &&\n      comment.comment === (dataDown as Comment).comment\n    );\n  }\n}\n\n// TODO: Test that inverses are bijections.\nexport class CoalesceBaseMoves extends TraversalUp<AlgPart> {\n  // TODO: Handle\n  public traverseSequence(sequence: Sequence): Sequence {\n    const coalesced: Unit[] = [];\n    for (const part of sequence.nestedUnits) {\n      if (!matchesAlgType(part, \"blockMove\")) {\n        coalesced.push(this.traverseIntoUnit(part));\n      } else if (coalesced.length > 0) {\n        const last = coalesced[coalesced.length - 1];\n        if (\n          matchesAlgType(last, \"blockMove\") &&\n          this.sameBlock(last as BlockMove, part as BlockMove)\n        ) {\n          // TODO: This is cube-specific. Perhaps pass the modules as DataDown?\n          const amount =\n            (last as BlockMove).amount + (part as BlockMove).amount;\n          coalesced.pop();\n          if (amount !== 0) {\n            // We could modify the last element instead of creating a new one,\n            // but this is safe against shifting coding practices.\n            // TODO: Figure out if the shoot-in-the-foot risk\n            // modification is worth the speed.\n            coalesced.push(\n              new BlockMove(\n                (part as BlockMove).outerLayer,\n                (part as BlockMove).innerLayer,\n                (part as BlockMove).family,\n                amount,\n              ),\n            );\n          }\n        } else {\n          coalesced.push(part);\n        }\n      } else {\n        coalesced.push(part);\n      }\n    }\n    return new Sequence(coalesced);\n  }\n\n  public traverseGroup(group: Group): AlgPart {\n    return group;\n  }\n\n  public traverseBlockMove(blockMove: BlockMove): AlgPart {\n    return blockMove;\n  }\n\n  public traverseCommutator(commutator: Commutator): AlgPart {\n    return commutator;\n  }\n\n  public traverseConjugate(conjugate: Conjugate): AlgPart {\n    return conjugate;\n  }\n\n  public traversePause(pause: Pause): AlgPart {\n    return pause;\n  }\n\n  public traverseNewLine(newLine: NewLine): AlgPart {\n    return newLine;\n  }\n\n  public traverseComment(comment: Comment): AlgPart {\n    return comment;\n  }\n\n  private sameBlock(moveA: BlockMove, moveB: BlockMove): boolean {\n    // TODO: Handle layers\n    return (\n      moveA.outerLayer === moveB.outerLayer &&\n      moveA.innerLayer === moveB.innerLayer &&\n      moveA.family === moveB.family\n    );\n  }\n}\n\n// export class Concat extends TraversalDownUp<Algorithm, Sequence> {\n//   private concatIntoSequence(A: Unit[], B: Algorithm): Sequence {\n//     var nestedAlgs: Unit[] = A.slice();\n//     if (matchesAlgType(B, \"sequence\")) {\n//       nestedAlgs = nestedAlgs.concat((B as unknown as Sequence).nestedUnits)\n//     } else {\n//       nestedAlgs.push(B as unknown as Unit);\n//     }\n//     return new Sequence(nestedAlgs)\n//   }\n//   public traverseSequence(     sequence:     Sequence,     dataDown: Algorithm): Sequence {return this.concatIntoSequence(sequence.nestedUnits, dataDown); }\n//   public traverseGroup(        group:        Group,        dataDown: Algorithm): Sequence {return this.concatIntoSequence([group]          , dataDown); }\n//   public traverseBlockMove(    BlockMove:    BlockMove,    dataDown: Algorithm): Sequence {return this.concatIntoSequence([BlockMove]      , dataDown); }\n//   public traverseCommutator(   commutator:   Commutator,   dataDown: Algorithm): Sequence {return this.concatIntoSequence([commutator]     , dataDown); }\n//   public traverseConjugate(    conjugate:    Conjugate,    dataDown: Algorithm): Sequence {return this.concatIntoSequence([conjugate]      , dataDown); }\n//   public traversePause(        pause:        Pause,        dataDown: Algorithm): Sequence {return this.concatIntoSequence([pause]          , dataDown); }\n//   public traverseNewLine(      newLine:      NewLine,      dataDown: Algorithm): Sequence {return this.concatIntoSequence([newLine]        , dataDown); }\n//   public traverseComment( comment: Comment, dataDown: Algorithm): Sequence {return this.concatIntoSequence([comment]   , dataDown); }\n// }\n\nfunction repetitionSuffix(amount: number): string {\n  const absAmount = Math.abs(amount);\n  let s = \"\";\n  if (absAmount !== 1) {\n    s += String(absAmount);\n  }\n  if (absAmount !== amount) {\n    s += \"'\";\n  }\n  return s;\n}\nexport function blockMoveToString(blockMove: BlockMove): string {\n  let out = blockMove.family + repetitionSuffix(blockMove.amount);\n  if (typeof blockMove.innerLayer !== \"undefined\") {\n    out = String(blockMove.innerLayer) + out;\n    if (typeof blockMove.outerLayer !== \"undefined\") {\n      out = String(blockMove.outerLayer) + \"-\" + out;\n    }\n  }\n  return out;\n}\n\nexport class ToString extends TraversalUp<string> {\n  public traverseSequence(sequence: Sequence): string {\n    let output = \"\";\n    if (sequence.nestedUnits.length > 0) {\n      output += this.traverse(sequence.nestedUnits[0]);\n      for (let i = 1; i < sequence.nestedUnits.length; i++) {\n        output += this.spaceBetween(\n          sequence.nestedUnits[i - 1],\n          sequence.nestedUnits[i],\n        );\n        output += this.traverse(sequence.nestedUnits[i]);\n      }\n    }\n    return output;\n  }\n\n  public traverseGroup(group: Group): string {\n    return (\n      \"(\" +\n      this.traverse(group.nestedSequence) +\n      \")\" +\n      repetitionSuffix(group.amount)\n    );\n  }\n\n  public traverseBlockMove(blockMove: BlockMove): string {\n    return blockMoveToString(blockMove);\n  }\n\n  public traverseCommutator(commutator: Commutator): string {\n    return (\n      \"[\" +\n      this.traverse(commutator.A) +\n      \", \" +\n      this.traverse(commutator.B) +\n      \"]\" +\n      repetitionSuffix(commutator.amount)\n    );\n  }\n\n  public traverseConjugate(conjugate: Conjugate): string {\n    return (\n      \"[\" +\n      this.traverse(conjugate.A) +\n      \": \" +\n      this.traverse(conjugate.B) +\n      \"]\" +\n      repetitionSuffix(conjugate.amount)\n    );\n  }\n\n  // TODO: Remove spaces between repeated pauses (in traverseSequence)\n  public traversePause(_pause: Pause): string {\n    return \".\";\n  }\n\n  public traverseNewLine(_newLine: NewLine): string {\n    return \"\\n\";\n  }\n\n  // TODO: Enforce being followed by a newline (or the end of the alg)?\n  public traverseComment(comment: Comment): string {\n    return \"//\" + comment.comment;\n  }\n\n  // TODO: Sanitize `*/`\n  private spaceBetween(u1: Unit, u2: Unit): string {\n    if (matchesAlgType(u1, \"pause\") && matchesAlgType(u2, \"pause\")) {\n      return \"\";\n    }\n    if (matchesAlgType(u1, \"newLine\") || matchesAlgType(u2, \"newLine\")) {\n      return \"\";\n    }\n    if (matchesAlgType(u1, \"comment\") && !matchesAlgType(u2, \"newLine\")) {\n      return \"\\n\";\n    }\n    return \" \";\n  }\n}\n\nconst invertInstance = new Invert();\nconst expandInstance = new Expand();\nconst structureEqualsInstance = new StructureEquals();\nconst coalesceBaseMovesInstance = new CoalesceBaseMoves();\nconst algToStringInstance = new ToString();\n\nexport const invert = invertInstance.traverseSequence.bind(invertInstance) as (\n  a: Sequence,\n) => Sequence;\nexport const expand = expandInstance.traverseSequence.bind(expandInstance) as (\n  a: Sequence,\n) => Sequence;\nexport const structureEquals = structureEqualsInstance.traverseSequence.bind(\n  structureEqualsInstance,\n) as (a1: Sequence, a2: Sequence) => boolean;\nexport const coalesceBaseMoves = coalesceBaseMovesInstance.traverseSequence.bind(\n  coalesceBaseMovesInstance,\n) as (a: Sequence) => Sequence;\nexport const algToString = algToStringInstance.traverseSequence.bind(\n  algToStringInstance,\n) as (a: Sequence) => string;\n\nexport const algPartStructureEqualsForTesting = algToStringInstance.traverse.bind(\n  algToStringInstance,\n) as (a1: AlgPart, a2: AlgPart) => boolean;\nexport const algPartToStringForTesting = algToStringInstance.traverse.bind(\n  algToStringInstance,\n) as (a: AlgPart) => string;\n\nexport function experimentalBlockMoveQuantumName(move: BlockMove): string {\n  return algPartToStringForTesting(\n    new BlockMove(move.outerLayer, move.innerLayer, move.family, 1),\n  );\n}\n", "import {\n  BareBlockMove,\n  Comment,\n  Commutator,\n  Conjugate,\n  Group,\n  NewLine,\n  Pause,\n  Sequence,\n} from \"./algorithm\";\n\n// tslint:disable-next-line no-namespace // TODO: nested module\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport const Example = {\n  Sune: new Sequence([\n    BareBlockMove(\"R\", 1),\n    BareBlockMove(\"U\", 1),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"U\", 1),\n    BareBlockMove(\"R\", 1),\n    BareBlockMove(\"U\", -2),\n    BareBlockMove(\"R\", -1),\n  ]),\n\n  AntiSune: new Sequence([\n    BareBlockMove(\"R\", 1),\n    BareBlockMove(\"U\", 2),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"U\", -1),\n    BareBlockMove(\"R\", 1),\n    BareBlockMove(\"U\", -1),\n    BareBlockMove(\"R\", -1),\n  ]),\n\n  SuneCommutator: new Sequence([\n    new Commutator(\n      new Sequence([\n        BareBlockMove(\"R\", 1),\n        BareBlockMove(\"U\", 1),\n        BareBlockMove(\"R\", -2),\n      ]),\n      new Sequence([\n        new Conjugate(\n          new Sequence([BareBlockMove(\"R\", 1)]),\n          new Sequence([BareBlockMove(\"U\", 1)]),\n          1,\n        ),\n      ]),\n      1,\n    ),\n  ]),\n\n  Niklas: new Sequence([\n    BareBlockMove(\"R\", 1),\n    BareBlockMove(\"U\", -1),\n    BareBlockMove(\"L\", -1),\n    BareBlockMove(\"U\", 1),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"U\", -1),\n    BareBlockMove(\"L\", 1),\n    BareBlockMove(\"U\", 1),\n  ]),\n\n  EPerm: new Sequence([\n    BareBlockMove(\"x\", -1),\n    new Commutator(\n      new Sequence([\n        new Conjugate(\n          new Sequence([BareBlockMove(\"R\", 1)]),\n          new Sequence([BareBlockMove(\"U\", -1)]),\n        ),\n      ]),\n      new Sequence([BareBlockMove(\"D\", 1)]),\n      1,\n    ),\n    new Commutator(\n      new Sequence([\n        new Conjugate(\n          new Sequence([BareBlockMove(\"R\", 1)]),\n          new Sequence([BareBlockMove(\"U\", 1)]),\n        ),\n      ]),\n      new Sequence([BareBlockMove(\"D\", 1)]),\n      1,\n    ),\n    BareBlockMove(\"x\", 1),\n  ]),\n\n  FURURFCompact: new Sequence([\n    new Conjugate(\n      new Sequence([BareBlockMove(\"F\", 1)]),\n      new Sequence([\n        new Commutator(\n          new Sequence([BareBlockMove(\"U\", 1)]),\n          new Sequence([BareBlockMove(\"R\", 1)]),\n          1,\n        ),\n      ]),\n      1,\n    ),\n  ]),\n\n  APermCompact: new Sequence([\n    new Conjugate(\n      new Sequence([BareBlockMove(\"R\", 2)]),\n      new Sequence([\n        new Commutator(\n          new Sequence([BareBlockMove(\"F\", 2)]),\n          new Sequence([\n            BareBlockMove(\"R\", -1),\n            BareBlockMove(\"B\", -1),\n            BareBlockMove(\"R\", 1),\n          ]),\n          1,\n        ),\n      ]),\n      1,\n    ),\n  ]),\n\n  FURURFMoves: new Sequence([\n    BareBlockMove(\"F\", 1),\n    BareBlockMove(\"U\", 1),\n    BareBlockMove(\"R\", 1),\n    BareBlockMove(\"U\", -1),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"F\", -1),\n  ]),\n\n  TPerm: new Sequence([\n    BareBlockMove(\"R\", 1),\n    BareBlockMove(\"U\", 1),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"U\", -1),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"F\", 1),\n    BareBlockMove(\"R\", 2),\n    BareBlockMove(\"U\", -1),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"U\", -1),\n    BareBlockMove(\"R\", 1),\n    BareBlockMove(\"U\", 1),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"F\", -1),\n  ]),\n\n  HeadlightSwaps: new Sequence([\n    new Conjugate(\n      new Sequence([BareBlockMove(\"F\", 1)]),\n      new Sequence([\n        new Commutator(\n          new Sequence([BareBlockMove(\"R\", 1)]),\n          new Sequence([BareBlockMove(\"U\", 1)]),\n          3,\n        ),\n      ]),\n      1,\n    ),\n  ]),\n\n  TriplePause: new Sequence([new Pause(), new Pause(), new Pause()]),\n\n  AllAlgParts: [\n    new Sequence([BareBlockMove(\"R\", 1), BareBlockMove(\"U\", -1)]),\n    new Group(new Sequence([BareBlockMove(\"F\", 1)]), 2),\n    // new Rotation(\"y\", -1),\n    BareBlockMove(\"R\", 2),\n    new Commutator(\n      new Sequence([BareBlockMove(\"R\", 2)]),\n      new Sequence([BareBlockMove(\"U\", 2)]),\n      2,\n    ),\n    new Conjugate(\n      new Sequence([BareBlockMove(\"L\", 2)]),\n      new Sequence([BareBlockMove(\"D\", -1)]),\n      2,\n    ),\n    new Pause(),\n    new NewLine(),\n    new Comment(\"short comment\"),\n  ],\n};\n", "import {\n  BlockMove,\n  Comment,\n  Commutator,\n  Conjugate,\n  Group,\n  NewLine,\n  Pause,\n  Sequence,\n} from \"./algorithm\";\n\nimport { TraversalUp } from \"./traversal\";\n\nexport class ValidationError extends Error {}\n\nexport abstract class ValidatorTraversal extends TraversalUp<void> {}\n\ninterface FamilyList {\n  [s: string]: boolean;\n}\n\nfunction validateFamily(\n  family: string,\n  allowedFamilyLists: FamilyList[],\n): boolean {\n  for (const list of allowedFamilyLists) {\n    if (list[family] === true) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// TODO: Switch to `Set`?\nconst plainMoveFamilies: FamilyList = {\n  x: true,\n  y: true,\n  z: true,\n  M: true,\n  E: true,\n  S: true,\n  m: true,\n  e: true,\n  s: true,\n};\n\nconst singleSliceMoveFamilies: FamilyList = {\n  U: true,\n  L: true,\n  F: true,\n  R: true,\n  B: true,\n  D: true,\n};\n\nconst wideMoveFamilies: FamilyList = {\n  u: true,\n  l: true,\n  f: true,\n  r: true,\n  b: true,\n  d: true,\n  Uw: true,\n  Lw: true,\n  Fw: true,\n  Rw: true,\n  Bw: true,\n  Dw: true,\n};\n\nabstract class BaseMoveValidator extends ValidatorTraversal {\n  public traverseSequence(sequence: Sequence): void {\n    // TODO: Handle newLines and comments correctly\n    for (const unit of sequence.nestedUnits) {\n      this.traverse(unit);\n    }\n  }\n\n  public traverseGroup(group: Group): void {\n    return this.traverse(group.nestedSequence);\n  }\n\n  public traverseCommutator(commutator: Commutator): void {\n    this.traverse(commutator.A);\n    this.traverse(commutator.B);\n  }\n\n  public traverseConjugate(conjugate: Conjugate): void {\n    this.traverse(conjugate.A);\n    this.traverse(conjugate.B);\n  }\n\n  public traversePause(_pause: Pause): void {\n    return;\n  }\n\n  public traverseNewLine(_newLine: NewLine): void {\n    return;\n  }\n\n  public traverseComment(_comment: Comment): void {\n    return;\n  }\n}\n\n// TODO: Export function instead?\nexport class BlockMoveValidator extends BaseMoveValidator {\n  public traverseBlockMove(blockMove: BlockMove): void {\n    if (typeof blockMove.outerLayer !== \"undefined\") {\n      if (typeof blockMove.innerLayer === \"undefined\") {\n        throw new ValidationError(\n          \"A BlockMove with an outer layer must have an inner layer.\",\n        );\n      }\n      if (!validateFamily(blockMove.family, [wideMoveFamilies])) {\n        throw new ValidationError(\n          `The provided SiGN move family is invalid, or cannot have an outer and inner layer: ${blockMove.family}`,\n        );\n      }\n      if (blockMove.outerLayer <= 0) {\n        throw new ValidationError(\"Cannot have an outer layer of 0 or less.\");\n      }\n      // TODO: Allow 2-2r?\n      if (blockMove.outerLayer >= blockMove.innerLayer) {\n        throw new ValidationError(\n          \"The outer layer must be less than the inner layer.\",\n        );\n      }\n      return;\n    } else if (typeof blockMove.innerLayer !== \"undefined\") {\n      if (\n        !validateFamily(blockMove.family, [\n          wideMoveFamilies,\n          singleSliceMoveFamilies,\n        ])\n      ) {\n        throw new ValidationError(\n          `The provided SiGN move family is invalid, or cannot have an inner slice: ${blockMove.family}`,\n        );\n      }\n      if (blockMove.innerLayer <= 0) {\n        throw new ValidationError(\"Cannot have an inner layer of 0 or less.\");\n      }\n      return;\n    } else {\n      if (\n        !validateFamily(blockMove.family, [\n          wideMoveFamilies,\n          singleSliceMoveFamilies,\n          plainMoveFamilies,\n        ])\n      ) {\n        throw new ValidationError(\n          `Invalid SiGN plain move family: ${blockMove.family}`,\n        );\n      }\n      return;\n    }\n  }\n}\n\n// TODO: Export function instead?\nexport class FlatAlgValidator extends ValidatorTraversal {\n  public traverseSequence(sequence: Sequence): void {\n    // TODO: Handle newLines and comments correctly\n    for (const unit of sequence.nestedUnits) {\n      this.traverse(unit);\n    }\n    return;\n  }\n\n  public traverseGroup(_group: Group): void {\n    throw new ValidationError(\"A flat alg cannot contain a group.\");\n  }\n\n  public traverseBlockMove(_blockMove: BlockMove): void {\n    return;\n  }\n\n  public traverseCommutator(_commutator: Commutator): void {\n    throw new ValidationError(\"A flat alg cannot contain a commutator.\");\n  }\n\n  public traverseConjugate(_conjugate: Conjugate): void {\n    throw new ValidationError(\"A flat alg cannot contain a conjugate.\");\n  }\n\n  public traversePause(_pause: Pause): void {\n    return;\n  }\n\n  public traverseNewLine(_newLine: NewLine): void {\n    return;\n  }\n\n  public traverseComment(_comment: Comment): void {\n    return;\n  }\n}\n\nexport type Validator = (a: Sequence) => void;\n\nconst BlockMoveValidatorInstance = new BlockMoveValidator();\nexport const validateSiGNMoves = BlockMoveValidatorInstance.traverse.bind(\n  BlockMoveValidatorInstance,\n) as Validator;\n\nconst flatAlgValidatorInstance = new FlatAlgValidator();\nexport const validateFlatAlg = flatAlgValidatorInstance.traverse.bind(\n  flatAlgValidatorInstance,\n) as Validator;\n\n// TODO: Option for puzzle size?\nexport function validateSiGNAlg(a: Sequence): void {\n  validateSiGNMoves(a);\n  validateFlatAlg(a);\n}\n", "// Workaround per https://github.com/pegjs/pegjs/pull/481\nexport { parse } from \"./parser-pegjs\";\n", "import { BareBlockMove, BlockMove } from \"./algorithm\";\n\nconst cubeKeyMapping: { [key: number]: BlockMove } = {\n  73: BareBlockMove(\"R\"),\n  75: BareBlockMove(\"R\", -1),\n  87: BareBlockMove(\"B\"),\n  79: BareBlockMove(\"B\", -1),\n  83: BareBlockMove(\"D\"),\n  76: BareBlockMove(\"D\", -1),\n  68: BareBlockMove(\"L\"),\n  69: BareBlockMove(\"L\", -1),\n  74: BareBlockMove(\"U\"),\n  70: BareBlockMove(\"U\", -1),\n  72: BareBlockMove(\"F\"),\n  71: BareBlockMove(\"F\", -1),\n\n  78: BareBlockMove(\"x\", -1),\n  67: BareBlockMove(\"l\"),\n  82: BareBlockMove(\"l\", -1),\n  85: BareBlockMove(\"r\"),\n  77: BareBlockMove(\"r\", -1),\n\n  88: BareBlockMove(\"d\", 1),\n  188: BareBlockMove(\"d\", -1),\n\n  84: BareBlockMove(\"x\"),\n  89: BareBlockMove(\"x\"),\n  66: BareBlockMove(\"x\", -1),\n  186: BareBlockMove(\"y\"),\n  59: BareBlockMove(\"y\"),\n  65: BareBlockMove(\"y\", -1), // 186 is WebKit, 59 is Mozilla; see http://unixpapa.com/js/key.html\n  80: BareBlockMove(\"z\"),\n  81: BareBlockMove(\"z\", -1),\n\n  90: BareBlockMove(\"M\", -1),\n  190: BareBlockMove(\"M\", -1),\n};\n\n// TODO: options about whether to ignore modifier keys (e.g. alt, ctrl).\n// TODO: Support different mappings.\n// TODO: Return BaseMove instead?\nexport function keyToMove(e: KeyboardEvent): BlockMove | null {\n  if (e.altKey || e.ctrlKey) {\n    return null;\n  }\n\n  return cubeKeyMapping[e.keyCode] || null;\n}\n"],
  "mappings": "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",
  "names": []
}
