{
  "version": 3,
  "sources": ["../../src/puzzle-geometry/Perm.ts", "../../src/puzzle-geometry/Perm.ts", "../../src/puzzle-geometry/PermOriSet.ts", "../../src/puzzle-geometry/Quat.ts", "../../src/puzzle-geometry/Quat.ts", "../../src/puzzle-geometry/PlatonicGenerator.ts", "../../src/puzzle-geometry/Puzzles.ts", "../../src/puzzle-geometry/interfaces.ts", "../../src/puzzle-geometry/NotationMapper.ts", "../../src/puzzle-geometry/FaceNameSwizzler.ts", "../../src/puzzle-geometry/PuzzleGeometry.ts", "../../src/puzzle-geometry/PuzzleGeometry.ts"],
  "sourcesContent": ["const zeroCache: number[][] = [];\nconst iotaCache: number[][] = [];\n\nexport function zeros(n: number): number[] {\n  if (!zeroCache[n]) {\n    const c = Array(n);\n    for (let i = 0; i < n; i++) {\n      c[i] = 0;\n    }\n    zeroCache[n] = c;\n  }\n  return zeroCache[n];\n}\n\nexport function iota(n: number): number[] {\n  if (!iotaCache[n]) {\n    const c = Array(n);\n    for (let i = 0; i < n; i++) {\n      c[i] = i;\n    }\n    iotaCache[n] = c;\n  }\n  return iotaCache[n];\n}\n\nexport function identity(n: number): Perm {\n  return new Perm(iota(n));\n}\n\nexport function random(n: number): Perm {\n  // random\n  const c = Array(n);\n  for (let i = 0; i < n; i++) {\n    c[i] = i;\n  }\n  for (let i = 0; i < n; i++) {\n    const j = i + Math.floor((n - i) * Math.random());\n    const t = c[i];\n    c[i] = c[j];\n    c[j] = t;\n  }\n  return new Perm(c);\n}\n\nexport function factorial(a: number): number {\n  let r = 1;\n  while (a > 1) {\n    r *= a;\n    a--;\n  }\n  return r;\n}\n\nfunction gcd(a: number, b: number): number {\n  if (a > b) {\n    const t = a;\n    a = b;\n    b = t;\n  }\n  while (a > 0) {\n    const m = b % a;\n    b = a;\n    a = m;\n  }\n  return b;\n}\n\nexport function lcm(a: number, b: number): number {\n  return (a / gcd(a, b)) * b;\n}\n\nexport class Perm {\n  public n: number; // length\n  public p: number[]; // The permutation itself\n  constructor(a: number[]) {\n    this.n = a.length;\n    this.p = a;\n  }\n\n  public toString(): string {\n    // stringify\n    return \"Perm[\" + this.p.join(\" \") + \"]\";\n  }\n\n  public mul(p2: Perm): Perm {\n    // multiply\n    const c: number[] = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[i] = p2.p[this.p[i]];\n    }\n    return new Perm(c);\n  }\n\n  public rmul(p2: Perm): Perm {\n    // multiply the other way\n    const c = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[i] = this.p[p2.p[i]];\n    }\n    return new Perm(c);\n  }\n\n  public inv(): Perm {\n    const c = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[this.p[i]] = i;\n    }\n    return new Perm(c);\n  }\n\n  public compareTo(p2: Perm): number {\n    // comparison\n    for (let i = 0; i < this.n; i++) {\n      if (this.p[i] !== p2.p[i]) {\n        return this.p[i] - p2.p[i];\n      }\n    }\n    return 0;\n  }\n\n  public toGap(): string {\n    const cyc = new Array<string>();\n    const seen = new Array<boolean>(this.n);\n    for (let i = 0; i < this.p.length; i++) {\n      if (seen[i] || this.p[i] === i) {\n        continue;\n      }\n      const incyc = new Array<number>();\n      for (let j = i; !seen[j]; j = this.p[j]) {\n        incyc.push(1 + j);\n        seen[j] = true;\n      }\n      cyc.push(\"(\" + incyc.join(\",\") + \")\");\n    }\n    return cyc.join(\"\");\n  }\n\n  public order(): number {\n    let r = 1;\n    const seen = new Array<boolean>(this.n);\n    for (let i = 0; i < this.p.length; i++) {\n      if (seen[i] || this.p[i] === i) {\n        continue;\n      }\n      let cs = 0;\n      for (let j = i; !seen[j]; j = this.p[j]) {\n        cs++;\n        seen[j] = true;\n      }\n      r = lcm(r, cs);\n    }\n    return r;\n  }\n}\n", "const zeroCache: number[][] = [];\nconst iotaCache: number[][] = [];\n\nexport function zeros(n: number): number[] {\n  if (!zeroCache[n]) {\n    const c = Array(n);\n    for (let i = 0; i < n; i++) {\n      c[i] = 0;\n    }\n    zeroCache[n] = c;\n  }\n  return zeroCache[n];\n}\n\nexport function iota(n: number): number[] {\n  if (!iotaCache[n]) {\n    const c = Array(n);\n    for (let i = 0; i < n; i++) {\n      c[i] = i;\n    }\n    iotaCache[n] = c;\n  }\n  return iotaCache[n];\n}\n\nexport function identity(n: number): Perm {\n  return new Perm(iota(n));\n}\n\nexport function random(n: number): Perm {\n  // random\n  const c = Array(n);\n  for (let i = 0; i < n; i++) {\n    c[i] = i;\n  }\n  for (let i = 0; i < n; i++) {\n    const j = i + Math.floor((n - i) * Math.random());\n    const t = c[i];\n    c[i] = c[j];\n    c[j] = t;\n  }\n  return new Perm(c);\n}\n\nexport function factorial(a: number): number {\n  let r = 1;\n  while (a > 1) {\n    r *= a;\n    a--;\n  }\n  return r;\n}\n\nfunction gcd(a: number, b: number): number {\n  if (a > b) {\n    const t = a;\n    a = b;\n    b = t;\n  }\n  while (a > 0) {\n    const m = b % a;\n    b = a;\n    a = m;\n  }\n  return b;\n}\n\nexport function lcm(a: number, b: number): number {\n  return (a / gcd(a, b)) * b;\n}\n\nexport class Perm {\n  public n: number; // length\n  public p: number[]; // The permutation itself\n  constructor(a: number[]) {\n    this.n = a.length;\n    this.p = a;\n  }\n\n  public toString(): string {\n    // stringify\n    return \"Perm[\" + this.p.join(\" \") + \"]\";\n  }\n\n  public mul(p2: Perm): Perm {\n    // multiply\n    const c: number[] = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[i] = p2.p[this.p[i]];\n    }\n    return new Perm(c);\n  }\n\n  public rmul(p2: Perm): Perm {\n    // multiply the other way\n    const c = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[i] = this.p[p2.p[i]];\n    }\n    return new Perm(c);\n  }\n\n  public inv(): Perm {\n    const c = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[this.p[i]] = i;\n    }\n    return new Perm(c);\n  }\n\n  public compareTo(p2: Perm): number {\n    // comparison\n    for (let i = 0; i < this.n; i++) {\n      if (this.p[i] !== p2.p[i]) {\n        return this.p[i] - p2.p[i];\n      }\n    }\n    return 0;\n  }\n\n  public toGap(): string {\n    const cyc = new Array<string>();\n    const seen = new Array<boolean>(this.n);\n    for (let i = 0; i < this.p.length; i++) {\n      if (seen[i] || this.p[i] === i) {\n        continue;\n      }\n      const incyc = new Array<number>();\n      for (let j = i; !seen[j]; j = this.p[j]) {\n        incyc.push(1 + j);\n        seen[j] = true;\n      }\n      cyc.push(\"(\" + incyc.join(\",\") + \")\");\n    }\n    return cyc.join(\"\");\n  }\n\n  public order(): number {\n    let r = 1;\n    const seen = new Array<boolean>(this.n);\n    for (let i = 0; i < this.p.length; i++) {\n      if (seen[i] || this.p[i] === i) {\n        continue;\n      }\n      let cs = 0;\n      for (let j = i; !seen[j]; j = this.p[j]) {\n        cs++;\n        seen[j] = true;\n      }\n      r = lcm(r, cs);\n    }\n    return r;\n  }\n}\n", "import { KPuzzleDefinition } from \"./interfaces\"; // TODO\n/* tslint:disable no-bitwise */\n/* tslint:disable prefer-for-of */ import {\n  factorial,\n  iota,\n  lcm,\n  Perm,\n  zeros,\n} from \"./Perm\";\nexport class OrbitDef {\n  constructor(public size: number, public mod: number) {}\n  public reassemblySize(): number {\n    return factorial(this.size) * Math.pow(this.mod, this.size);\n  }\n}\n\nexport class OrbitsDef {\n  constructor(\n    public orbitnames: string[],\n    public orbitdefs: OrbitDef[],\n    public solved: VisibleState,\n    public movenames: string[],\n    public moveops: Transformation[],\n  ) {}\n\n  public transformToKPuzzle(t: Transformation): any {\n    const mp: { [orbitName: string]: any } = {};\n    for (let j = 0; j < this.orbitnames.length; j++) {\n      mp[this.orbitnames[j]] = t.orbits[j].toKpuzzle();\n    }\n    return mp;\n  }\n\n  public toKsolve(name: string, forTwisty: boolean): string[] {\n    const result = [];\n    result.push(\"Name \" + name);\n    result.push(\"\");\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      result.push(\n        \"Set \" +\n          this.orbitnames[i] +\n          \" \" +\n          this.orbitdefs[i].size +\n          \" \" +\n          this.orbitdefs[i].mod,\n      );\n    }\n    result.push(\"\");\n    result.push(\"Solved\");\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      result.push(this.orbitnames[i]);\n      const o = this.solved.orbits[i].toKsolveVS();\n      result.push(o[0]);\n      result.push(o[1]);\n    }\n    result.push(\"End\");\n    result.push(\"\");\n    for (let i = 0; i < this.movenames.length; i++) {\n      result.push(\"Move \" + this.movenames[i]);\n      for (let j = 0; j < this.orbitnames.length; j++) {\n        if (!forTwisty && this.moveops[i].orbits[j].isIdentity()) {\n          continue;\n        }\n        result.push(this.orbitnames[j]);\n        const o = this.moveops[i].orbits[j].toKsolve();\n        result.push(o[0]);\n        result.push(o[1]);\n      }\n      result.push(\"End\");\n      result.push(\"\");\n    }\n    // extra blank line on end lets us use join(\"\\n\") to terminate all\n    return result;\n  }\n\n  // TODO: return type.\n  public toKpuzzle(): KPuzzleDefinition {\n    const orbits: { [orbitName: string]: any } = {};\n    const start: { [orbitName: string]: any } = {};\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      orbits[this.orbitnames[i]] = {\n        numPieces: this.orbitdefs[i].size,\n        orientations: this.orbitdefs[i].mod,\n      };\n      start[this.orbitnames[i]] = this.solved.orbits[i].toKpuzzle();\n    }\n    const moves: { [moveName: string]: any } = {};\n    for (let i = 0; i < this.movenames.length; i++) {\n      moves[this.movenames[i]] = this.transformToKPuzzle(this.moveops[i]);\n    }\n    return { name: \"PG3D\", orbits, startPieces: start, moves };\n  }\n\n  public optimize(): OrbitsDef {\n    const neworbitnames: string[] = [];\n    const neworbitdefs: OrbitDef[] = [];\n    const newsolved: Orbit[] = [];\n    const newmoveops: Orbit[][] = [];\n    for (let j = 0; j < this.moveops.length; j++) {\n      newmoveops.push([]);\n    }\n    for (let i = 0; i < this.orbitdefs.length; i++) {\n      const om = this.orbitdefs[i].mod;\n      const n = this.orbitdefs[i].size;\n      const du = new DisjointUnion(n);\n      const changed = new Array<boolean>(this.orbitdefs[i].size);\n      for (let k = 0; k < n; k++) {\n        changed[k] = false;\n      }\n      for (let j = 0; j < this.moveops.length; j++) {\n        for (let k = 0; k < n; k++) {\n          if (\n            this.moveops[j].orbits[i].perm[k] !== k ||\n            this.moveops[j].orbits[i].ori[k] !== 0\n          ) {\n            changed[k] = true;\n            du.union(k, this.moveops[j].orbits[i].perm[k]);\n          }\n        }\n      }\n      let keepori = true;\n      // right now we kill ori only if solved is unique and\n      // if we can kill it completely.  This is not all the optimization\n      // we can perform.\n      if (om > 1) {\n        keepori = false;\n        const duo = new DisjointUnion(this.orbitdefs[i].size * om);\n        for (let j = 0; j < this.moveops.length; j++) {\n          for (let k = 0; k < n; k++) {\n            if (\n              this.moveops[j].orbits[i].perm[k] !== k ||\n              this.moveops[j].orbits[i].ori[k] !== 0\n            ) {\n              for (let o = 0; o < om; o++) {\n                duo.union(\n                  k * om + o,\n                  this.moveops[j].orbits[i].perm[k] * om +\n                    ((o + this.moveops[j].orbits[i].ori[k]) % om),\n                );\n              }\n            }\n          }\n        }\n        for (let j = 0; !keepori && j < n; j++) {\n          for (let o = 1; o < om; o++) {\n            if (duo.find(j * om) === duo.find(j * om + o)) {\n              keepori = true;\n            }\n          }\n        }\n        for (let j = 0; !keepori && j < n; j++) {\n          for (let k = 0; k < j; k++) {\n            if (\n              this.solved.orbits[i].perm[j] === this.solved.orbits[i].perm[k]\n            ) {\n              keepori = true;\n            }\n          }\n        }\n      }\n      // is there just one result set, or more than one?\n      let nontriv = -1;\n      let multiple = false;\n      for (let j = 0; j < this.orbitdefs[i].size; j++) {\n        if (changed[j]) {\n          const h = du.find(j);\n          if (nontriv < 0) {\n            nontriv = h;\n          } else if (nontriv !== h) {\n            multiple = true;\n          }\n        }\n      }\n      for (let j = 0; j < this.orbitdefs[i].size; j++) {\n        if (!changed[j]) {\n          continue;\n        }\n        const h = du.find(j);\n        if (h !== j) {\n          continue;\n        }\n        const no: number[] = [];\n        const on: number[] = [];\n        let nv = 0;\n        for (let k = 0; k < this.orbitdefs[i].size; k++) {\n          if (du.find(k) === j) {\n            no[nv] = k;\n            on[k] = nv;\n            nv++;\n          }\n        }\n        if (multiple) {\n          neworbitnames.push(this.orbitnames[i] + \"_p\" + j);\n        } else {\n          neworbitnames.push(this.orbitnames[i]);\n        }\n        if (keepori) {\n          neworbitdefs.push(new OrbitDef(nv, this.orbitdefs[i].mod));\n          newsolved.push(this.solved.orbits[i].remapVS(no, nv));\n          for (let k = 0; k < this.moveops.length; k++) {\n            newmoveops[k].push(this.moveops[k].orbits[i].remap(no, on, nv));\n          }\n        } else {\n          neworbitdefs.push(new OrbitDef(nv, 1));\n          newsolved.push(this.solved.orbits[i].remapVS(no, nv).killOri());\n          for (let k = 0; k < this.moveops.length; k++) {\n            newmoveops[k].push(\n              this.moveops[k].orbits[i].remap(no, on, nv).killOri(),\n            );\n          }\n        }\n      }\n    }\n    return new OrbitsDef(\n      neworbitnames,\n      neworbitdefs,\n      new VisibleState(newsolved),\n      this.movenames,\n      newmoveops.map((_) => new Transformation(_)),\n    );\n  }\n\n  // generate a new \"solved\" position based on scrambling\n  // we use an algorithm that should be faster for large puzzles than\n  // just picking random moves.\n  public scramble(n: number): void {\n    const pool: Transformation[] = [];\n    for (let i = 0; i < this.moveops.length; i++) {\n      pool[i] = this.moveops[i];\n    }\n    for (let i = 0; i < pool.length; i++) {\n      const j = Math.floor(Math.random() * pool.length);\n      const t = pool[i];\n      pool[i] = pool[j];\n      pool[j] = t;\n    }\n    if (n < pool.length) {\n      n = pool.length;\n    }\n    for (let i = 0; i < n; i++) {\n      const ri = Math.floor(Math.random() * pool.length);\n      const rj = Math.floor(Math.random() * pool.length);\n      const rm = Math.floor(Math.random() * this.moveops.length);\n      pool[ri] = pool[ri].mul(pool[rj]).mul(this.moveops[rm]);\n      if (Math.random() < 0.1) {\n        // break up parity\n        pool[ri] = pool[ri].mul(this.moveops[rm]);\n      }\n    }\n    let s = pool[0];\n    for (let i = 1; i < pool.length; i++) {\n      s = s.mul(pool[i]);\n    }\n    this.solved = this.solved.mul(s);\n  }\n\n  public reassemblySize(): number {\n    let n = 1;\n    for (let i = 0; i < this.orbitdefs.length; i++) {\n      n *= this.orbitdefs[i].reassemblySize();\n    }\n    return n;\n  }\n}\nexport class Orbit {\n  public static e(n: number, mod: number): Orbit {\n    return new Orbit(iota(n), zeros(n), mod);\n  }\n\n  constructor(\n    public perm: number[],\n    public ori: number[],\n    public orimod: number,\n  ) {}\n\n  public mul(b: Orbit): Orbit {\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n);\n    if (this.orimod === 1) {\n      for (let i = 0; i < n; i++) {\n        newPerm[i] = this.perm[b.perm[i]];\n      }\n      return new Orbit(newPerm, this.ori, this.orimod);\n    } else {\n      const newOri = new Array<number>(n);\n      for (let i = 0; i < n; i++) {\n        newPerm[i] = this.perm[b.perm[i]];\n        newOri[i] = (this.ori[b.perm[i]] + b.ori[i]) % this.orimod;\n      }\n      return new Orbit(newPerm, newOri, this.orimod);\n    }\n  }\n\n  public inv(): Orbit {\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n);\n    const newOri = new Array<number>(n);\n    for (let i = 0; i < n; i++) {\n      newPerm[this.perm[i]] = i;\n      newOri[this.perm[i]] = (this.orimod - this.ori[i]) % this.orimod;\n    }\n    return new Orbit(newPerm, newOri, this.orimod);\n  }\n\n  public equal(b: Orbit): boolean {\n    const n = this.perm.length;\n    for (let i = 0; i < n; i++) {\n      if (this.perm[i] !== b.perm[i] || this.ori[i] !== b.ori[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // in-place mutator\n  public killOri(): this {\n    const n = this.perm.length;\n    for (let i = 0; i < n; i++) {\n      this.ori[i] = 0;\n    }\n    this.orimod = 1;\n    return this;\n  }\n\n  public toPerm(): Perm {\n    const o = this.orimod;\n    if (o === 1) {\n      return new Perm(this.perm);\n    }\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n * o);\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < o; j++) {\n        newPerm[i * o + j] = o * this.perm[i] + ((this.ori[i] + j) % o);\n      }\n    }\n    return new Perm(newPerm);\n  }\n\n  // returns tuple of sets of identical pieces in this orbit\n  public identicalPieces(): number[][] {\n    const done: boolean[] = [];\n    const n = this.perm.length;\n    const r: number[][] = [];\n    for (let i = 0; i < n; i++) {\n      const v = this.perm[i];\n      if (done[v] === undefined) {\n        const s: number[] = [i];\n        done[v] = true;\n        for (let j = i + 1; j < n; j++) {\n          if (this.perm[j] === v) {\n            s.push(j);\n          }\n        }\n        r.push(s);\n      }\n    }\n    return r;\n  }\n\n  public order(): number {\n    // can be made more efficient\n    return this.toPerm().order();\n  }\n\n  public isIdentity(): boolean {\n    const n = this.perm.length;\n    if (this.perm === iota(n) && this.ori === zeros(n)) {\n      return true;\n    }\n    for (let i = 0; i < n; i++) {\n      if (this.perm[i] !== i || this.ori[i] !== 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  public remap(no: number[], on: number[], nv: number): Orbit {\n    const newPerm = new Array<number>(nv);\n    const newOri = new Array<number>(nv);\n    for (let i = 0; i < nv; i++) {\n      newPerm[i] = on[this.perm[no[i]]];\n      newOri[i] = this.ori[no[i]];\n    }\n    return new Orbit(newPerm, newOri, this.orimod);\n  }\n\n  public remapVS(no: number[], nv: number): Orbit {\n    const newPerm = new Array<number>(nv);\n    const newOri = new Array<number>(nv);\n    let nextNew = 0;\n    const reassign = [];\n    for (let i = 0; i < nv; i++) {\n      const ov = this.perm[no[i]];\n      if (reassign[ov] === undefined) {\n        reassign[ov] = nextNew++;\n      }\n      newPerm[i] = reassign[ov];\n      newOri[i] = this.ori[no[i]];\n    }\n    return new Orbit(newPerm, newOri, this.orimod);\n  }\n\n  public toKsolveVS(): string[] {\n    return [this.perm.map((_: number) => _ + 1).join(\" \"), this.ori.join(\" \")];\n  }\n\n  public toKsolve(): string[] {\n    const newori = new Array<number>(this.ori.length);\n    for (let i = 0; i < newori.length; i++) {\n      newori[this.perm[i]] = this.ori[i];\n    }\n    return [this.perm.map((_: number) => _ + 1).join(\" \"), newori.join(\" \")];\n  }\n\n  // TODO: return type\n  public toKpuzzle(): Record<string, unknown> {\n    return { permutation: this.perm, orientation: this.ori };\n  }\n}\nexport class TransformationBase {\n  constructor(public orbits: Orbit[]) {}\n  public internalMul(b: TransformationBase): Orbit[] {\n    const newOrbits: Orbit[] = [];\n    for (let i = 0; i < this.orbits.length; i++) {\n      newOrbits.push(this.orbits[i].mul(b.orbits[i]));\n    }\n    return newOrbits;\n  }\n\n  public internalInv(): Orbit[] {\n    const newOrbits: Orbit[] = [];\n    for (let i = 0; i < this.orbits.length; i++) {\n      newOrbits.push(this.orbits[i].inv());\n    }\n    return newOrbits;\n  }\n\n  public equal(b: TransformationBase): boolean {\n    for (let i = 0; i < this.orbits.length; i++) {\n      if (!this.orbits[i].equal(b.orbits[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  public killOri(): this {\n    for (let i = 0; i < this.orbits.length; i++) {\n      this.orbits[i].killOri();\n    }\n    return this;\n  }\n\n  public toPerm(): Perm {\n    const perms = new Array<Perm>();\n    let n = 0;\n    for (let i = 0; i < this.orbits.length; i++) {\n      const p = this.orbits[i].toPerm();\n      perms.push(p);\n      n += p.n;\n    }\n    const newPerm = new Array<number>(n);\n    n = 0;\n    for (let i = 0; i < this.orbits.length; i++) {\n      const p = perms[i];\n      for (let j = 0; j < p.n; j++) {\n        newPerm[n + j] = n + p.p[j];\n      }\n      n += p.n;\n    }\n    return new Perm(newPerm);\n  }\n\n  public identicalPieces(): number[][] {\n    const r: number[][] = [];\n    let n = 0;\n    for (let i = 0; i < this.orbits.length; i++) {\n      const o = this.orbits[i].orimod;\n      const s = this.orbits[i].identicalPieces();\n      for (let j = 0; j < s.length; j++) {\n        r.push(s[j].map((_) => _ * o + n));\n      }\n      n += o * this.orbits[i].perm.length;\n    }\n    return r;\n  }\n\n  public order(): number {\n    let r = 1;\n    for (let i = 0; i < this.orbits.length; i++) {\n      r = lcm(r, this.orbits[i].order());\n    }\n    return r;\n  }\n}\nexport class Transformation extends TransformationBase {\n  constructor(orbits: Orbit[]) {\n    super(orbits);\n  }\n\n  public mul(b: Transformation): Transformation {\n    return new Transformation(this.internalMul(b));\n  }\n\n  public mulScalar(n: number): Transformation {\n    if (n === 0) {\n      return this.e();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let t: Transformation = this;\n    if (n < 0) {\n      t = t.inv();\n      n = -n;\n    }\n    while ((n & 1) === 0) {\n      t = t.mul(t);\n      n >>= 1;\n    }\n    if (n === 1) {\n      return t;\n    }\n    let s = t;\n    let r = this.e();\n    while (n > 0) {\n      if (n & 1) {\n        r = r.mul(s);\n      }\n      if (n > 1) {\n        s = s.mul(s);\n      }\n      n >>= 1;\n    }\n    return r;\n  }\n\n  public inv(): Transformation {\n    return new Transformation(this.internalInv());\n  }\n\n  public e(): Transformation {\n    return new Transformation(\n      this.orbits.map((_: Orbit) => Orbit.e(_.perm.length, _.orimod)),\n    );\n  }\n}\nexport class VisibleState extends TransformationBase {\n  constructor(orbits: Orbit[]) {\n    super(orbits);\n  }\n\n  public mul(b: Transformation): VisibleState {\n    return new VisibleState(this.internalMul(b));\n  }\n}\n//  Disjoint set union implementation.\nclass DisjointUnion {\n  public heads: number[];\n  constructor(public n: number) {\n    this.heads = new Array<number>(n);\n    for (let i = 0; i < n; i++) {\n      this.heads[i] = i;\n    }\n  }\n\n  public find(v: number): number {\n    let h = this.heads[v];\n    if (this.heads[h] === h) {\n      return h;\n    }\n    h = this.find(this.heads[h]);\n    this.heads[v] = h;\n    return h;\n  }\n\n  public union(a: number, b: number): void {\n    const ah = this.find(a);\n    const bh = this.find(b);\n    if (ah < bh) {\n      this.heads[bh] = ah;\n    } else if (ah > bh) {\n      this.heads[ah] = bh;\n    }\n  }\n}\nexport function showcanon(g: OrbitsDef, disp: (s: string) => void): void {\n  // show information for canonical move derivation\n  const n = g.moveops.length;\n  if (n > 30) {\n    throw new Error(\"Canon info too big for bitmask\");\n  }\n  const orders = [];\n  const commutes = [];\n  for (let i = 0; i < n; i++) {\n    const permA = g.moveops[i];\n    orders.push(permA.order());\n    let bits = 0;\n    for (let j = 0; j < n; j++) {\n      if (j === i) {\n        continue;\n      }\n      const permB = g.moveops[j];\n      if (permA.mul(permB).equal(permB.mul(permA))) {\n        bits |= 1 << j;\n      }\n    }\n    commutes.push(bits);\n  }\n  let curlev: any = {};\n  curlev[0] = 1;\n  for (let d = 0; d < 100; d++) {\n    let sum = 0;\n    const nextlev: any = {};\n    let uniq = 0;\n    for (const sti in curlev) {\n      const st = +sti; // string to number\n      const cnt = curlev[st];\n      sum += cnt;\n      uniq++;\n      for (let mv = 0; mv < orders.length; mv++) {\n        if (\n          ((st >> mv) & 1) === 0 &&\n          (st & commutes[mv] & ((1 << mv) - 1)) === 0\n        ) {\n          const nst = (st & commutes[mv]) | (1 << mv);\n          if (nextlev[nst] === undefined) {\n            nextlev[nst] = 0;\n          }\n          nextlev[nst] += (orders[mv] - 1) * cnt;\n        }\n      }\n    }\n    disp(\"\" + d + \": canonseq \" + sum + \" states \" + uniq);\n    curlev = nextlev;\n  }\n}\n// This is a less effective canonicalization (that happens to work fine\n// for the 3x3x3).  We include this only for comparison.\nexport function showcanon0(g: OrbitsDef, disp: (s: string) => void): void {\n  // show information for canonical move derivation\n  const n = g.moveops.length;\n  if (n > 30) {\n    throw new Error(\"Canon info too big for bitmask\");\n  }\n  const orders = [];\n  const commutes = [];\n  for (let i = 0; i < n; i++) {\n    const permA = g.moveops[i];\n    orders.push(permA.order());\n    let bits = 0;\n    for (let j = 0; j < n; j++) {\n      if (j === i) {\n        continue;\n      }\n      const permB = g.moveops[j];\n      if (permA.mul(permB).equal(permB.mul(permA))) {\n        bits |= 1 << j;\n      }\n    }\n    commutes.push(bits);\n  }\n  let curlev: any = {};\n  disp(\"\" + 0 + \": canonseq \" + 1);\n  for (let x = 0; x < orders.length; x++) {\n    curlev[x] = orders[x] - 1;\n  }\n  for (let d = 1; d < 100; d++) {\n    let sum = 0;\n    const nextlev: any = {};\n    let uniq = 0;\n    for (const sti in curlev) {\n      const st = +sti; // string to number\n      const cnt = curlev[st];\n      sum += cnt;\n      uniq++;\n      for (let mv = 0; mv < orders.length; mv++) {\n        if (mv === st || (commutes[mv] & (1 << st) && mv < st)) {\n          continue;\n        }\n        if (nextlev[mv] === undefined) {\n          nextlev[mv] = 0;\n        }\n        nextlev[mv] += (orders[mv] - 1) * cnt;\n      }\n    }\n    disp(\"\" + d + \": canonseq \" + sum + \" states \" + uniq);\n    curlev = nextlev;\n  }\n}\n", "/* tslint:disable no-bitwise */\n/* tslint:disable prefer-for-of */ // TODO\n\n// We need a quaternion class.  We use this to represent rotations,\n// planes, and points.\n\nconst eps = 1e-9; // TODO: Deduplicate with `PuzzleGeometry`?\n\nexport function expandfaces(rots: Quat[], faces: Quat[][]): Quat[][] {\n  // given a set of faces, expand by rotation set\n  const nfaces = [];\n  for (let i = 0; i < rots.length; i++) {\n    for (let k = 0; k < faces.length; k++) {\n      const face = faces[k];\n      const nface = [];\n      for (let j = 0; j < face.length; j++) {\n        nface.push(face[j].rotateplane(rots[i]));\n      }\n      nfaces.push(nface);\n    }\n  }\n  return nfaces;\n}\n\nexport function centermassface(face: Quat[]): Quat {\n  // calculate a center of a face by averaging points\n  let s = new Quat(0, 0, 0, 0);\n  for (let i = 0; i < face.length; i++) {\n    s = s.sum(face[i]);\n  }\n  return s.smul(1.0 / face.length);\n}\n\nexport function random(): Quat {\n  // generate a random quat\n  const q = new Quat(\n    Math.random() * 2 - 1,\n    Math.random() * 2 - 1,\n    Math.random() * 2 - 1,\n    Math.random() * 2 - 1,\n  );\n  return q.smul(1 / q.len());\n}\n\nexport function solvethreeplanes(\n  p1: number,\n  p2: number,\n  p3: number,\n  planes: Quat[],\n): any {\n  // find intersection of three planes but only if interior\n  // Takes three indices into a plane array, and returns the point at the\n  // intersection of all three, but only if it is internal to all planes.\n  const p = planes[p1].intersect3(planes[p2], planes[p3]);\n  if (!p) {\n    return p;\n  }\n  for (let i = 0; i < planes.length; i++) {\n    if (i !== p1 && i !== p2 && i !== p3) {\n      const dt = planes[i].b * p.b + planes[i].c * p.c + planes[i].d * p.d;\n      if (\n        (planes[i].a > 0 && dt > planes[i].a) ||\n        (planes[i].a < 0 && dt < planes[i].a)\n      ) {\n        return false;\n      }\n    }\n  }\n  return p;\n}\n\nexport class Quat {\n  constructor(\n    public a: number,\n    public b: number,\n    public c: number,\n    public d: number,\n  ) {}\n\n  public mul(q: Quat): Quat {\n    // Quaternion multiplication\n    return new Quat(\n      this.a * q.a - this.b * q.b - this.c * q.c - this.d * q.d,\n      this.a * q.b + this.b * q.a + this.c * q.d - this.d * q.c,\n      this.a * q.c - this.b * q.d + this.c * q.a + this.d * q.b,\n      this.a * q.d + this.b * q.c - this.c * q.b + this.d * q.a,\n    );\n  }\n\n  public toString(): string {\n    return \"Q[\" + this.a + \",\" + this.b + \",\" + this.c + \",\" + this.d + \"]\";\n  }\n\n  public dist(q: Quat): number {\n    // Euclidean distance\n    return Math.hypot(this.a - q.a, this.b - q.b, this.c - q.c, this.d - q.d);\n  }\n\n  public len(): number {\n    // Euclidean length\n    return Math.hypot(this.a, this.b, this.c, this.d);\n  }\n\n  public cross(q: Quat): Quat {\n    // cross product\n    return new Quat(\n      0,\n      this.c * q.d - this.d * q.c,\n      this.d * q.b - this.b * q.d,\n      this.b * q.c - this.c * q.b,\n    );\n  }\n\n  public dot(q: Quat): number {\n    // dot product of two quaternions\n    return this.b * q.b + this.c * q.c + this.d * q.d;\n  }\n\n  public normalize(): Quat {\n    // make the magnitude be 1\n    const d = Math.sqrt(this.dot(this));\n    return new Quat(this.a / d, this.b / d, this.c / d, this.d / d);\n  }\n\n  public makenormal(): Quat {\n    // make a normal vector from a plane or quat or point\n    return new Quat(0, this.b, this.c, this.d).normalize();\n  }\n\n  public normalizeplane(): Quat {\n    // normalize a plane\n    const d = Math.hypot(this.b, this.c, this.d);\n    return new Quat(this.a / d, this.b / d, this.c / d, this.d / d);\n  }\n\n  public smul(m: number): Quat {\n    // scalar multiplication\n    return new Quat(this.a * m, this.b * m, this.c * m, this.d * m);\n  }\n\n  public sum(q: Quat): Quat {\n    // quaternion sum\n    return new Quat(this.a + q.a, this.b + q.b, this.c + q.c, this.d + q.d);\n  }\n\n  public sub(q: Quat): Quat {\n    // difference\n    return new Quat(this.a - q.a, this.b - q.b, this.c - q.c, this.d - q.d);\n  }\n\n  public angle(): number {\n    // quaternion angle\n    return 2 * Math.acos(this.a);\n  }\n\n  public invrot(): Quat {\n    // quaternion inverse rotation\n    return new Quat(this.a, -this.b, -this.c, -this.d);\n  }\n\n  public det3x3(\n    a00: number,\n    a01: number,\n    a02: number,\n    a10: number,\n    a11: number,\n    a12: number,\n    a20: number,\n    a21: number,\n    a22: number,\n  ): number {\n    // 3x3 determinant\n    return (\n      a00 * (a11 * a22 - a12 * a21) +\n      a01 * (a12 * a20 - a10 * a22) +\n      a02 * (a10 * a21 - a11 * a20)\n    );\n  }\n\n  public rotateplane(q: Quat): Quat {\n    // rotate a plane using a quaternion\n    const t = q.mul(new Quat(0, this.b, this.c, this.d)).mul(q.invrot());\n    t.a = this.a;\n    return t;\n  }\n\n  // return any vector orthogonal to the given one.  Find the smallest\n  // component (in absolute value) and return the cross product of that\n  // axis with the given vector.\n  public orthogonal(): Quat {\n    const ab = Math.abs(this.b);\n    const ac = Math.abs(this.c);\n    const ad = Math.abs(this.d);\n    if (ab < ac && ab < ad) {\n      return this.cross(new Quat(0, 1, 0, 0)).normalize();\n    } else if (ac < ab && ac < ad) {\n      return this.cross(new Quat(0, 0, 1, 0)).normalize();\n    } else {\n      return this.cross(new Quat(0, 0, 0, 1)).normalize();\n    }\n  }\n\n  // return the Quaternion that will rotate the this vector\n  // to the b vector through rotatepoint.\n  public pointrotation(b: Quat): Quat {\n    const a = this.normalize();\n    b = b.normalize();\n    if (a.sub(b).len() < eps) {\n      return new Quat(1, 0, 0, 0);\n    }\n    let h = a.sum(b);\n    if (h.len() < eps) {\n      h = h.orthogonal();\n    } else {\n      h = h.normalize();\n    }\n    const r = a.cross(h);\n    r.a = a.dot(h);\n    return r;\n  }\n\n  // given two vectors, return the portion of the first that\n  // is not in the direction of the second.\n  public unproject(b: Quat): Quat {\n    return this.sum(b.smul(-this.dot(b) / (this.len() * b.len())));\n  }\n\n  public rotatepoint(q: Quat): Quat {\n    // rotate a point\n    return q.mul(this).mul(q.invrot());\n  }\n\n  public rotateface(face: Quat[]): Quat[] {\n    // rotate a face by this Q.\n    return face.map((_: Quat) => _.rotatepoint(this));\n  }\n\n  public rotatecubie(cubie: Quat[][]): Quat[][] {\n    // rotate a cubie by this Q.\n    return cubie.map((_: Quat[]) => this.rotateface(_));\n  }\n\n  public intersect3(p2: Quat, p3: Quat): Quat | false {\n    // intersect three planes if there is one\n    const det = this.det3x3(\n      this.b,\n      this.c,\n      this.d,\n      p2.b,\n      p2.c,\n      p2.d,\n      p3.b,\n      p3.c,\n      p3.d,\n    );\n    if (Math.abs(det) < eps) {\n      return false; // TODO: Change to `null` or `undefined`?\n    }\n    return new Quat(\n      0,\n      this.det3x3(this.a, this.c, this.d, p2.a, p2.c, p2.d, p3.a, p3.c, p3.d) /\n        det,\n      this.det3x3(this.b, this.a, this.d, p2.b, p2.a, p2.d, p3.b, p3.a, p3.d) /\n        det,\n      this.det3x3(this.b, this.c, this.a, p2.b, p2.c, p2.a, p3.b, p3.c, p3.a) /\n        det,\n    );\n  }\n\n  public side(x: number): number {\n    // is this point close to the origin, or on one or the other side?\n    if (x > eps) {\n      return 1;\n    }\n    if (x < -eps) {\n      return -1;\n    }\n    return 0;\n  }\n\n  public cutfaces(faces: Quat[][]): Quat[][] {\n    // Cut a set of faces by a plane and return new set\n    const d = this.a;\n    const nfaces = [];\n    for (let j = 0; j < faces.length; j++) {\n      const face = faces[j];\n      const inout = face.map((_: Quat) => this.side(_.dot(this) - d));\n      let seen = 0;\n      for (let i = 0; i < inout.length; i++) {\n        seen |= 1 << (inout[i] + 1);\n      }\n      if ((seen & 5) === 5) {\n        // saw both sides\n        for (let s = -1; s <= 1; s += 2) {\n          const nface = [];\n          for (let k = 0; k < face.length; k++) {\n            if (inout[k] === s || inout[k] === 0) {\n              nface.push(face[k]);\n            }\n            const kk = (k + 1) % face.length;\n            if (inout[k] + inout[kk] === 0 && inout[k] !== 0) {\n              const vk = face[k].dot(this) - d;\n              const vkk = face[kk].dot(this) - d;\n              const r = vk / (vk - vkk);\n              const pt = face[k].smul(1 - r).sum(face[kk].smul(r));\n              nface.push(pt);\n            }\n          }\n          nfaces.push(nface);\n        }\n      } else {\n        // no split\n        nfaces.push(face);\n      }\n    }\n    return nfaces;\n  }\n\n  public faceside(face: Quat[]): number {\n    // which side of a plane is a face on?\n    const d = this.a;\n    for (let i = 0; i < face.length; i++) {\n      const s = this.side(face[i].dot(this) - d);\n      if (s !== 0) {\n        return s;\n      }\n    }\n    throw new Error(\"Could not determine side of plane in faceside\");\n  }\n\n  public sameplane(p: Quat): boolean {\n    // are two planes the same?\n    const a = this.normalize();\n    const b = p.normalize();\n    return a.dist(b) < eps || a.dist(b.smul(-1)) < eps;\n  }\n\n  public makecut(r: number): Quat {\n    // make a cut from a normal vector\n    return new Quat(r, this.b, this.c, this.d);\n  }\n}\n", "/* tslint:disable no-bitwise */\n/* tslint:disable prefer-for-of */ // TODO\n\n// We need a quaternion class.  We use this to represent rotations,\n// planes, and points.\n\nconst eps = 1e-9; // TODO: Deduplicate with `PuzzleGeometry`?\n\nexport function expandfaces(rots: Quat[], faces: Quat[][]): Quat[][] {\n  // given a set of faces, expand by rotation set\n  const nfaces = [];\n  for (let i = 0; i < rots.length; i++) {\n    for (let k = 0; k < faces.length; k++) {\n      const face = faces[k];\n      const nface = [];\n      for (let j = 0; j < face.length; j++) {\n        nface.push(face[j].rotateplane(rots[i]));\n      }\n      nfaces.push(nface);\n    }\n  }\n  return nfaces;\n}\n\nexport function centermassface(face: Quat[]): Quat {\n  // calculate a center of a face by averaging points\n  let s = new Quat(0, 0, 0, 0);\n  for (let i = 0; i < face.length; i++) {\n    s = s.sum(face[i]);\n  }\n  return s.smul(1.0 / face.length);\n}\n\nexport function random(): Quat {\n  // generate a random quat\n  const q = new Quat(\n    Math.random() * 2 - 1,\n    Math.random() * 2 - 1,\n    Math.random() * 2 - 1,\n    Math.random() * 2 - 1,\n  );\n  return q.smul(1 / q.len());\n}\n\nexport function solvethreeplanes(\n  p1: number,\n  p2: number,\n  p3: number,\n  planes: Quat[],\n): any {\n  // find intersection of three planes but only if interior\n  // Takes three indices into a plane array, and returns the point at the\n  // intersection of all three, but only if it is internal to all planes.\n  const p = planes[p1].intersect3(planes[p2], planes[p3]);\n  if (!p) {\n    return p;\n  }\n  for (let i = 0; i < planes.length; i++) {\n    if (i !== p1 && i !== p2 && i !== p3) {\n      const dt = planes[i].b * p.b + planes[i].c * p.c + planes[i].d * p.d;\n      if (\n        (planes[i].a > 0 && dt > planes[i].a) ||\n        (planes[i].a < 0 && dt < planes[i].a)\n      ) {\n        return false;\n      }\n    }\n  }\n  return p;\n}\n\nexport class Quat {\n  constructor(\n    public a: number,\n    public b: number,\n    public c: number,\n    public d: number,\n  ) {}\n\n  public mul(q: Quat): Quat {\n    // Quaternion multiplication\n    return new Quat(\n      this.a * q.a - this.b * q.b - this.c * q.c - this.d * q.d,\n      this.a * q.b + this.b * q.a + this.c * q.d - this.d * q.c,\n      this.a * q.c - this.b * q.d + this.c * q.a + this.d * q.b,\n      this.a * q.d + this.b * q.c - this.c * q.b + this.d * q.a,\n    );\n  }\n\n  public toString(): string {\n    return \"Q[\" + this.a + \",\" + this.b + \",\" + this.c + \",\" + this.d + \"]\";\n  }\n\n  public dist(q: Quat): number {\n    // Euclidean distance\n    return Math.hypot(this.a - q.a, this.b - q.b, this.c - q.c, this.d - q.d);\n  }\n\n  public len(): number {\n    // Euclidean length\n    return Math.hypot(this.a, this.b, this.c, this.d);\n  }\n\n  public cross(q: Quat): Quat {\n    // cross product\n    return new Quat(\n      0,\n      this.c * q.d - this.d * q.c,\n      this.d * q.b - this.b * q.d,\n      this.b * q.c - this.c * q.b,\n    );\n  }\n\n  public dot(q: Quat): number {\n    // dot product of two quaternions\n    return this.b * q.b + this.c * q.c + this.d * q.d;\n  }\n\n  public normalize(): Quat {\n    // make the magnitude be 1\n    const d = Math.sqrt(this.dot(this));\n    return new Quat(this.a / d, this.b / d, this.c / d, this.d / d);\n  }\n\n  public makenormal(): Quat {\n    // make a normal vector from a plane or quat or point\n    return new Quat(0, this.b, this.c, this.d).normalize();\n  }\n\n  public normalizeplane(): Quat {\n    // normalize a plane\n    const d = Math.hypot(this.b, this.c, this.d);\n    return new Quat(this.a / d, this.b / d, this.c / d, this.d / d);\n  }\n\n  public smul(m: number): Quat {\n    // scalar multiplication\n    return new Quat(this.a * m, this.b * m, this.c * m, this.d * m);\n  }\n\n  public sum(q: Quat): Quat {\n    // quaternion sum\n    return new Quat(this.a + q.a, this.b + q.b, this.c + q.c, this.d + q.d);\n  }\n\n  public sub(q: Quat): Quat {\n    // difference\n    return new Quat(this.a - q.a, this.b - q.b, this.c - q.c, this.d - q.d);\n  }\n\n  public angle(): number {\n    // quaternion angle\n    return 2 * Math.acos(this.a);\n  }\n\n  public invrot(): Quat {\n    // quaternion inverse rotation\n    return new Quat(this.a, -this.b, -this.c, -this.d);\n  }\n\n  public det3x3(\n    a00: number,\n    a01: number,\n    a02: number,\n    a10: number,\n    a11: number,\n    a12: number,\n    a20: number,\n    a21: number,\n    a22: number,\n  ): number {\n    // 3x3 determinant\n    return (\n      a00 * (a11 * a22 - a12 * a21) +\n      a01 * (a12 * a20 - a10 * a22) +\n      a02 * (a10 * a21 - a11 * a20)\n    );\n  }\n\n  public rotateplane(q: Quat): Quat {\n    // rotate a plane using a quaternion\n    const t = q.mul(new Quat(0, this.b, this.c, this.d)).mul(q.invrot());\n    t.a = this.a;\n    return t;\n  }\n\n  // return any vector orthogonal to the given one.  Find the smallest\n  // component (in absolute value) and return the cross product of that\n  // axis with the given vector.\n  public orthogonal(): Quat {\n    const ab = Math.abs(this.b);\n    const ac = Math.abs(this.c);\n    const ad = Math.abs(this.d);\n    if (ab < ac && ab < ad) {\n      return this.cross(new Quat(0, 1, 0, 0)).normalize();\n    } else if (ac < ab && ac < ad) {\n      return this.cross(new Quat(0, 0, 1, 0)).normalize();\n    } else {\n      return this.cross(new Quat(0, 0, 0, 1)).normalize();\n    }\n  }\n\n  // return the Quaternion that will rotate the this vector\n  // to the b vector through rotatepoint.\n  public pointrotation(b: Quat): Quat {\n    const a = this.normalize();\n    b = b.normalize();\n    if (a.sub(b).len() < eps) {\n      return new Quat(1, 0, 0, 0);\n    }\n    let h = a.sum(b);\n    if (h.len() < eps) {\n      h = h.orthogonal();\n    } else {\n      h = h.normalize();\n    }\n    const r = a.cross(h);\n    r.a = a.dot(h);\n    return r;\n  }\n\n  // given two vectors, return the portion of the first that\n  // is not in the direction of the second.\n  public unproject(b: Quat): Quat {\n    return this.sum(b.smul(-this.dot(b) / (this.len() * b.len())));\n  }\n\n  public rotatepoint(q: Quat): Quat {\n    // rotate a point\n    return q.mul(this).mul(q.invrot());\n  }\n\n  public rotateface(face: Quat[]): Quat[] {\n    // rotate a face by this Q.\n    return face.map((_: Quat) => _.rotatepoint(this));\n  }\n\n  public rotatecubie(cubie: Quat[][]): Quat[][] {\n    // rotate a cubie by this Q.\n    return cubie.map((_: Quat[]) => this.rotateface(_));\n  }\n\n  public intersect3(p2: Quat, p3: Quat): Quat | false {\n    // intersect three planes if there is one\n    const det = this.det3x3(\n      this.b,\n      this.c,\n      this.d,\n      p2.b,\n      p2.c,\n      p2.d,\n      p3.b,\n      p3.c,\n      p3.d,\n    );\n    if (Math.abs(det) < eps) {\n      return false; // TODO: Change to `null` or `undefined`?\n    }\n    return new Quat(\n      0,\n      this.det3x3(this.a, this.c, this.d, p2.a, p2.c, p2.d, p3.a, p3.c, p3.d) /\n        det,\n      this.det3x3(this.b, this.a, this.d, p2.b, p2.a, p2.d, p3.b, p3.a, p3.d) /\n        det,\n      this.det3x3(this.b, this.c, this.a, p2.b, p2.c, p2.a, p3.b, p3.c, p3.a) /\n        det,\n    );\n  }\n\n  public side(x: number): number {\n    // is this point close to the origin, or on one or the other side?\n    if (x > eps) {\n      return 1;\n    }\n    if (x < -eps) {\n      return -1;\n    }\n    return 0;\n  }\n\n  public cutfaces(faces: Quat[][]): Quat[][] {\n    // Cut a set of faces by a plane and return new set\n    const d = this.a;\n    const nfaces = [];\n    for (let j = 0; j < faces.length; j++) {\n      const face = faces[j];\n      const inout = face.map((_: Quat) => this.side(_.dot(this) - d));\n      let seen = 0;\n      for (let i = 0; i < inout.length; i++) {\n        seen |= 1 << (inout[i] + 1);\n      }\n      if ((seen & 5) === 5) {\n        // saw both sides\n        for (let s = -1; s <= 1; s += 2) {\n          const nface = [];\n          for (let k = 0; k < face.length; k++) {\n            if (inout[k] === s || inout[k] === 0) {\n              nface.push(face[k]);\n            }\n            const kk = (k + 1) % face.length;\n            if (inout[k] + inout[kk] === 0 && inout[k] !== 0) {\n              const vk = face[k].dot(this) - d;\n              const vkk = face[kk].dot(this) - d;\n              const r = vk / (vk - vkk);\n              const pt = face[k].smul(1 - r).sum(face[kk].smul(r));\n              nface.push(pt);\n            }\n          }\n          nfaces.push(nface);\n        }\n      } else {\n        // no split\n        nfaces.push(face);\n      }\n    }\n    return nfaces;\n  }\n\n  public faceside(face: Quat[]): number {\n    // which side of a plane is a face on?\n    const d = this.a;\n    for (let i = 0; i < face.length; i++) {\n      const s = this.side(face[i].dot(this) - d);\n      if (s !== 0) {\n        return s;\n      }\n    }\n    throw new Error(\"Could not determine side of plane in faceside\");\n  }\n\n  public sameplane(p: Quat): boolean {\n    // are two planes the same?\n    const a = this.normalize();\n    const b = p.normalize();\n    return a.dist(b) < eps || a.dist(b.smul(-1)) < eps;\n  }\n\n  public makecut(r: number): Quat {\n    // make a cut from a normal vector\n    return new Quat(r, this.b, this.c, this.d);\n  }\n}\n", "/* tslint:disable prefer-for-of */ // TODO\n\nimport { Quat, solvethreeplanes } from \"./Quat\";\n\n// Next we define a class that yields quaternion generators for each of\n// the five platonic solids.  The quaternion generators chosen are\n// chosen specifically so that the first quaternion doubles as a plane\n// description that yields the given Platonic solid (so for instance, the\n// cubical group and octahedral group are identical in math, but we\n// give distinct representations choosing the first quaternion so that\n// we get the desired figure.)  Our convention is one vertex of the\n// shape points precisely down.\n\n// This class is static.\n\nconst eps = 1e-9; // TODO: Deduplicate with `PuzzleGeometry`?\n\nexport function cube(): Quat[] {\n  const s5 = Math.sqrt(0.5);\n  return [new Quat(s5, s5, 0, 0), new Quat(s5, 0, s5, 0)];\n}\n\nexport function tetrahedron(): Quat[] {\n  return [new Quat(0.5, 0.5, 0.5, 0.5), new Quat(0.5, 0.5, 0.5, -0.5)];\n}\n\nexport function dodecahedron(): Quat[] {\n  const d36 = (2 * Math.PI) / 10;\n  let dx = 0.5 + 0.3 * Math.sqrt(5);\n  let dy = 0.5 + 0.1 * Math.sqrt(5);\n  const dd = Math.sqrt(dx * dx + dy * dy);\n  dx /= dd;\n  dy /= dd;\n  return [\n    new Quat(Math.cos(d36), dx * Math.sin(d36), dy * Math.sin(d36), 0),\n    new Quat(0.5, 0.5, 0.5, 0.5),\n  ];\n}\n\nexport function icosahedron(): Quat[] {\n  let dx = 1 / 6 + Math.sqrt(5) / 6;\n  let dy = 2 / 3 + Math.sqrt(5) / 3;\n  const dd = Math.sqrt(dx * dx + dy * dy);\n  dx /= dd;\n  dy /= dd;\n  const ang = (2 * Math.PI) / 6;\n  return [\n    new Quat(Math.cos(ang), dx * Math.sin(ang), dy * Math.sin(ang), 0),\n    new Quat(Math.cos(ang), -dx * Math.sin(ang), dy * Math.sin(ang), 0),\n  ];\n}\n\nexport function octahedron(): Quat[] {\n  const s5 = Math.sqrt(0.5);\n  return [new Quat(0.5, 0.5, 0.5, 0.5), new Quat(s5, 0, 0, s5)];\n}\n\nexport function closure(g: Quat[]): Quat[] {\n  // compute the closure of a set of generators\n  // This is quadratic in the result size.  Also, it has no protection\n  // against you providing a bogus set of generators that would generate\n  // an infinite group.\n  const q = [new Quat(1, 0, 0, 0)];\n  for (let i = 0; i < q.length; i++) {\n    for (let j = 0; j < g.length; j++) {\n      const ns = g[j].mul(q[i]);\n      const negns = ns.smul(-1);\n      let wasseen = false;\n      for (let k = 0; k < q.length; k++) {\n        if (ns.dist(q[k]) < eps || negns.dist(q[k]) < eps) {\n          wasseen = true;\n          break;\n        }\n      }\n      if (!wasseen) {\n        q.push(ns);\n      }\n    }\n  }\n  return q;\n}\n\nexport function uniqueplanes(p: Quat, g: Quat[]): Quat[] {\n  // compute unique plane rotations\n  // given a rotation group and a plane, find the rotations that\n  // generate unique planes.  This is quadratic in the return size.\n  const planes = [];\n  const planerot = [];\n  for (let i = 0; i < g.length; i++) {\n    const p2 = p.rotateplane(g[i]);\n    let wasseen = false;\n    for (let j = 0; j < planes.length; j++) {\n      if (p2.dist(planes[j]) < eps) {\n        wasseen = true;\n        break;\n      }\n    }\n    if (!wasseen) {\n      planes.push(p2);\n      planerot.push(g[i]);\n    }\n  }\n  return planerot;\n}\n\nexport function getface(planes: Quat[]): Quat[] {\n  // compute a face given a set of planes\n  // The face returned will be a set of points that lie in the first plane\n  // in the given array, that are on the surface of the polytope defined\n  // by all the planes, and will be returned in clockwise order.\n  // This is O(planes^2 * return size + return_size^2).\n  const face = [];\n  for (let i = 1; i < planes.length; i++) {\n    for (let j = i + 1; j < planes.length; j++) {\n      const p = solvethreeplanes(0, i, j, planes);\n      if (p) {\n        let wasseen = false;\n        for (let k = 0; k < face.length; k++) {\n          if (p.dist(face[k]) < eps) {\n            wasseen = true;\n            break;\n          }\n        }\n        if (!wasseen) {\n          face.push(p);\n        }\n      }\n    }\n  }\n  for (;;) {\n    let changed = false;\n    for (let i = 0; i < face.length; i++) {\n      const j: number = (i + 1) % face.length;\n      if (planes[0].dot(face[i].cross(face[j])) < 0) {\n        const t: Quat = face[i];\n        face[i] = face[j];\n        face[j] = t;\n        changed = true;\n      }\n    }\n    if (!changed) {\n      break;\n    }\n  }\n  return face;\n}\n", "export type PuzzleDescriptionString = string;\n\nexport const Puzzles: { [name: string]: PuzzleDescriptionString } = {\n  \"2x2x2\": \"c f 0\",\n  \"3x3x3\": \"c f 0.333333333333333\",\n  \"4x4x4\": \"c f 0.5 f 0\",\n  \"5x5x5\": \"c f 0.6 f 0.2\",\n  \"6x6x6\": \"c f 0.666666666666667 f 0.333333333333333 f 0\",\n  \"7x7x7\": \"c f 0.714285714285714 f 0.428571428571429 f 0.142857142857143\",\n  \"8x8x8\": \"c f 0.75 f 0.5 f 0.25 f 0\",\n  \"9x9x9\":\n    \"c f 0.777777777777778 f 0.555555555555556 f 0.333333333333333 f 0.111111111111111\",\n  \"10x10x10\": \"c f 0.8 f 0.6 f 0.4 f 0.2 f 0\",\n  \"11x11x11\":\n    \"c f 0.818181818181818 f 0.636363636363636 f 0.454545454545455 f 0.272727272727273 f 0.0909090909090909\",\n  \"12x12x12\":\n    \"c f 0.833333333333333 f 0.666666666666667 f 0.5 f 0.333333333333333 f 0.166666666666667 f 0\",\n  \"13x13x13\":\n    \"c f 0.846153846153846 f 0.692307692307692 f 0.538461538461538 f 0.384615384615385 f 0.230769230769231 f 0.0769230769230769\",\n  \"20x20x20\": \"c f 0 f .1 f .2 f .3 f .4 f .5 f .6 f .7 f .8 f .9\",\n  \"30x30x30\":\n    \"c f 0 f .066667 f .133333 f .2 f .266667 f .333333 f .4 f .466667 f .533333 f .6 f .666667 f .733333 f .8 f .866667 f .933333\",\n  \"skewb\": \"c v 0\",\n  \"master skewb\": \"c v 0.275\",\n  \"professor skewb\": \"c v 0 v 0.38\",\n  \"compy cube\": \"c v 0.915641442663986\",\n  \"helicopter\": \"c e 0.707106781186547\",\n  \"curvy copter\": \"c e 0.83\",\n  \"dino\": \"c v 0.577350269189626\",\n  \"little chop\": \"c e 0\",\n  \"pyramorphix\": \"t e 0\",\n  \"mastermorphix\": \"t e 0.346184634065199\",\n  \"pyraminx\": \"t v 0.333333333333333 v 1.66666666666667\",\n  \"master pyraminx\": \"t v 0 v 1 v 2\",\n  \"professor pyraminx\": \"t v -0.2 v 0.6 v 1.4 v 2.2\",\n  \"Jing pyraminx\": \"t f 0\",\n  \"master pyramorphix\": \"t e 0.866025403784437\",\n  \"megaminx\": \"d f 0.7\",\n  \"gigaminx\": \"d f 0.64 f 0.82\",\n  \"pentultimate\": \"d f 0\",\n  // exact value for starminx is sqrt(5(5-2 sqrt(5))/3)\n  \"starminx\": \"d v 0.937962370425399\",\n  \"starminx 2\": \"d f 0.23606797749979\",\n  \"pyraminx crystal\": \"d f 0.447213595499989\",\n  \"chopasaurus\": \"d v 0\",\n  \"big chop\": \"d e 0\",\n  \"skewb diamond\": \"o f 0\",\n  \"FTO\": \"o f 0.333333333333333\",\n  \"Christopher's jewel\": \"o v 0.577350269189626\",\n  \"octastar\": \"o e 0\",\n  \"Trajber's octahedron\": \"o v 0.433012701892219\",\n  \"radio chop\": \"i f 0\",\n  \"icosamate\": \"i v 0\",\n  \"icosahedron 2\": \"i v 0.18759247376021\",\n  \"icosahedron 3\": \"i v 0.18759247376021 e 0\",\n  \"icosahedron static faces\": \"i v 0.84\",\n  \"icosahedron moving faces\": \"i v 0.73\",\n  \"Eitan's star\": \"i f 0.61803398874989\",\n  \"2x2x2 + dino\": \"c f 0 v 0.577350269189626\",\n  \"2x2x2 + little chop\": \"c f 0 e 0\",\n  \"dino + little chop\": \"c v 0.577350269189626 e 0\",\n  \"2x2x2 + dino + little chop\": \"c f 0 v 0.577350269189626 e 0\",\n  \"megaminx + chopasaurus\": \"d f 0.61803398875 v 0\",\n  \"starminx combo\": \"d f 0.23606797749979 v 0.937962370425399\",\n};\n\nexport type PuzzleName = keyof typeof Puzzles;\n", "//   We don't want to introduce dependencies from alg or kpuzzle or other\n//   tools into puzzle geometry, but we do want to interoperate with them.\n//   This file contains interface declarations for some of the things we\n//   use interoperably.  These definitions are not identical to those in\n//   the corresponding classes but they are interoperable.\n\nexport class BlockMove {\n  public type: string = \"blockMove\";\n  public outerLayer?: number;\n  public innerLayer?: number;\n  constructor(\n    outerLayer: number | undefined,\n    innerLayer: number | undefined,\n    public family: string,\n    public amount: number = 1,\n  ) {\n    if (innerLayer) {\n      this.innerLayer = innerLayer;\n      if (outerLayer) {\n        this.outerLayer = outerLayer;\n      }\n    }\n    if (outerLayer && !innerLayer) {\n      throw new Error(\n        \"Attempted to contruct block move with outer layer but no inner layer\",\n      );\n    }\n  }\n}\n\nexport interface MoveNotation {\n  lookupMove(move: BlockMove): Transformation | undefined;\n}\n\nexport interface OrbitTransformation {\n  permutation: number[];\n  orientation: number[];\n}\n\nexport type Transformation = Record<string, OrbitTransformation>;\n\nexport interface OrbitDefinition {\n  numPieces: number;\n  orientations: number;\n}\n\nexport interface KPuzzleDefinition {\n  name: string;\n  orbits: { [key: string]: OrbitDefinition };\n  startPieces: Transformation;\n  moves: { [key: string]: Transformation };\n  svg?: string;\n  moveNotation?: MoveNotation;\n}\n", "import { FaceNameSwizzler } from \"./FaceNameSwizzler\";\nimport { BlockMove } from \"./interfaces\";\n\nexport interface NotationMapper {\n  notationToInternal(mv: BlockMove): BlockMove;\n  notationToExternal(mv: BlockMove): BlockMove;\n}\n\nexport class NullMapper implements NotationMapper {\n  public notationToInternal(mv: BlockMove): BlockMove {\n    return mv;\n  }\n\n  public notationToExternal(mv: BlockMove): BlockMove {\n    return mv;\n  }\n}\n\nexport class NxNxNCubeMapper implements NotationMapper {\n  constructor(public slices: number) {}\n\n  public notationToInternal(mv: BlockMove): BlockMove {\n    const grip = mv.family;\n    if (!mv.innerLayer && !mv.outerLayer) {\n      if (grip === \"x\") {\n        mv = new BlockMove(undefined, undefined, \"Rv\", mv.amount);\n      } else if (grip === \"y\") {\n        mv = new BlockMove(undefined, undefined, \"Uv\", mv.amount);\n      } else if (grip === \"z\") {\n        mv = new BlockMove(undefined, undefined, \"Fv\", mv.amount);\n      }\n      if ((this.slices & 1) === 1) {\n        if (grip === \"E\") {\n          mv = new BlockMove(undefined, (this.slices + 1) / 2, \"D\", mv.amount);\n        } else if (grip === \"M\") {\n          mv = new BlockMove(undefined, (this.slices + 1) / 2, \"L\", mv.amount);\n        } else if (grip === \"S\") {\n          mv = new BlockMove(undefined, (this.slices + 1) / 2, \"F\", mv.amount);\n        }\n      }\n      if (this.slices > 2) {\n        if (grip === \"e\") {\n          mv = new BlockMove(2, this.slices - 1, \"D\", mv.amount);\n        } else if (grip === \"m\") {\n          mv = new BlockMove(2, this.slices - 1, \"L\", mv.amount);\n        } else if (grip === \"s\") {\n          mv = new BlockMove(2, this.slices - 1, \"F\", mv.amount);\n        }\n      }\n    }\n    return mv;\n  }\n\n  // do we want to map slice moves to E/M/S instead of 2U/etc.?\n  public notationToExternal(mv: BlockMove): BlockMove {\n    const grip = mv.family;\n    if (!mv.innerLayer && !mv.outerLayer) {\n      if (grip === \"Rv\") {\n        return new BlockMove(undefined, undefined, \"x\", mv.amount);\n      } else if (grip === \"Uv\") {\n        return new BlockMove(undefined, undefined, \"y\", mv.amount);\n      } else if (grip === \"Fv\") {\n        return new BlockMove(undefined, undefined, \"z\", mv.amount);\n      } else if (grip === \"Lv\") {\n        return this.negate(\"x\", mv.amount);\n      } else if (grip === \"Dv\") {\n        return this.negate(\"y\", mv.amount);\n      } else if (grip === \"Bv\") {\n        return this.negate(\"z\", mv.amount);\n      }\n    }\n    return mv;\n  }\n\n  private negate(family: string, v: number | undefined): BlockMove {\n    if (v === undefined) {\n      v = -1;\n    } else if (v === -1) {\n      v = undefined;\n    } else {\n      v = -v;\n    }\n    return new BlockMove(undefined, undefined, family, v);\n  }\n}\n\n// face renaming mapper.  Accepts two face name remappers.  We\n// work between the two.\n\nexport class FaceRenamingMapper implements NotationMapper {\n  constructor(\n    public internalNames: FaceNameSwizzler,\n    public externalNames: FaceNameSwizzler,\n  ) {}\n\n  // TODO:  consider putting a cache in front of this\n  public convertString(\n    grip: string,\n    a: FaceNameSwizzler,\n    b: FaceNameSwizzler,\n  ): string {\n    let suffix = \"\";\n    if ((grip.endsWith(\"v\") || grip.endsWith(\"v\")) && grip <= \"_\") {\n      suffix = grip.slice(grip.length - 1);\n      grip = grip.slice(0, grip.length - 1);\n    }\n    const upper = grip.toUpperCase();\n    let isLowerCase = false;\n    if (grip !== upper) {\n      isLowerCase = true;\n      grip = upper;\n    }\n    grip = b.joinByFaceIndices(a.splitByFaceNames(grip));\n    if (isLowerCase) {\n      grip = grip.toLowerCase();\n    }\n    return grip + suffix;\n  }\n\n  public convert(\n    mv: BlockMove,\n    a: FaceNameSwizzler,\n    b: FaceNameSwizzler,\n  ): BlockMove {\n    const grip = mv.family;\n    const ngrip = this.convertString(grip, a, b);\n    if (grip === ngrip) {\n      return mv;\n    } else {\n      return new BlockMove(mv.outerLayer, mv.innerLayer, ngrip, mv.amount);\n    }\n  }\n\n  public notationToInternal(mv: BlockMove): BlockMove {\n    const r = this.convert(mv, this.externalNames, this.internalNames);\n    return r;\n  }\n\n  public notationToExternal(mv: BlockMove): BlockMove {\n    return this.convert(mv, this.internalNames, this.externalNames);\n  }\n}\n\n// Sits on top of a (possibly null) notation mapper, and\n// adds R++/R--/D++/D-- notation mapping.\nexport class MegaminxScramblingNotationMapper implements NotationMapper {\n  constructor(private child: NotationMapper) {}\n\n  public notationToInternal(mv: BlockMove): BlockMove {\n    if (\n      mv.innerLayer === undefined &&\n      mv.outerLayer === undefined &&\n      Math.abs(mv.amount) === 1\n    ) {\n      if (mv.family === \"R++\") {\n        return new BlockMove(2, 3, \"L\", -2 * mv.amount);\n      } else if (mv.family === \"R--\") {\n        return new BlockMove(2, 3, \"L\", 2 * mv.amount);\n      } else if (mv.family === \"D++\") {\n        return new BlockMove(2, 3, \"U\", -2 * mv.amount);\n      } else if (mv.family === \"D--\") {\n        return new BlockMove(2, 3, \"U\", 2 * mv.amount);\n      }\n    }\n    return this.child.notationToInternal(mv);\n  }\n\n  // we never rewrite click moves to these moves.\n  public notationToExternal(mv: BlockMove): BlockMove {\n    return this.child.notationToExternal(mv);\n  }\n}\n", "// Manages a set of face names.  Detects whether they are prefix-free.\n// Implements greedy splitting into face names and comparisons between\n// concatenated face names and grip names.\n\nexport class FaceNameSwizzler {\n  public prefixFree: boolean = true;\n  public gripnames: string[] = [];\n  constructor(public facenames: string[], gripnames_arg?: string[]) {\n    if (gripnames_arg) {\n      this.gripnames = gripnames_arg;\n    }\n    for (let i = 0; this.prefixFree && i < facenames.length; i++) {\n      for (let j = 0; this.prefixFree && j < facenames.length; j++) {\n        if (i !== j && facenames[i].startsWith(facenames[j])) {\n          this.prefixFree = false;\n        }\n      }\n    }\n  }\n\n  public setGripNames(names: string[]): void {\n    this.gripnames = names;\n  }\n\n  // split a string into face names and return a list of\n  // indices.\n  public splitByFaceNames(s: string): number[] {\n    const r = [];\n    let at = 0;\n    while (at < s.length) {\n      if (at > 0 && at < s.length && s[at] === \"_\") {\n        at++;\n      }\n      let currentMatch = -1;\n      for (let i = 0; i < this.facenames.length; i++) {\n        if (\n          s.substr(at).startsWith(this.facenames[i]) &&\n          (currentMatch < 0 ||\n            this.facenames[i].length > this.facenames[currentMatch].length)\n        ) {\n          currentMatch = i;\n        }\n      }\n      if (currentMatch >= 0) {\n        r.push(currentMatch);\n        at += this.facenames[currentMatch].length;\n      } else {\n        throw new Error(\"Could not split \" + s + \" into face names.\");\n      }\n    }\n    return r;\n  }\n\n  // cons a grip from an array of numbers.\n  public joinByFaceIndices(list: number[]): string {\n    let sep = \"\";\n    const r = [];\n    for (let i = 0; i < list.length; i++) {\n      r.push(sep);\n      r.push(this.facenames[list[i]]);\n      if (!this.prefixFree) {\n        sep = \"_\";\n      }\n    }\n    return r.join(\"\");\n  }\n\n  /*\n   *   Try to match something the user gave us with some geometric\n   *   feature.  We used to have strict requirements:\n   *\n   *      a)  The set of face names are prefix free\n   *      b)  When specifying a corner, all coincident planes were\n   *          specified\n   *\n   *   But, to allow megaminx to have more reasonable and\n   *   conventional names, and to permit shorter canonical\n   *   names, we are relaxing these requirements and adding\n   *   new syntax.  Now:\n   *\n   *      a)  Face names need not be syntax free.\n   *      b)  When parsing a geometric name, we use greedy\n   *          matching, so the longest name that matches the\n   *          user string at the current position is the one\n   *          assumed to match.\n   *      c)  Underscores are permitted to separate face names\n   *          (both in user input and in geometric\n   *          descriptions).\n   *      d)  Default names of corner moves where corners have\n   *          more than three corners, need only include three\n   *          of the corners.\n   *\n   *   This code is not performance-sensitive so we can do it a\n   *   slow and simple way.\n   */\n  public spinmatch(userinput: string, longname: string): boolean {\n    // are these the same rotationally?\n    if (userinput === longname) {\n      return true;\n    }\n    try {\n      const e1 = this.splitByFaceNames(userinput);\n      const e2 = this.splitByFaceNames(longname);\n      // All elements of userinput need to be in the longname.\n      // There should be no duplicate elements in the userinput.\n      // if both have length 1 or length 2, the sets must be equal.\n      // if both have length 3 or more, then the first set must be\n      // a subset of the second.  Order doesn't matter.\n      if (e1.length !== e2.length && e1.length < 3) {\n        return false;\n      }\n      for (let i = 0; i < e1.length; i++) {\n        for (let j = 0; j < i; j++) {\n          if (e1[i] === e1[j]) {\n            return false;\n          }\n        }\n        let found = false;\n        for (let j = 0; j < e2.length; j++) {\n          if (e1[i] === e2[j]) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          return false;\n        }\n      }\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  public unswizzle(s: string): string {\n    if ((s.endsWith(\"v\") || s.endsWith(\"w\")) && s[0] <= \"Z\") {\n      s = s.slice(0, s.length - 1);\n    }\n    const upperCaseGrip = s.toUpperCase();\n    for (let i = 0; i < this.gripnames.length; i++) {\n      const g = this.gripnames[i];\n      if (this.spinmatch(upperCaseGrip, g)) {\n        return g;\n      }\n    }\n    return s;\n  }\n}\n", "/* tslint:disable no-bitwise */\n/* tslint:disable prefer-for-of */ // TODO\n/* tslint:disable only-arrow-functions */ // TODO\n/* tslint:disable typedef */ // TODO\n\nimport { iota, zeros, Perm } from \"./Perm\";\nimport {\n  Orbit,\n  OrbitDef,\n  OrbitsDef,\n  showcanon,\n  Transformation,\n  VisibleState,\n} from \"./PermOriSet\";\nimport {\n  closure,\n  cube,\n  dodecahedron,\n  getface,\n  icosahedron,\n  octahedron,\n  tetrahedron,\n  uniqueplanes,\n} from \"./PlatonicGenerator\";\nimport { PuzzleDescriptionString, Puzzles, PuzzleName } from \"./Puzzles\";\nimport { centermassface, expandfaces, Quat } from \"./Quat\";\nimport {\n  BlockMove,\n  KPuzzleDefinition,\n  MoveNotation,\n  Transformation as KTransformation,\n} from \"./interfaces\";\nimport {\n  FaceRenamingMapper,\n  MegaminxScramblingNotationMapper,\n  NotationMapper,\n  NullMapper,\n  NxNxNCubeMapper,\n} from \"./NotationMapper\";\nimport { FaceNameSwizzler } from \"./FaceNameSwizzler\";\n\nconst DEFAULT_COLOR_FRACTION = 0.77;\n\nexport interface StickerDatSticker {\n  coords: number[][];\n  color: string;\n  orbit: string;\n  ord: number;\n  ori: number;\n}\n\nexport interface StickerDatFace {\n  coords: number[][];\n  name: string;\n}\n\nexport type StickerDatAxis = [number[], string, number];\n\nexport interface StickerDat {\n  stickers: StickerDatSticker[];\n  foundations: StickerDatSticker[];\n  faces: StickerDatFace[];\n  axis: StickerDatAxis[];\n  unswizzle(mv: BlockMove): string;\n  notationMapper: NotationMapper;\n}\n\n// TODO: Remove this once we no longer have prefix restrictions.\nlet NEW_FACE_NAMES = true;\nexport function useNewFaceNames(use: boolean): void {\n  NEW_FACE_NAMES = use;\n}\n\n//  Now we have a geometry class that does the 3D goemetry to calculate\n//  individual sticker information from a Platonic solid and a set of\n//  cuts.  The cuts must have the same symmetry as the Platonic solid;\n//  we even restrict them further to be either vertex-normal,\n//  edge-normal, or face-parallel cuts.  Right now our constructor takes\n//  a character solid indicator (one of c(ube), o(ctahedron), i(cosahedron),\n//  t(etradron), or d(odecahedron), followed by an array of cuts.\n//  Each cut is a character normal indicator that is either f(ace),\n//  e(dge), or v(ertex), followed by a floating point value that gives\n//  the depth of the cut where 0 is the center and 1 is the outside\n//  border of the shape in that direction.\n\n//  This is a heavyweight class with lots of members and construction\n//  is slow.  Be gentle.\n\n//  Everything except a very few methods should be considered private.\n\nconst eps: number = 1e-9;\nconst copyright = \"PuzzleGeometry 0.1 Copyright 2018 Tomas Rokicki.\";\nconst permissivieMoveParsing = false;\n\n// This is a description of the nets and the external names we give each\n// face.  The names should be a set of prefix-free upper-case alphabetics\n// so\n// we can easily also name and distinguish vertices and edges, but we\n// may change this in the future.  The nets consist of a list of lists.\n// Each list gives the name of a face, and then the names of the\n// faces connected to that face (in the net) in clockwise order.\n// The length of each list should be one more than the number of\n// edges in the regular polygon for that face.  All polygons must\n// have the same number of edges.\n// The first two faces in the first list must describe a horizontal edge\n// that is at the bottom of a regular polygon.  The first two faces in\n// every subsequent list for a given polytope must describe a edge that\n// is directly connected in the net and has already been described (this\n// sets the location and orientation of the polygon for that face.\n// Any edge that is not directly connected in the net should be given\n// the empty string as the other face.  All faces do not need to have\n// a list starting with that face; just enough to describe the full\n// connectivity of the net.\n//\n// TODO: change this back to a const JSON definition.\nfunction defaultnets(): any {\n  return {\n    // four faces: tetrahedron\n    4: [[\"F\", \"D\", \"L\", \"R\"]],\n    // six faces: cube\n    6: [\n      [\"F\", \"D\", \"L\", \"U\", \"R\"],\n      [\"R\", \"F\", \"\", \"B\", \"\"],\n    ],\n    // eight faces: octahedron\n    8: [\n      [\"F\", \"D\", \"L\", \"R\"],\n      [\"D\", \"F\", \"BR\", \"\"],\n      [\"BR\", \"D\", \"\", \"BB\"],\n      [\"BB\", \"BR\", \"U\", \"BL\"],\n    ],\n    // twelve faces:  dodecahedron; U/F/R/F/BL/BR from megaminx\n    12: [\n      [\"U\", \"F\", \"\", \"\", \"\", \"\"],\n      [\"F\", \"U\", \"R\", \"C\", \"A\", \"L\"],\n      [\"R\", \"F\", \"\", \"\", \"E\", \"\"],\n      [\"E\", \"R\", \"\", \"BF\", \"\", \"\"],\n      [\"BF\", \"E\", \"BR\", \"BL\", \"I\", \"D\"],\n    ],\n    // twenty faces: icosahedron\n    20: [\n      [\"R\", \"C\", \"F\", \"E\"],\n      [\"F\", \"R\", \"L\", \"U\"],\n      [\"L\", \"F\", \"A\", \"\"],\n      [\"E\", \"R\", \"G\", \"I\"],\n      [\"I\", \"E\", \"S\", \"H\"],\n      [\"S\", \"I\", \"J\", \"B\"],\n      [\"B\", \"S\", \"K\", \"D\"],\n      [\"K\", \"B\", \"M\", \"O\"],\n      [\"O\", \"K\", \"P\", \"N\"],\n      [\"P\", \"O\", \"Q\", \"\"],\n    ],\n  };\n}\n\n// TODO: change this back to a const JSON definition.\nfunction defaultcolors(): any {\n  return {\n    // the colors should use the same naming convention as the nets, above.\n    4: { F: \"#00ff00\", D: \"#ffff00\", L: \"#ff0000\", R: \"#0000ff\" },\n    6: {\n      U: \"#ffffff\",\n      F: \"#00ff00\",\n      R: \"#ff0000\",\n      D: \"#ffff00\",\n      B: \"#0000ff\",\n      L: \"#ff8000\",\n    },\n    8: {\n      U: \"#ffffff\",\n      F: \"#ff0000\",\n      R: \"#00bb00\",\n      D: \"#ffff00\",\n      BB: \"#1122ff\",\n      L: \"#9524c5\",\n      BL: \"#ff8800\",\n      BR: \"#aaaaaa\",\n    },\n    12: {\n      U: \"#ffffff\",\n      F: \"#006633\",\n      R: \"#ff0000\",\n      C: \"#ffffd0\",\n      A: \"#3399ff\",\n      L: \"#660099\",\n      E: \"#ff66cc\",\n      BF: \"#99ff00\",\n      BR: \"#0000ff\",\n      BL: \"#ffff00\",\n      I: \"#ff6633\",\n      D: \"#999999\",\n    },\n    20: {\n      R: \"#db69f0\",\n      C: \"#178fde\",\n      F: \"#23238b\",\n      E: \"#9cc726\",\n      L: \"#2c212d\",\n      U: \"#177fa7\",\n      A: \"#e0de7f\",\n      G: \"#2b57c0\",\n      I: \"#41126b\",\n      S: \"#4b8c28\",\n      H: \"#7c098d\",\n      J: \"#7fe7b4\",\n      B: \"#85fb74\",\n      K: \"#3f4bc3\",\n      D: \"#0ff555\",\n      M: \"#f1c2c8\",\n      O: \"#58d340\",\n      P: \"#c514f2\",\n      N: \"#14494e\",\n      Q: \"#8b1be1\",\n    },\n  };\n}\n\n// the default precedence of the faces is given here.  This permits\n// the orientations to be reasonably predictable.  There are tradeoffs;\n// some face precedence orders do better things to the edge orientations\n// than the corner orientations and some are the opposite.\n// TODO: change this back to a const JSON definition.\nfunction defaultfaceorders(): any {\n  return {\n    4: [\"F\", \"D\", \"L\", \"R\"],\n    6: [\"U\", \"D\", \"F\", \"B\", \"L\", \"R\"],\n    8: [\"F\", \"BB\", \"D\", \"U\", \"BR\", \"L\", \"R\", \"BL\"],\n    12: [\"L\", \"E\", \"F\", \"BF\", \"R\", \"I\", \"U\", \"D\", \"BR\", \"A\", \"BL\", \"C\"],\n    20: [\n      \"L\",\n      \"S\",\n      \"E\",\n      \"O\",\n      \"F\",\n      \"B\",\n      \"I\",\n      \"P\",\n      \"R\",\n      \"K\",\n      \"U\",\n      \"D\",\n      \"J\",\n      \"A\",\n      \"Q\",\n      \"H\",\n      \"G\",\n      \"N\",\n      \"M\",\n      \"C\",\n    ],\n  };\n}\n\n/*\n *  Default orientations for the puzzles in 3D space.  Can be overridden\n *  by puzzleOrientation or puzzleOrientations options.\n *\n *  These are defined to have a strong intuitive vertical (y) direction\n *  since 3D orbital controls need this.  In comments, we list the\n *  preferred initial camera orientation for each puzzle for twizzle;\n *  this information is explicitly given in the twizzle app file.\n */\n// TODO: change this back to a const JSON definition.\nfunction defaultOrientations(): any {\n  return {\n    4: [\"FLR\", [0, 1, 0], \"F\", [0, 0, 1]], // FLR towards viewer\n    6: [\"U\", [0, 1, 0], \"F\", [0, 0, 1]], // URF towards viewer\n    8: [\"U\", [0, 1, 0], \"F\", [0, 0, 1]], // FLUR towards viewer\n    12: [\"U\", [0, 1, 0], \"F\", [0, 0, 1]], // F towards viewer\n    20: [\"GUQMJ\", [0, 1, 0], \"F\", [0, 0, 1]], // F towards viewer\n  };\n}\n\nfunction findelement(a: any[], p: Quat): number {\n  // find something in facenames, vertexnames, edgenames\n  for (let i = 0; i < a.length; i++) {\n    if (a[i][0].dist(p) < eps) {\n      return i;\n    }\n  }\n  throw new Error(\"Element not found\");\n}\n\nexport function getpuzzles(): { [s: string]: PuzzleDescriptionString } {\n  // get some simple definitions of basic puzzles\n  return Puzzles;\n}\n\nexport function getpuzzle(puzzleName: PuzzleName): PuzzleDescriptionString {\n  // get some simple definitions of basic puzzles\n  return Puzzles[puzzleName];\n}\n\nexport function parsedesc(s: string): any {\n  // parse a text description\n  const a = s.split(/ /).filter(Boolean);\n  if (a.length % 2 === 0) {\n    return false;\n  }\n  if (\n    a[0] !== \"o\" &&\n    a[0] !== \"c\" &&\n    a[0] !== \"i\" &&\n    a[0] !== \"d\" &&\n    a[0] !== \"t\"\n  ) {\n    return false;\n  }\n  const r = [];\n  for (let i = 1; i < a.length; i += 2) {\n    if (a[i] !== \"f\" && a[i] !== \"v\" && a[i] !== \"e\") {\n      return false;\n    }\n    r.push([a[i], a[i + 1]]);\n  }\n  return [a[0], r];\n}\n\nexport function getPuzzleGeometryByDesc(\n  desc: string,\n  options: string[] = [],\n): PuzzleGeometry {\n  const [shape, cuts] = parsedesc(desc);\n  const pg = new PuzzleGeometry(\n    shape,\n    cuts,\n    [\"allmoves\", \"true\"].concat(options),\n  );\n  pg.allstickers();\n  pg.genperms();\n  return pg;\n}\n\nexport function getPuzzleGeometryByName(\n  puzzleName: PuzzleName,\n  options: string[] = [],\n): PuzzleGeometry {\n  return getPuzzleGeometryByDesc(Puzzles[puzzleName], options);\n}\n\nfunction getmovename(geo: any, bits: number, slices: number): any {\n  // generate a move name based on bits, slice, and geo\n  // if the move name is from the opposite face, say so.\n  // find the face that's turned.\n  let nbits = 0;\n  let inverted = false;\n  for (let i = 0; i <= slices; i++) {\n    if ((bits >> i) & 1) {\n      nbits |= 1 << (slices - i);\n    }\n  }\n  if (nbits < bits) {\n    // flip if most of the move is on the other side\n    geo = [geo[2], geo[3], geo[0], geo[1]];\n    bits = nbits;\n    inverted = true;\n  }\n  let movenameFamily = geo[0];\n  let movenamePrefix = \"\";\n  let hibit = 0;\n  while (bits >> (1 + hibit)) {\n    hibit++;\n  }\n  if (bits === (2 << slices) - 1) {\n    movenameFamily = movenameFamily + \"v\";\n  } else if (bits === 1 << hibit) {\n    if (hibit > 0) {\n      movenamePrefix = String(hibit + 1);\n    }\n  } else if (bits === (2 << hibit) - 1) {\n    movenameFamily = movenameFamily.toLowerCase();\n    if (hibit > 1) {\n      movenamePrefix = String(hibit + 1);\n    }\n  } else {\n    movenamePrefix = \"_\" + bits + \"_\";\n    //       throw \"We only support slice and outer block moves right now. \" + bits ;\n  }\n  return [movenamePrefix + movenameFamily, inverted];\n}\n\n// split a geometrical element into face names.  Do greedy match.\n// Permit underscores between names.\nfunction splitByFaceNames(s: string, facenames: any[]): string[] {\n  const r: string[] = [];\n  let at = 0;\n  while (at < s.length) {\n    if (at > 0 && at < s.length && s[at] === \"_\") {\n      at++;\n    }\n    let currentMatch = \"\";\n    for (let i = 0; i < facenames.length; i++) {\n      if (\n        s.substr(at).startsWith(facenames[i][1]) &&\n        facenames[i][1].length > currentMatch.length\n      ) {\n        currentMatch = facenames[i][1];\n      }\n    }\n    if (currentMatch !== \"\") {\n      r.push(currentMatch);\n      at += currentMatch.length;\n    } else {\n      throw new Error(\"Could not split \" + s + \" into face names.\");\n    }\n  }\n  return r;\n}\n\nfunction toCoords(q: Quat, maxdist: number): number[] {\n  return [q.b / maxdist, -q.c / maxdist, q.d / maxdist];\n}\n\nfunction toFaceCoords(q: Quat[], maxdist: number): number[][] {\n  const r = [];\n  const n = q.length;\n  for (let i = 0; i < n; i++) {\n    r[n - i - 1] = toCoords(q[i], maxdist);\n  }\n  return r;\n}\n\nfunction trimEdges(face: Quat[], tr: number): Quat[] {\n  const r: Quat[] = [];\n  for (let iter = 1; iter < 10; iter++) {\n    for (let i = 0; i < face.length; i++) {\n      const pi = (i + face.length - 1) % face.length;\n      const ni = (i + 1) % face.length;\n      const A = face[pi].sub(face[i]).normalize();\n      const B = face[ni].sub(face[i]).normalize();\n      const d = A.dot(B);\n      const m = tr / Math.sqrt(1 - d * d);\n      r[i] = face[i].sum(A.sum(B).smul(m));\n    }\n    let good = true;\n    for (let i = 0; good && i < r.length; i++) {\n      const pi = (i + face.length - 1) % face.length;\n      const ni = (i + 1) % face.length;\n      if (r[pi].sub(r[i]).cross(r[ni].sub(r[i])).dot(r[i]) >= 0) {\n        good = false;\n      }\n    }\n    if (good) {\n      return r;\n    }\n    tr /= 2;\n  }\n  return face;\n}\n\nexport class PuzzleGeometry {\n  public args: string = \"\";\n  public rotations: Quat[]; // all members of the rotation group\n  public baseplanerot: Quat[]; // unique rotations of the baseplane\n  public baseplanes: Quat[]; // planes, corresponding to faces\n  public facenames: any[]; // face names\n  public faceplanes: any; // face planes\n  public edgenames: any[]; // edge names\n  public vertexnames: any[]; // vertexnames\n  public geonormals: any[]; // all geometric directions, with names and types\n  public moveplanes: Quat[]; // the planes that split moves\n  public moveplanes2: Quat[]; // the planes that split moves, filtered\n  public moveplanesets: any[]; // the move planes, in parallel sets\n  public moveplanenormals: Quat[]; // one move plane\n  public movesetorders: any[]; // the order of rotations for each move set\n  public movesetgeos: any[]; // geometric feature information for move sets\n  public basefaces: Quat[][]; // polytope faces before cuts\n  public faces: Quat[][]; // all the stickers\n  public basefacecount: number; // number of base faces\n  public stickersperface: number; // number of stickers per face\n  public cornerfaces: number; // number of faces that meet at a corner\n  public cubies: any[]; // the cubies\n  public shortedge: number; // shortest edge\n  public vertexdistance: number; // vertex distance\n  public edgedistance: number; // edge distance\n  public orbits: number; // count of cubie orbits\n  public facetocubies: any[]; // map a face to a cubie index and offset\n  public moverotations: Quat[][]; // move rotations\n  public cubiekey: any; // cubie locator\n  public cubiekeys: string[]; // cubie keys\n  public facelisthash: any; // face list by key\n  public cubiesetnames: any[]; // cubie set names\n  public cubieords: number[]; // the size of each orbit\n  public cubiesetnums: number[];\n  public cubieordnums: number[];\n  public orbitoris: number[]; // the orientation size of each orbit\n  public cubievaluemap: number[]; // the map for identical cubies\n  public cubiesetcubies: number[][]; // cubies in each cubie set\n  public cmovesbyslice: number[][][] = []; // cmoves as perms by slice\n  // options\n  public verbose: number = 0; // verbosity (console.log)\n  public allmoves: boolean = false; // generate all slice moves in ksolve\n  public outerblockmoves: boolean; // generate outer block moves\n  public vertexmoves: boolean; // generate vertex moves\n  public addrotations: boolean; // add symmetry information to ksolve output\n  public movelist: any; // move list to generate\n  public parsedmovelist: any; // parsed move list\n  public puzzleOrientation: any; // single puzzle orientation from options\n  public puzzleOrientations: any; // puzzle orientation override list from options\n  public cornersets: boolean = true; // include corner sets\n  public centersets: boolean = true; // include center sets\n  public edgesets: boolean = true; // include edge sets\n  public graycorners: boolean = false; // make corner sets gray\n  public graycenters: boolean = false; // make center sets gray\n  public grayedges: boolean = false; // make edge sets gray\n  public killorientation: boolean = false; // eliminate any orientations\n  public optimize: boolean = false; // optimize PermOri\n  public scramble: number = 0; // scramble?\n  public ksolvemovenames: string[]; // move names from ksolve\n  public fixPiece: string = \"\"; // fix a piece?\n  public orientCenters: boolean = false; // orient centers?\n  public duplicatedFaces: number[] = []; // which faces are duplicated\n  public duplicatedCubies: number[] = []; // which cubies are duplicated\n  public fixedCubie: number = -1; // fixed cubie, if any\n  public svggrips: any[]; // grips from svg generation by svg coordinate\n  public net: any = [];\n  public colors: any = [];\n  public faceorder: any = [];\n  public faceprecedence: number[] = [];\n  public swizzler: FaceNameSwizzler;\n  public notationMapper: NotationMapper = new NullMapper();\n  public addNotationMapper: string = \"\";\n  constructor(shape: string, cuts: string[][], optionlist: any[] | undefined) {\n    function asstructured(v: any): any {\n      if (typeof v === \"string\") {\n        return JSON.parse(v);\n      }\n      return v;\n    }\n    function asboolean(v: any): boolean {\n      if (typeof v === \"string\") {\n        if (v === \"false\") {\n          return false;\n        }\n        return true;\n      } else {\n        return v ? true : false;\n      }\n    }\n    if (optionlist !== undefined) {\n      if (optionlist.length % 2 !== 0) {\n        throw new Error(\"Odd length in option list?\");\n      }\n      for (let i = 0; i < optionlist.length; i += 2) {\n        if (optionlist[i] === \"verbose\") {\n          this.verbose++;\n        } else if (optionlist[i] === \"quiet\") {\n          this.verbose = 0;\n        } else if (optionlist[i] === \"allmoves\") {\n          this.allmoves = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"outerblockmoves\") {\n          this.outerblockmoves = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"vertexmoves\") {\n          this.vertexmoves = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"rotations\") {\n          this.addrotations = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"cornersets\") {\n          this.cornersets = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"centersets\") {\n          this.centersets = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"edgesets\") {\n          this.edgesets = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"graycorners\") {\n          this.graycorners = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"graycenters\") {\n          this.graycenters = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"grayedges\") {\n          this.grayedges = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"movelist\") {\n          this.movelist = asstructured(optionlist[i + 1]);\n        } else if (optionlist[i] === \"killorientation\") {\n          this.killorientation = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"optimize\") {\n          this.optimize = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"scramble\") {\n          this.scramble = optionlist[i + 1];\n        } else if (optionlist[i] === \"fix\") {\n          this.fixPiece = optionlist[i + 1];\n        } else if (optionlist[i] === \"orientcenters\") {\n          this.orientCenters = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"puzzleorientation\") {\n          this.puzzleOrientation = asstructured(optionlist[i + 1]);\n        } else if (optionlist[i] === \"puzzleorientations\") {\n          this.puzzleOrientations = asstructured(optionlist[i + 1]);\n        } else {\n          throw new Error(\n            \"Bad option while processing option list \" + optionlist[i],\n          );\n        }\n      }\n    }\n    this.args = shape + \" \" + cuts.map((_) => _.join(\" \")).join(\" \");\n    if (optionlist) {\n      this.args += \" \" + optionlist.join(\" \");\n    }\n    if (this.verbose > 0) {\n      console.log(this.header(\"# \"));\n    }\n    this.create(shape, cuts);\n  }\n\n  public create(shape: string, cuts: any[]): void {\n    // create the shape, doing all the essential geometry\n    // create only goes far enough to figure out how many stickers per\n    // face, and what the short edge is.  If the short edge is too short,\n    // we probably don't want to display or manipulate this one.  How\n    // short is too short is hard to say.\n    // var that = this ; // TODO\n    this.moveplanes = [];\n    this.moveplanes2 = [];\n    this.faces = [];\n    this.cubies = [];\n    let g = null;\n    switch (shape) {\n      case \"c\":\n        g = cube();\n        break;\n      case \"o\":\n        g = octahedron();\n        break;\n      case \"i\":\n        g = icosahedron();\n        break;\n      case \"t\":\n        g = tetrahedron();\n        break;\n      case \"d\":\n        g = dodecahedron();\n        break;\n      default:\n        throw new Error(\"Bad shape argument: \" + shape);\n    }\n    this.rotations = closure(g);\n    if (this.verbose) {\n      console.log(\"# Rotations: \" + this.rotations.length);\n    }\n    const baseplane = g[0];\n    this.baseplanerot = uniqueplanes(baseplane, this.rotations);\n    const baseplanes = this.baseplanerot.map((_) => baseplane.rotateplane(_));\n    this.baseplanes = baseplanes;\n    this.basefacecount = baseplanes.length;\n    const net = defaultnets()[baseplanes.length];\n    this.net = net;\n    this.colors = defaultcolors()[baseplanes.length];\n    this.faceorder = defaultfaceorders()[baseplanes.length];\n    if (this.verbose) {\n      console.log(\"# Base planes: \" + baseplanes.length);\n    }\n    const baseface = getface(baseplanes);\n    const zero = new Quat(0, 0, 0, 0);\n    if (this.verbose) {\n      console.log(\"# Face vertices: \" + baseface.length);\n    }\n    const facenormal = baseplanes[0].makenormal();\n    const edgenormal = baseface[0].sum(baseface[1]).makenormal();\n    const vertexnormal = baseface[0].makenormal();\n    const boundary = new Quat(1, facenormal.b, facenormal.c, facenormal.d);\n    if (this.verbose) {\n      console.log(\"# Boundary is \" + boundary);\n    }\n    const planerot = uniqueplanes(boundary, this.rotations);\n    const planes = planerot.map((_) => boundary.rotateplane(_));\n    let faces = [getface(planes)];\n    this.edgedistance = faces[0][0].sum(faces[0][1]).smul(0.5).dist(zero);\n    this.vertexdistance = faces[0][0].dist(zero);\n    const cutplanes = [];\n    const intersects = [];\n    let sawface = false; // what cuts did we see?\n    let sawedge = false;\n    let sawvertex = false;\n    for (let i = 0; i < cuts.length; i++) {\n      let normal = null;\n      let distance = 0;\n      switch (cuts[i][0]) {\n        case \"f\":\n          normal = facenormal;\n          distance = 1;\n          sawface = true;\n          break;\n        case \"v\":\n          normal = vertexnormal;\n          distance = this.vertexdistance;\n          sawvertex = true;\n          break;\n        case \"e\":\n          normal = edgenormal;\n          distance = this.edgedistance;\n          sawedge = true;\n          break;\n        default:\n          throw new Error(\"Bad cut argument: \" + cuts[i][0]);\n      }\n      cutplanes.push(normal.makecut(cuts[i][1]));\n      intersects.push(cuts[i][1] < distance);\n    }\n    if (this.addrotations) {\n      if (!sawface) {\n        cutplanes.push(facenormal.makecut(10));\n      }\n      if (!sawvertex) {\n        cutplanes.push(vertexnormal.makecut(10));\n      }\n      if (!sawedge) {\n        cutplanes.push(edgenormal.makecut(10));\n      }\n    }\n    this.basefaces = [];\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(faces[0]);\n      this.basefaces.push(face);\n    }\n    //\n    //   Determine names for edges, vertices, and planes.  Planes are defined\n    //   by the plane normal/distance; edges are defined by the midpoint;\n    //   vertices are defined by actual point.  In each case we define a name.\n    //   Note that edges have two potential names, and corners have n where\n    //   n planes meet at a vertex.  We arbitrarily choose the one that is\n    //   alphabetically first (and we will probably want to change this).\n    //\n    const facenames: any[] = [];\n    const faceplanes = [];\n    const vertexnames: any[] = [];\n    const edgenames: any[] = [];\n    const edgesperface = faces[0].length;\n    function searchaddelement(a: any[], p: Quat, name: any): void {\n      for (let i = 0; i < a.length; i++) {\n        if (a[i][0].dist(p) < eps) {\n          a[i].push(name);\n          return;\n        }\n      }\n      a.push([p, name]);\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(faces[0]);\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        searchaddelement(edgenames, midpoint, i);\n      }\n    }\n    const otherfaces = [];\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(faces[0]);\n      const facelist = [];\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        const el = edgenames[findelement(edgenames, midpoint)];\n        if (i === el[1]) {\n          facelist.push(el[2]);\n        } else if (i === el[2]) {\n          facelist.push(el[1]);\n        } else {\n          throw new Error(\"Could not find edge\");\n        }\n      }\n      otherfaces.push(facelist);\n    }\n    const facenametoindex: any = {};\n    const faceindextoname: any = [];\n    faceindextoname.push(net[0][0]);\n    facenametoindex[net[0][0]] = 0;\n    faceindextoname[otherfaces[0][0]] = net[0][1];\n    facenametoindex[net[0][1]] = otherfaces[0][0];\n    for (let i = 0; i < net.length; i++) {\n      const f0 = net[i][0];\n      const fi = facenametoindex[f0];\n      if (fi === undefined) {\n        throw new Error(\"Bad edge description; first edge not connected\");\n      }\n      let ii = -1;\n      for (let j = 0; j < otherfaces[fi].length; j++) {\n        const fn2 = faceindextoname[otherfaces[fi][j]];\n        if (fn2 !== undefined && fn2 === net[i][1]) {\n          ii = j;\n          break;\n        }\n      }\n      if (ii < 0) {\n        throw new Error(\"First element of a net not known\");\n      }\n      for (let j = 2; j < net[i].length; j++) {\n        if (net[i][j] === \"\") {\n          continue;\n        }\n        const of = otherfaces[fi][(j + ii - 1) % edgesperface];\n        const fn2 = faceindextoname[of];\n        if (fn2 !== undefined && fn2 !== net[i][j]) {\n          throw new Error(\"Face mismatch in net\");\n        }\n        faceindextoname[of] = net[i][j];\n        facenametoindex[net[i][j]] = of;\n      }\n    }\n    for (let i = 0; i < faceindextoname.length; i++) {\n      let found = false;\n      for (let j = 0; j < this.faceorder.length; j++) {\n        if (faceindextoname[i] === this.faceorder[j]) {\n          this.faceprecedence[i] = j;\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        throw new Error(\n          \"Could not find face \" +\n            faceindextoname[i] +\n            \" in face order list \" +\n            this.faceorder,\n        );\n      }\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(faces[0]);\n      const faceplane = boundary.rotateplane(this.baseplanerot[i]);\n      const facename = faceindextoname[i];\n      facenames.push([face, facename]);\n      faceplanes.push([faceplane, facename]);\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(faces[0]);\n      const facename = faceindextoname[i];\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        const jjj = (j + 2) % face.length;\n        const midpoint2 = face[jj].sum(face[jjj]).smul(0.5);\n        const e1 = findelement(edgenames, midpoint);\n        const e2 = findelement(edgenames, midpoint2);\n        searchaddelement(vertexnames, face[jj], [facename, e2, e1]);\n      }\n    }\n    this.swizzler = new FaceNameSwizzler(facenames.map((_: any) => _[1]));\n    const sep = this.swizzler.prefixFree ? \"\" : \"_\";\n    // fix the edge names; use face precedence order\n    for (let i = 0; i < edgenames.length; i++) {\n      if (edgenames[i].length !== 3) {\n        throw new Error(\"Bad length in edge names \" + edgenames[i]);\n      }\n      let c1 = faceindextoname[edgenames[i][1]];\n      const c2 = faceindextoname[edgenames[i][2]];\n      if (\n        this.faceprecedence[edgenames[i][1]] <\n        this.faceprecedence[edgenames[i][2]]\n      ) {\n        c1 = c1 + sep + c2;\n      } else {\n        c1 = c2 + sep + c1;\n      }\n      edgenames[i] = [edgenames[i][0], c1];\n    }\n    // fix the vertex names; clockwise rotations; low face first.\n    this.cornerfaces = vertexnames[0].length - 1;\n    for (let i = 0; i < vertexnames.length; i++) {\n      if (vertexnames[i].length < 4) {\n        throw new Error(\"Bad length in vertex names\");\n      }\n      let st = 1;\n      for (let j = 2; j < vertexnames[i].length; j++) {\n        if (\n          this.faceprecedence[facenametoindex[vertexnames[i][j][0]]] <\n          this.faceprecedence[facenametoindex[vertexnames[i][st][0]]]\n        ) {\n          st = j;\n        }\n      }\n      let r = \"\";\n      for (let j = 1; j < vertexnames[i].length; j++) {\n        if (j === 1) {\n          r = vertexnames[i][st][0];\n        } else {\n          r = r + sep + vertexnames[i][st][0];\n        }\n        for (let k = 1; k < vertexnames[i].length; k++) {\n          if (vertexnames[i][st][2] === vertexnames[i][k][1]) {\n            st = k;\n            break;\n          }\n        }\n      }\n      vertexnames[i] = [vertexnames[i][0], r];\n    }\n    if (this.verbose > 1) {\n      console.log(\"Face precedence list: \" + this.faceorder.join(\" \"));\n      console.log(\"Face names: \" + facenames.map((_: any) => _[1]).join(\" \"));\n      console.log(\"Edge names: \" + edgenames.map((_: any) => _[1]).join(\" \"));\n      console.log(\n        \"Vertex names: \" + vertexnames.map((_: any) => _[1]).join(\" \"),\n      );\n    }\n    const geonormals = [];\n    for (let i = 0; i < faceplanes.length; i++) {\n      geonormals.push([faceplanes[i][0].makenormal(), faceplanes[i][1], \"f\"]);\n    }\n    for (let i = 0; i < edgenames.length; i++) {\n      geonormals.push([edgenames[i][0].makenormal(), edgenames[i][1], \"e\"]);\n    }\n    for (let i = 0; i < vertexnames.length; i++) {\n      geonormals.push([vertexnames[i][0].makenormal(), vertexnames[i][1], \"v\"]);\n    }\n    this.facenames = facenames;\n    this.faceplanes = faceplanes;\n    this.edgenames = edgenames;\n    this.vertexnames = vertexnames;\n    this.geonormals = geonormals;\n    const geonormalnames = geonormals.map((_: any) => _[1]);\n    this.swizzler.setGripNames(geonormalnames);\n    if (this.verbose) {\n      console.log(\n        \"# Distances: face \" +\n          1 +\n          \" edge \" +\n          this.edgedistance +\n          \" vertex \" +\n          this.vertexdistance,\n      );\n    }\n    // expand cutplanes by rotations.  We only work with one face here.\n    for (let c = 0; c < cutplanes.length; c++) {\n      for (let i = 0; i < this.rotations.length; i++) {\n        const q = cutplanes[c].rotateplane(this.rotations[i]);\n        let wasseen = false;\n        for (let j = 0; j < this.moveplanes.length; j++) {\n          if (q.sameplane(this.moveplanes[j])) {\n            wasseen = true;\n            break;\n          }\n        }\n        if (!wasseen) {\n          this.moveplanes.push(q);\n          faces = q.cutfaces(faces);\n          if (intersects[c]) {\n            this.moveplanes2.push(q);\n          }\n        }\n      }\n    }\n    this.faces = faces;\n    if (this.verbose) {\n      console.log(\"# Faces is now \" + faces.length);\n    }\n    this.stickersperface = faces.length;\n    //  Find and report the shortest edge in any of the faces.  If this\n    //  is small the puzzle is probably not practical or displayable.\n    let shortedge = 1e99;\n    for (let i = 0; i < faces.length; i++) {\n      for (let j = 0; j < faces[i].length; j++) {\n        const k = (j + 1) % faces[i].length;\n        const t = faces[i][j].dist(faces[i][k]);\n        if (t < shortedge) {\n          shortedge = t;\n        }\n      }\n    }\n    this.shortedge = shortedge;\n    if (this.verbose) {\n      console.log(\"# Short edge is \" + shortedge);\n    }\n    // add nxnxn cube notation if it has cube face moves\n    if (shape === \"c\" && sawface) {\n      // In this case the mapper adding is deferred until we\n      // know the number of slices.\n      this.addNotationMapper = \"NxNxNCubeMapper\";\n    }\n    if (shape === \"o\" && sawface && NEW_FACE_NAMES) {\n      this.notationMapper = new FaceRenamingMapper(\n        this.swizzler,\n        new FaceNameSwizzler([\"F\", \"D\", \"L\", \"BL\", \"R\", \"U\", \"BR\", \"B\"]),\n      );\n    }\n    if (shape === \"d\" && sawface && NEW_FACE_NAMES) {\n      this.addNotationMapper = \"Megaminx\";\n      this.notationMapper = new FaceRenamingMapper(\n        this.swizzler,\n        new FaceNameSwizzler([\n          \"U\",\n          \"F\",\n          \"L\",\n          \"BL\",\n          \"BR\",\n          \"R\",\n          \"FR\",\n          \"FL\",\n          \"DL\",\n          \"B\",\n          \"DR\",\n          \"D\",\n        ]),\n      );\n    }\n  }\n\n  public keyface(face: Quat[]): string {\n    // take a face and figure out the sides of each move plane\n    let s = \"\";\n    for (let i = 0; i < this.moveplanesets.length; i++) {\n      let t = 0;\n      for (let j = 0; j < this.moveplanesets[i].length; j++) {\n        if (this.moveplanesets[i][j].faceside(face) > 0) {\n          t++;\n        }\n      }\n      s = s + \" \" + t;\n    }\n    return s;\n  }\n\n  public findcubie(face: Quat[]): number {\n    return this.facetocubies[this.findface(face)][0];\n  }\n\n  public findface(face: Quat[]): number {\n    const cm = centermassface(face);\n    const key = this.keyface(face);\n    for (let i = 0; i < this.facelisthash[key].length; i++) {\n      const face2 = this.facelisthash[key][i];\n      if (Math.abs(cm.dist(centermassface(this.faces[face2]))) < eps) {\n        return face2;\n      }\n    }\n    throw new Error(\"Could not find face.\");\n  }\n\n  public project2d(facen: number, edgen: number, targvec: Quat[]): any {\n    // calculate geometry to map a particular edge of a particular\n    //  face to a given 2D vector.  The face is given as an index into the\n    //  facenames/baseplane arrays, and the edge is given as an offset into\n    //  the vertices.\n    const face = this.facenames[facen][0];\n    const edgen2 = (edgen + 1) % face.length;\n    const plane = this.baseplanes[facen];\n    let x0 = face[edgen2].sub(face[edgen]);\n    const olen = x0.len();\n    x0 = x0.normalize();\n    const y0 = x0.cross(plane).normalize();\n    let delta = targvec[1].sub(targvec[0]);\n    const len = delta.len() / olen;\n    delta = delta.normalize();\n    const cosr = delta.b;\n    const sinr = delta.c;\n    const x1 = x0.smul(cosr).sub(y0.smul(sinr)).smul(len);\n    const y1 = y0.smul(cosr).sum(x0.smul(sinr)).smul(len);\n    const off = new Quat(\n      0,\n      targvec[0].b - x1.dot(face[edgen]),\n      targvec[0].c - y1.dot(face[edgen]),\n      0,\n    );\n    return [x1, y1, off];\n  }\n\n  public allstickers(): void {\n    // next step is to calculate all the stickers and orbits\n    // We do enough work here to display the cube on the screen.\n    // take our newly split base face and expand it by the rotation matrix.\n    // this generates our full set of \"stickers\".\n    this.faces = expandfaces(this.baseplanerot, this.faces);\n    if (this.verbose) {\n      console.log(\"# Total stickers is now \" + this.faces.length);\n    }\n    // Split moveplanes into a list of parallel planes.\n    const moveplanesets: Quat[][] = [];\n    const moveplanenormals: Quat[] = [];\n    // get the normals, first, from unfiltered moveplanes.\n    for (let i = 0; i < this.moveplanes.length; i++) {\n      const q = this.moveplanes[i];\n      const qnormal = q.makenormal();\n      let wasseen = false;\n      for (let j = 0; j < moveplanenormals.length; j++) {\n        if (qnormal.sameplane(moveplanenormals[j].makenormal())) {\n          wasseen = true;\n        }\n      }\n      if (!wasseen) {\n        moveplanenormals.push(qnormal);\n        moveplanesets.push([]);\n      }\n    }\n    for (let i = 0; i < this.moveplanes2.length; i++) {\n      const q = this.moveplanes2[i];\n      const qnormal = q.makenormal();\n      for (let j = 0; j < moveplanenormals.length; j++) {\n        if (qnormal.sameplane(moveplanenormals[j])) {\n          moveplanesets[j].push(q);\n          break;\n        }\n      }\n    }\n    // make the normals all face the same way in each set.\n    for (let i = 0; i < moveplanesets.length; i++) {\n      const q: Quat[] = moveplanesets[i].map((_) => _.normalizeplane());\n      const goodnormal = moveplanenormals[i];\n      for (let j = 0; j < q.length; j++) {\n        if (q[j].makenormal().dist(goodnormal) > eps) {\n          q[j] = q[j].smul(-1);\n        }\n      }\n      q.sort((a, b) => a.a - b.a);\n      moveplanesets[i] = q;\n    }\n    this.moveplanesets = moveplanesets;\n    this.moveplanenormals = moveplanenormals;\n    const sizes = moveplanesets.map((_) => _.length);\n    if (this.verbose) {\n      console.log(\"# Move plane sets: \" + sizes);\n    }\n    // for each of the move planes, find the rotations that are relevant\n    const moverotations: Quat[][] = [];\n    for (let i = 0; i < moveplanesets.length; i++) {\n      moverotations.push([]);\n    }\n    for (let i = 0; i < this.rotations.length; i++) {\n      const q: Quat = this.rotations[i];\n      if (Math.abs(Math.abs(q.a) - 1) < eps) {\n        continue;\n      }\n      const qnormal = q.makenormal();\n      for (let j = 0; j < moveplanesets.length; j++) {\n        if (qnormal.sameplane(moveplanenormals[j])) {\n          moverotations[j].push(q);\n          break;\n        }\n      }\n    }\n    this.moverotations = moverotations;\n    //  Sort the rotations by the angle of rotation.  A bit tricky because\n    //  while the norms should be the same, they need not be.  So we start\n    //  by making the norms the same, and then sorting.\n    for (let i = 0; i < moverotations.length; i++) {\n      const r = moverotations[i];\n      const goodnormal = r[0].makenormal();\n      for (let j = 0; j < r.length; j++) {\n        if (goodnormal.dist(r[j].makenormal()) > eps) {\n          r[j] = r[j].smul(-1);\n        }\n      }\n      r.sort((a, b) => a.angle() - b.angle());\n      if (moverotations[i][0].dot(moveplanenormals[i]) < 0) {\n        r.reverse();\n      }\n    }\n    const sizes2 = moverotations.map((_) => 1 + _.length);\n    this.movesetorders = sizes2;\n    const movesetgeos = [];\n    let gtype = \"?\";\n    for (let i = 0; i < moveplanesets.length; i++) {\n      const p0 = moveplanenormals[i];\n      let neg = null;\n      let pos = null;\n      for (let j = 0; j < this.geonormals.length; j++) {\n        const d = p0.dot(this.geonormals[j][0]);\n        if (Math.abs(d - 1) < eps) {\n          pos = [this.geonormals[j][1], this.geonormals[j][2]];\n          gtype = this.geonormals[j][2];\n        } else if (Math.abs(d + 1) < eps) {\n          neg = [this.geonormals[j][1], this.geonormals[j][2]];\n          gtype = this.geonormals[j][2];\n        }\n      }\n      if (pos === null || neg === null) {\n        throw new Error(\"Saw positive or negative sides as null\");\n      }\n      movesetgeos.push([\n        pos[0],\n        pos[1],\n        neg[0],\n        neg[1],\n        1 + moveplanesets[i].length,\n      ]);\n      if (this.addNotationMapper === \"NxNxNCubeMapper\" && gtype === \"f\") {\n        this.notationMapper = new NxNxNCubeMapper(1 + moveplanesets[i].length);\n        this.addNotationMapper = \"\";\n      }\n      if (this.addNotationMapper === \"Megaminx\" && gtype === \"f\") {\n        if (1 + moveplanesets[i].length === 3) {\n          this.notationMapper = new MegaminxScramblingNotationMapper(\n            this.notationMapper,\n          );\n        }\n        this.addNotationMapper = \"\";\n      }\n    }\n    this.movesetgeos = movesetgeos;\n    //  Cubies are split by move plane sets.  For each cubie we can\n    //  average its points to find a point on the interior of that\n    //  cubie.  We can then check that point against all the move\n    //  planes and from that derive a coordinate for the cubie.\n    //  This also works for faces; no face should ever lie on a move\n    //  plane.  This allows us to take a set of stickers and break\n    //  them up into cubie sets.\n    const cubiehash: any = {};\n    const facelisthash: any = {};\n    const cubiekey: any = {};\n    const cubiekeys = [];\n    const cubies: Quat[][][] = [];\n    const faces = this.faces;\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      const s = this.keyface(face);\n      if (!cubiehash[s]) {\n        cubiekey[s] = cubies.length;\n        cubiekeys.push(s);\n        cubiehash[s] = [];\n        facelisthash[s] = [];\n        cubies.push(cubiehash[s]);\n      }\n      facelisthash[s].push(i);\n      cubiehash[s].push(face);\n      //  If we find a core cubie, split it up into multiple cubies,\n      //  because ksolve doesn't handle orientations that are not\n      //  cyclic, and the rotation group of the core is not cyclic.\n      if (facelisthash[s].length === this.basefacecount) {\n        if (this.verbose) {\n          console.log(\"# Splitting core.\");\n        }\n        for (let suff = 0; suff < this.basefacecount; suff++) {\n          const s2 = s + \" \" + suff;\n          facelisthash[s2] = [facelisthash[s][suff]];\n          cubiehash[s2] = [cubiehash[s][suff]];\n          cubiekeys.push(s2);\n          cubiekey[s2] = cubies.length;\n          cubies.push(cubiehash[s2]);\n        }\n        cubiehash[s] = [];\n        cubies[cubiekey[s]] = [];\n      }\n    }\n    this.cubiekey = cubiekey;\n    this.facelisthash = facelisthash;\n    this.cubiekeys = cubiekeys;\n    if (this.verbose) {\n      console.log(\"# Cubies: \" + Object.keys(cubiehash).length);\n    }\n    //  Sort the faces around each corner so they are clockwise.  Only\n    //  relevant for cubies that actually are corners (three or more\n    //  faces).  In general cubies might have many faces; for icosohedrons\n    //  there are five faces on the corner cubies.\n    this.cubies = cubies;\n    for (let k = 0; k < cubies.length; k++) {\n      const cubie = cubies[k];\n      if (cubie.length < 2) {\n        continue;\n      }\n      if (cubie.length === this.basefacecount) {\n        // looks like core?  don't sort\n        continue;\n      }\n      if (cubie.length > 5) {\n        throw new Error(\n          \"Bad math; too many faces on this cubie \" + cubie.length,\n        );\n      }\n      const s = this.keyface(cubie[0]);\n      const facelist = facelisthash[s];\n      const cm = cubie.map((_) => centermassface(_));\n      const cmall = centermassface(cm);\n      for (let looplimit = 0; cubie.length > 2; looplimit++) {\n        let changed = false;\n        for (let i = 0; i < cubie.length; i++) {\n          const j = (i + 1) % cubie.length;\n          // var ttt = cmall.dot(cm[i].cross(cm[j])) ; // TODO\n          if (cmall.dot(cm[i].cross(cm[j])) < 0) {\n            const t = cubie[i];\n            cubie[i] = cubie[j];\n            cubie[j] = t;\n            const u = cm[i];\n            cm[i] = cm[j];\n            cm[j] = u;\n            const v = facelist[i];\n            facelist[i] = facelist[j];\n            facelist[j] = v;\n            changed = true;\n          }\n        }\n        if (!changed) {\n          break;\n        }\n        if (looplimit > 1000) {\n          throw new Error(\"Bad epsilon math; too close to border\");\n        }\n      }\n      let mini = 0;\n      let minf = this.findface(cubie[mini]);\n      for (let i = 1; i < cubie.length; i++) {\n        const temp = this.findface(cubie[i]);\n        if (\n          this.faceprecedence[this.getfaceindex(temp)] <\n          this.faceprecedence[this.getfaceindex(minf)]\n        ) {\n          mini = i;\n          minf = temp;\n        }\n      }\n      if (mini !== 0) {\n        const ocubie = cubie.slice();\n        const ofacelist = facelist.slice();\n        for (let i = 0; i < cubie.length; i++) {\n          cubie[i] = ocubie[(mini + i) % cubie.length];\n          facelist[i] = ofacelist[(mini + i) % cubie.length];\n        }\n      }\n    }\n    //  Build an array that takes each face to a cubie ordinal and a\n    //  face number.\n    const facetocubies = [];\n    for (let i = 0; i < cubies.length; i++) {\n      const facelist = facelisthash[cubiekeys[i]];\n      for (let j = 0; j < facelist.length; j++) {\n        facetocubies[facelist[j]] = [i, j];\n      }\n    }\n    this.facetocubies = facetocubies;\n    //  Calculate the orbits of each cubie.  Assumes we do all moves.\n    //  Also calculates which cubies are identical.\n    const typenames = [\"?\", \"CENTERS\", \"EDGES\", \"CORNERS\", \"C4RNER\", \"C5RNER\"];\n    const cubiesetnames = [];\n    const cubietypecounts = [0, 0, 0, 0, 0, 0];\n    const orbitoris = [];\n    const seen = [];\n    let cubiesetnum = 0;\n    const cubiesetnums = [];\n    const cubieordnums = [];\n    const cubieords = [];\n    // var cubiesetnumhash = {} ; // TODO\n    const cubievaluemap = [];\n    // Later we will make this smarter to use a get color for face function\n    // so we support puzzles with multiple faces the same color\n    const getcolorkey = (cubienum: number): string => {\n      return cubies[cubienum]\n        .map((_) => this.getfaceindex(this.findface(_)))\n        .join(\" \");\n    };\n    const cubiesetcubies: any = [];\n    for (let i = 0; i < cubies.length; i++) {\n      if (seen[i]) {\n        continue;\n      }\n      const cubie = cubies[i];\n      if (cubie.length === 0) {\n        continue;\n      }\n      const cubiekeymap: any = {};\n      let cubievalueid = 0;\n      cubieords.push(0);\n      cubiesetcubies.push([]);\n      const facecnt = cubie.length;\n      const typectr = cubietypecounts[facecnt]++;\n      let typename = typenames[facecnt];\n      if (typename === undefined || facecnt === this.basefacecount) {\n        typename = \"CORE\";\n      }\n      typename = typename + (typectr === 0 ? \"\" : typectr + 1);\n      cubiesetnames[cubiesetnum] = typename;\n      orbitoris[cubiesetnum] = facecnt;\n      const queue = [i];\n      let qg = 0;\n      seen[i] = true;\n      while (qg < queue.length) {\n        const cind = queue[qg++];\n        const cubiecolorkey = getcolorkey(cind);\n        if (cubie.length > 1 || cubiekeymap[cubiecolorkey] === undefined) {\n          cubiekeymap[cubiecolorkey] = cubievalueid++;\n        }\n        cubievaluemap[cind] = cubiekeymap[cubiecolorkey];\n        cubiesetnums[cind] = cubiesetnum;\n        cubiesetcubies[cubiesetnum].push(cind);\n        cubieordnums[cind] = cubieords[cubiesetnum]++;\n        for (let j = 0; j < moverotations.length; j++) {\n          const tq = this.findcubie(\n            moverotations[j][0].rotateface(cubies[cind][0]),\n          );\n          if (!seen[tq]) {\n            queue.push(tq);\n            seen[tq] = true;\n          }\n        }\n      }\n      cubiesetnum++;\n    }\n    this.orbits = cubieords.length;\n    this.cubiesetnums = cubiesetnums;\n    this.cubieordnums = cubieordnums;\n    this.cubiesetnames = cubiesetnames;\n    this.cubieords = cubieords;\n    this.orbitoris = orbitoris;\n    this.cubievaluemap = cubievaluemap;\n    this.cubiesetcubies = cubiesetcubies;\n    // if we fix a cubie, find a cubie to fix\n    if (this.fixPiece !== \"\") {\n      for (let i = 0; i < cubies.length; i++) {\n        if (\n          (this.fixPiece === \"v\" && cubies[i].length > 2) ||\n          (this.fixPiece === \"e\" && cubies[i].length === 2) ||\n          (this.fixPiece === \"f\" && cubies[i].length === 1)\n        ) {\n          this.fixedCubie = i;\n          break;\n        }\n      }\n      if (this.fixedCubie < 0) {\n        throw new Error(\n          \"Could not find a cubie of type \" + this.fixPiece + \" to fix.\",\n        );\n      }\n    }\n    // show the orbits\n    if (this.verbose) {\n      console.log(\"# Cubie orbit sizes \" + cubieords);\n    }\n  }\n\n  public unswizzle(mv: BlockMove): string {\n    const newmv = this.notationMapper.notationToInternal(mv);\n    return this.swizzler.unswizzle(newmv.family);\n  }\n\n  // We use an extremely permissive parse here; any character but\n  // digits are allowed in a family name.\n  public stringToBlockMove(mv: string): BlockMove {\n    // parse a move from the command line\n    const re = RegExp(\"^(([0-9]+)-)?([0-9]+)?([^0-9]+)([0-9]+'?)?$\");\n    const p = mv.match(re);\n    if (p === null) {\n      throw new Error(\"Bad move passed \" + mv);\n    }\n    const grip = p[4];\n    let loslice = undefined;\n    let hislice = undefined;\n    if (p[2] !== undefined) {\n      if (p[3] === undefined) {\n        throw new Error(\"Missing second number in range\");\n      }\n      loslice = parseInt(p[2], 10);\n    }\n    if (p[3] !== undefined) {\n      hislice = parseInt(p[3], 10);\n    }\n    let amountstr = \"1\";\n    let amount = 1;\n    if (p[5] !== undefined) {\n      amountstr = p[5];\n      if (amountstr[0] === \"'\") {\n        amountstr = \"-\" + amountstr.substring(1);\n      }\n      amount = parseInt(amountstr, 10);\n    }\n    return new BlockMove(loslice, hislice, grip, amount);\n  }\n\n  public parseBlockMove(blockmove: BlockMove): any {\n    blockmove = this.notationMapper.notationToInternal(blockmove); // pluggable notation\n    let grip = blockmove.family;\n    let fullrotation = false;\n    if (grip.endsWith(\"v\") && grip[0] <= \"Z\") {\n      if (\n        blockmove.innerLayer !== undefined ||\n        blockmove.outerLayer !== undefined\n      ) {\n        throw new Error(\"Cannot use a prefix with full cube rotations\");\n      }\n      grip = grip.slice(0, -1);\n      fullrotation = true;\n    }\n    if (grip.endsWith(\"w\") && grip[0] <= \"Z\") {\n      grip = grip.slice(0, -1).toLowerCase();\n    }\n    let geo;\n    let msi = -1;\n    const geoname = this.swizzler.unswizzle(grip);\n    let firstgrip = false;\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const g = this.movesetgeos[i];\n      if (geoname === g[0]) {\n        firstgrip = true;\n        geo = g;\n        msi = i;\n      }\n      if (geoname === g[2]) {\n        firstgrip = false;\n        geo = g;\n        msi = i;\n      }\n    }\n    let loslice = 1;\n    let hislice = 1;\n    if (grip.toUpperCase() !== grip) {\n      hislice = 2;\n    }\n    if (geo === undefined) {\n      throw new Error(\"Bad grip in move \" + blockmove.family);\n    }\n    if (blockmove.outerLayer !== undefined) {\n      loslice = blockmove.outerLayer;\n    }\n    if (blockmove.innerLayer !== undefined) {\n      if (blockmove.outerLayer === undefined) {\n        hislice = blockmove.innerLayer;\n        if (geoname === grip) {\n          loslice = hislice;\n        } else {\n          loslice = 1;\n        }\n      } else {\n        hislice = blockmove.innerLayer;\n      }\n    }\n    loslice--;\n    hislice--;\n    if (fullrotation) {\n      loslice = 0;\n      hislice = this.moveplanesets[msi].length;\n    }\n    if (\n      loslice < 0 ||\n      loslice > this.moveplanesets[msi].length ||\n      hislice < 0 ||\n      hislice > this.moveplanesets[msi].length\n    ) {\n      throw new Error(\"Bad slice spec \" + loslice + \" \" + hislice);\n    }\n    if (\n      !permissivieMoveParsing &&\n      loslice === 0 &&\n      hislice === this.moveplanesets[msi].length &&\n      !fullrotation\n    ) {\n      throw new Error(\n        \"! full puzzle rotations must be specified with v suffix.\",\n      );\n    }\n    const r = [undefined, msi, loslice, hislice, firstgrip, blockmove.amount];\n    return r;\n  }\n\n  public parsemove(mv: string): any {\n    const r = this.parseBlockMove(this.stringToBlockMove(mv));\n    r[0] = mv;\n    return r;\n  }\n\n  public genperms(): void {\n    // generate permutations for moves\n    if (this.cmovesbyslice.length > 0) {\n      // did this already?\n      return;\n    }\n    const cmovesbyslice = [];\n    // if orientCenters is set, we find all cubies that have only one\n    // sticker and that sticker is in the center of a face, and we\n    // introduce duplicate stickers so we can orient them properly.\n    if (this.orientCenters) {\n      for (let k = 0; k < this.cubies.length; k++) {\n        if (this.cubies[k].length === 1) {\n          const kk = this.findface(this.cubies[k][0]);\n          const i = this.getfaceindex(kk);\n          if (\n            centermassface(this.basefaces[i]).dist(\n              centermassface(this.faces[kk]),\n            ) < eps\n          ) {\n            const o = this.basefaces[i].length;\n            for (let m = 0; m < o; m++) {\n              this.cubies[k].push(this.cubies[k][0]);\n            }\n            this.duplicatedFaces[kk] = o;\n            this.duplicatedCubies[k] = o;\n            this.orbitoris[this.cubiesetnums[k]] = o;\n          }\n        }\n      }\n    }\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveplaneset = this.moveplanesets[k];\n      const slicenum = [];\n      const slicecnts = [];\n      for (let i = 0; i < this.faces.length; i++) {\n        const face = this.faces[i];\n        let t = 0;\n        for (let j = 0; j < moveplaneset.length; j++) {\n          if (moveplaneset[j].faceside(face) < 0) {\n            t++;\n          }\n        }\n        slicenum.push(t);\n        while (slicecnts.length <= t) {\n          slicecnts.push(0);\n        }\n        slicecnts[t]++;\n      }\n      const axiscmoves = [];\n      for (let sc = 0; sc < slicecnts.length; sc++) {\n        const slicecmoves = [];\n        const cubiedone = [];\n        for (let i = 0; i < this.faces.length; i++) {\n          if (slicenum[i] !== sc) {\n            continue;\n          }\n          const b = this.facetocubies[i].slice();\n          let face = this.faces[i];\n          let fi2 = i;\n          for (;;) {\n            slicenum[fi2] = -1;\n            const face2 = this.moverotations[k][0].rotateface(face);\n            fi2 = this.findface(face2);\n            if (slicenum[fi2] < 0) {\n              break;\n            }\n            if (slicenum[fi2] !== sc) {\n              throw new Error(\"Bad movement?\");\n            }\n            const c = this.facetocubies[fi2];\n            b.push(c[0], c[1]);\n            face = face2;\n          }\n          // If an oriented center is moving, we need to figure out\n          // the appropriate new orientation.  Normally we use the cubie\n          // sticker identity to locate, but this doesn't work here.\n          // Instead we need to redo the geometry of the sticker itself\n          // rotating and figure out how that maps to the destination\n          // sticker.\n          //\n          // We only need to do this for central center stickers: those\n          // where the face vertex goes through the center.  The others\n          // don't actually need orientation because they can only be\n          // in one orientation by physical constraints.  (You can't spin\n          // a point or cross sticker on the 5x5x5, for example.)\n          //\n          // This also simplifies things because it means the actual\n          // remapping has the same order as the moves themselves.\n          //\n          // The center may or may not have been duplicated at this point.\n          //\n          // The move moving the center might not be the same modulo as the\n          // center itself.\n          if (\n            b.length > 2 &&\n            this.orientCenters &&\n            (this.cubies[b[0]].length === 1 ||\n              this.cubies[b[0]][0] === this.cubies[b[0]][1])\n          ) {\n            // is this a real center cubie, around an axis?\n            if (\n              centermassface(this.faces[i]).dist(\n                centermassface(this.basefaces[this.getfaceindex(i)]),\n              ) < eps\n            ) {\n              // how does remapping of the face/point set map to the original?\n              let face1 = this.cubies[b[0]][0];\n              for (let ii = 0; ii < b.length; ii += 2) {\n                const face0 = this.cubies[b[ii]][0];\n                let o = -1;\n                for (let jj = 0; jj < face1.length; jj++) {\n                  if (face0[jj].dist(face1[0]) < eps) {\n                    o = jj;\n                    break;\n                  }\n                }\n                if (o < 0) {\n                  throw new Error(\n                    \"Couldn't find rotation of center faces; ignoring for now.\",\n                  );\n                } else {\n                  b[ii + 1] = o;\n                  face1 = this.moverotations[k][0].rotateface(face1);\n                }\n              }\n            }\n          }\n          // b.length == 2 means a sticker is spinning in place.\n          // in this case we add duplicate stickers\n          // so that we can make it animate properly in a 3D world.\n          if (b.length === 2 && this.orientCenters) {\n            for (let ii = 1; ii < this.movesetorders[k]; ii++) {\n              if (sc === 0) {\n                b.push(b[0], ii);\n              } else {\n                b.push(\n                  b[0],\n                  (this.movesetorders[k] - ii) % this.movesetorders[k],\n                );\n              }\n            }\n          }\n          if (b.length > 2 && !cubiedone[b[0]]) {\n            if (b.length !== 2 * this.movesetorders[k]) {\n              throw new Error(\"Bad length in perm gen\");\n            }\n            for (let j = 0; j < b.length; j++) {\n              slicecmoves.push(b[j]);\n            }\n          }\n          for (let j = 0; j < b.length; j += 2) {\n            cubiedone[b[j]] = true;\n          }\n        }\n        axiscmoves.push(slicecmoves);\n      }\n      cmovesbyslice.push(axiscmoves);\n    }\n    this.cmovesbyslice = cmovesbyslice;\n    if (this.movelist !== undefined) {\n      const parsedmovelist: any[] = [];\n      // make sure the movelist makes sense based on the geos.\n      for (let i = 0; i < this.movelist.length; i++) {\n        parsedmovelist.push(this.parsemove(this.movelist[i]));\n      }\n      this.parsedmovelist = parsedmovelist;\n    }\n  }\n\n  public getfaces(): number[][][] {\n    // get the faces for 3d.\n    return this.faces.map((_) => {\n      return _.map((__) => [__.b, __.c, __.d]);\n    });\n  }\n\n  public getboundarygeometry(): any {\n    // get the boundary geometry\n    return {\n      baseplanes: this.baseplanes,\n      facenames: this.facenames,\n      faceplanes: this.faceplanes,\n      vertexnames: this.vertexnames,\n      edgenames: this.edgenames,\n      geonormals: this.geonormals,\n    };\n  }\n\n  public getmovesets(k: number): any {\n    // get the move sets we support based on slices\n    // for even values we omit the middle \"slice\".  This isn't perfect\n    // but it is what we do for now.\n    // if there was a move list specified, pull values from that\n    const slices = this.moveplanesets[k].length;\n    if (slices > 30) {\n      throw new Error(\"Too many slices for getmovesets bitmasks\");\n    }\n    let r = [];\n    if (this.parsedmovelist !== undefined) {\n      for (let i = 0; i < this.parsedmovelist.length; i++) {\n        const parsedmove = this.parsedmovelist[i];\n        if (parsedmove[1] !== k) {\n          continue;\n        }\n        if (parsedmove[4]) {\n          r.push((2 << parsedmove[3]) - (1 << parsedmove[2]));\n        } else {\n          r.push(\n            (2 << (slices - parsedmove[2])) - (1 << (slices - parsedmove[3])),\n          );\n        }\n        r.push(parsedmove[5]);\n      }\n    } else if (this.vertexmoves && !this.allmoves) {\n      const msg = this.movesetgeos[k];\n      if (msg[1] !== msg[3]) {\n        for (let i = 0; i < slices; i++) {\n          if (msg[1] !== \"v\") {\n            if (this.outerblockmoves) {\n              r.push((2 << slices) - (2 << i));\n            } else {\n              r.push(2 << i);\n            }\n            r.push(1);\n          } else {\n            if (this.outerblockmoves) {\n              r.push((2 << i) - 1);\n            } else {\n              r.push(1 << i);\n            }\n            r.push(1);\n          }\n        }\n      }\n    } else {\n      for (let i = 0; i <= slices; i++) {\n        if (!this.allmoves && i + i === slices) {\n          continue;\n        }\n        if (this.outerblockmoves) {\n          if (i + i > slices) {\n            r.push((2 << slices) - (1 << i));\n          } else {\n            r.push((2 << i) - 1);\n          }\n        } else {\n          r.push(1 << i);\n        }\n        r.push(1);\n      }\n    }\n    if (this.fixedCubie >= 0) {\n      const dep = 1 << +this.cubiekeys[this.fixedCubie].trim().split(\" \")[k];\n      const newr = [];\n      for (let i = 0; i < r.length; i += 2) {\n        let o = r[i];\n        if (o & dep) {\n          o = (2 << slices) - 1 - o;\n        }\n        let found = false;\n        for (let j = 0; j < newr.length; j += 2) {\n          if (newr[j] === o && newr[j + 1] === r[i + 1]) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          newr.push(o);\n          newr.push(r[i + 1]);\n        }\n      }\n      r = newr;\n    }\n    return r;\n  }\n\n  public graybyori(cubie: number): boolean {\n    let ori = this.cubies[cubie].length;\n    if (this.duplicatedCubies[cubie]) {\n      ori = 1;\n    }\n    return (\n      (ori === 1 && (this.graycenters || !this.centersets)) ||\n      (ori === 2 && (this.grayedges || !this.edgesets)) ||\n      (ori > 2 && (this.graycorners || !this.cornersets))\n    );\n  }\n\n  public skipbyori(cubie: number): boolean {\n    let ori = this.cubies[cubie].length;\n    if (this.duplicatedCubies[cubie]) {\n      ori = 1;\n    }\n    return (\n      (ori === 1 && !this.centersets) ||\n      (ori === 2 && !this.edgesets) ||\n      (ori > 2 && !this.cornersets)\n    );\n  }\n\n  public skipcubie(fi: number): boolean {\n    return this.skipbyori(fi);\n  }\n\n  public skipset(set: number[]): boolean {\n    if (set.length === 0) {\n      return true;\n    }\n    const fi = set[0];\n    return this.skipbyori(this.facetocubies[fi][0]);\n  }\n\n  public header(comment: string): string {\n    return comment + copyright + \"\\n\" + comment + this.args + \"\\n\";\n  }\n\n  public writegap(): string {\n    // write out a gap set of generators\n    const os = this.getOrbitsDef(false);\n    const r = [];\n    const mvs = [];\n    for (let i = 0; i < os.moveops.length; i++) {\n      const movename = \"M_\" + os.movenames[i];\n      // gap doesn't like angle brackets in IDs\n      mvs.push(movename);\n      r.push(movename + \":=\" + os.moveops[i].toPerm().toGap() + \";\");\n    }\n    r.push(\"Gen:=[\");\n    r.push(mvs.join(\",\"));\n    r.push(\"];\");\n    const ip = os.solved.identicalPieces();\n    r.push(\n      \"ip:=[\" +\n        ip.map((_) => \"[\" + _.map((__) => __ + 1).join(\",\") + \"]\").join(\",\") +\n        \"];\",\n    );\n    r.push(\"\");\n    return this.header(\"# \") + r.join(\"\\n\");\n  }\n\n  public writeksolve(\n    name: string = \"PuzzleGeometryPuzzle\",\n    fortwisty: boolean = false,\n  ): string {\n    const od = this.getOrbitsDef(fortwisty);\n    if (fortwisty) {\n      return od.toKsolve(name, fortwisty).join(\"\\n\");\n    } else {\n      return this.header(\"# \") + od.toKsolve(name, fortwisty).join(\"\\n\");\n    }\n  }\n\n  public writekpuzzle(fortwisty: boolean = true): any {\n    const od = this.getOrbitsDef(fortwisty);\n    const r = od.toKpuzzle() as KPuzzleDefinition;\n    r.moveNotation = new PGNotation(this, od);\n    return r;\n  }\n\n  public getMoveFromBits(\n    movebits: number,\n    amount: number,\n    inverted: boolean,\n    axiscmoves: number[][],\n    setmoves: number[] | undefined,\n    movesetorder: number,\n  ): Transformation {\n    const moveorbits: Orbit[] = [];\n    const perms = [];\n    const oris = [];\n    for (let ii = 0; ii < this.cubiesetnames.length; ii++) {\n      perms.push(iota(this.cubieords[ii]));\n      oris.push(zeros(this.cubieords[ii]));\n    }\n    for (let m = 0; m < axiscmoves.length; m++) {\n      if (((movebits >> m) & 1) === 0) {\n        continue;\n      }\n      const slicecmoves = axiscmoves[m];\n      for (let j = 0; j < slicecmoves.length; j += 2 * movesetorder) {\n        const mperm = slicecmoves.slice(j, j + 2 * movesetorder);\n        const setnum = this.cubiesetnums[mperm[0]];\n        for (let ii = 0; ii < mperm.length; ii += 2) {\n          mperm[ii] = this.cubieordnums[mperm[ii]];\n        }\n        let inc = 2;\n        let oinc = 3;\n        if (inverted) {\n          inc = mperm.length - 2;\n          oinc = mperm.length - 1;\n        }\n        if (perms[setnum] === iota(this.cubieords[setnum])) {\n          perms[setnum] = perms[setnum].slice();\n          if (this.orbitoris[setnum] > 1 && !this.killorientation) {\n            oris[setnum] = oris[setnum].slice();\n          }\n        }\n        for (let ii = 0; ii < mperm.length; ii += 2) {\n          perms[setnum][mperm[(ii + inc) % mperm.length]] = mperm[ii];\n          if (this.orbitoris[setnum] > 1 && !this.killorientation) {\n            oris[setnum][mperm[ii]] =\n              (mperm[(ii + oinc) % mperm.length] -\n                mperm[(ii + 1) % mperm.length] +\n                2 * this.orbitoris[setnum]) %\n              this.orbitoris[setnum];\n          }\n        }\n      }\n    }\n    for (let ii = 0; ii < this.cubiesetnames.length; ii++) {\n      if (setmoves && !setmoves[ii]) {\n        continue;\n      }\n      if (this.orbitoris[ii] === 1 || this.killorientation) {\n        moveorbits.push(new Orbit(perms[ii], oris[ii], 1));\n      } else {\n        const no = new Array<number>(oris[ii].length);\n        // convert ksolve oris to our internal ori rep\n        for (let jj = 0; jj < perms[ii].length; jj++) {\n          no[jj] = oris[ii][perms[ii][jj]];\n        }\n        moveorbits.push(new Orbit(perms[ii], no, this.orbitoris[ii]));\n      }\n    }\n    let mv = new Transformation(moveorbits);\n    if (amount !== 1) {\n      mv = mv.mulScalar(amount);\n    }\n    return mv;\n  }\n\n  public getOrbitsDef(fortwisty: boolean): OrbitsDef {\n    // generate a representation of the puzzle\n    const setmoves = [];\n    const setnames: string[] = [];\n    const setdefs: OrbitDef[] = [];\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveset = this.getmovesets(k);\n      const movesetorder = this.movesetorders[k];\n      // check there's no redundancy in moveset.\n      for (let i = 0; i < moveset.length; i += 2) {\n        for (let j = 0; j < i; j += 2) {\n          if (moveset[i] === moveset[j] && moveset[i + 1] === moveset[j + 1]) {\n            throw new Error(\"Redundant moves in moveset.\");\n          }\n        }\n      }\n      let allbits = 0;\n      for (let i = 0; i < moveset.length; i += 2) {\n        allbits |= moveset[i];\n      }\n      const axiscmoves = this.cmovesbyslice[k];\n      for (let i = 0; i < axiscmoves.length; i++) {\n        if (((allbits >> i) & 1) === 0) {\n          continue;\n        }\n        const slicecmoves = axiscmoves[i];\n        for (let j = 0; j < slicecmoves.length; j += 2 * movesetorder) {\n          if (this.skipcubie(slicecmoves[j])) {\n            continue;\n          }\n          const ind = this.cubiesetnums[slicecmoves[j]];\n          setmoves[ind] = 1;\n        }\n      }\n    }\n    for (let i = 0; i < this.cubiesetnames.length; i++) {\n      if (!setmoves[i]) {\n        continue;\n      }\n      setnames.push(this.cubiesetnames[i]);\n      setdefs.push(\n        new OrbitDef(\n          this.cubieords[i],\n          this.killorientation ? 1 : this.orbitoris[i],\n        ),\n      );\n    }\n    const solved: Orbit[] = [];\n    for (let i = 0; i < this.cubiesetnames.length; i++) {\n      if (!setmoves[i]) {\n        continue;\n      }\n      const p = [];\n      const o = [];\n      for (let j = 0; j < this.cubieords[i]; j++) {\n        if (fortwisty) {\n          p.push(j);\n        } else {\n          const cubie = this.cubiesetcubies[i][j];\n          p.push(this.cubievaluemap[cubie]);\n        }\n        o.push(0);\n      }\n      solved.push(\n        new Orbit(p, o, this.killorientation ? 1 : this.orbitoris[i]),\n      );\n    }\n    const movenames: string[] = [];\n    const moves: Transformation[] = [];\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveplaneset = this.moveplanesets[k];\n      const slices = moveplaneset.length;\n      const moveset = this.getmovesets(k);\n      const movesetgeo = this.movesetgeos[k];\n      for (let i = 0; i < moveset.length; i += 2) {\n        const movebits = moveset[i];\n        const mna = getmovename(movesetgeo, movebits, slices);\n        const movename = mna[0];\n        const inverted = mna[1];\n        if (moveset[i + 1] === 1) {\n          movenames.push(movename);\n        } else {\n          movenames.push(movename + moveset[i + 1]);\n        }\n        const mv = this.getMoveFromBits(\n          movebits,\n          moveset[i + 1],\n          inverted,\n          this.cmovesbyslice[k],\n          setmoves,\n          this.movesetorders[k],\n        );\n        moves.push(mv);\n      }\n    }\n    this.ksolvemovenames = movenames; // hack!\n    let r = new OrbitsDef(\n      setnames,\n      setdefs,\n      new VisibleState(solved),\n      movenames,\n      moves,\n    );\n    if (this.optimize) {\n      r = r.optimize();\n    }\n    if (this.scramble !== 0) {\n      r.scramble(this.scramble);\n    }\n    return r;\n  }\n\n  public getMovesAsPerms(): Perm[] {\n    return this.getOrbitsDef(false).moveops.map((_: Transformation) =>\n      _.toPerm(),\n    );\n  }\n\n  public showcanon(disp: (s: string) => void): void {\n    // show information for canonical move derivation\n    showcanon(this.getOrbitsDef(false), disp);\n  }\n\n  public getsolved(): Perm {\n    // get a solved position\n    const r = [];\n    for (let i = 0; i < this.basefacecount; i++) {\n      for (let j = 0; j < this.stickersperface; j++) {\n        r.push(i);\n      }\n    }\n    return new Perm(r);\n  }\n\n  // Given a rotation description that says to align feature1\n  // with a given vector, and then as much as possible feature2\n  // with another given vector, return a Quaternion that\n  // performs this rotation.\n  public getOrientationRotation(desiredRotation: any[]): Quat {\n    const feature1name = desiredRotation[0];\n    const direction1 = new Quat(\n      0,\n      desiredRotation[1][0],\n      -desiredRotation[1][1],\n      desiredRotation[1][2],\n    );\n    const feature2name = desiredRotation[2];\n    const direction2 = new Quat(\n      0,\n      desiredRotation[3][0],\n      -desiredRotation[3][1],\n      desiredRotation[3][2],\n    );\n    let feature1: Quat | null = null;\n    let feature2: Quat | null = null;\n    const feature1geoname = this.swizzler.unswizzle(feature1name);\n    const feature2geoname = this.swizzler.unswizzle(feature2name);\n    for (const gn of this.geonormals) {\n      if (feature1geoname === gn[1]) {\n        feature1 = gn[0];\n      }\n      if (feature2geoname === gn[1]) {\n        feature2 = gn[0];\n      }\n    }\n    if (!feature1) {\n      throw new Error(\"Could not find feature \" + feature1name);\n    }\n    if (!feature2) {\n      throw new Error(\"Could not find feature \" + feature2name);\n    }\n    const r1 = feature1.pointrotation(direction1);\n    const feature2rot = feature2.rotatepoint(r1);\n    const r2 = feature2rot\n      .unproject(direction1)\n      .pointrotation(direction2.unproject(direction1));\n    return r2.mul(r1);\n  }\n\n  public getInitial3DRotation(): Quat {\n    const basefacecount = this.basefacecount;\n    let rotDesc: any = null;\n    if (this.puzzleOrientation) {\n      rotDesc = this.puzzleOrientation;\n    } else if (this.puzzleOrientations) {\n      rotDesc = this.puzzleOrientations[basefacecount];\n    }\n    // either no option specified or no matching key in\n    // puzzleOrientations.\n    if (!rotDesc) {\n      rotDesc = defaultOrientations()[basefacecount];\n    }\n    if (!rotDesc) {\n      throw new Error(\"No default orientation?\");\n    }\n    return this.getOrientationRotation(rotDesc);\n  }\n\n  public generatesvg(\n    w: number = 800,\n    h: number = 500,\n    trim: number = 10,\n    threed: boolean = false,\n  ): string {\n    // generate svg to interoperate with Lucas twistysim\n    w -= 2 * trim;\n    h -= 2 * trim;\n    function extendedges(a: number[][], n: number): void {\n      let dx = a[1][0] - a[0][0];\n      let dy = a[1][1] - a[0][1];\n      const ang = (2 * Math.PI) / n;\n      const cosa = Math.cos(ang);\n      const sina = Math.sin(ang);\n      for (let i = 2; i < n; i++) {\n        const ndx = dx * cosa + dy * sina;\n        dy = dy * cosa - dx * sina;\n        dx = ndx;\n        a.push([a[i - 1][0] + dx, a[i - 1][1] + dy]);\n      }\n    }\n    // if we don't add this noise to coordinate values, then Safari\n    // doesn't render our polygons correctly.  What a hack.\n    function noise(c: number): number {\n      return c + 0 * (Math.random() - 0.5);\n    }\n    function drawedges(id: string, pts: number[][], color: string): string {\n      return (\n        '<polygon id=\"' +\n        id +\n        '\" class=\"sticker\" style=\"fill: ' +\n        color +\n        '\" points=\"' +\n        pts.map((p) => noise(p[0]) + \" \" + noise(p[1])).join(\" \") +\n        '\"/>\\n'\n      );\n    }\n    // What grips do we need?  if rotations, add all grips.\n    let needvertexgrips = this.addrotations;\n    let neededgegrips = this.addrotations;\n    let needfacegrips = this.addrotations;\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const msg = this.movesetgeos[i];\n      for (let j = 1; j <= 3; j += 2) {\n        if (msg[j] === \"v\") {\n          needvertexgrips = true;\n        }\n        if (msg[j] === \"f\") {\n          needfacegrips = true;\n        }\n        if (msg[j] === \"e\") {\n          neededgegrips = true;\n        }\n      }\n    }\n    // Find a net from a given face count.  Walk it, assuming we locate\n    // the first edge from (0,0) to (1,1) and compute the minimum and\n    // maximum vertex locations from this.  Then do a second walk, and\n    // assign the actual geometry.\n    this.genperms();\n    const boundarygeo = this.getboundarygeometry();\n    const face0 = boundarygeo.facenames[0][0];\n    const polyn = face0.length; // number of vertices; 3, 4, or 5\n    const net = this.net;\n    if (net === null) {\n      throw new Error(\"No net?\");\n    }\n    const edges: any = {};\n    let minx = 0;\n    let miny = 0;\n    let maxx = 1;\n    let maxy = 0;\n    edges[net[0][0]] = [\n      [1, 0],\n      [0, 0],\n    ];\n    extendedges(edges[net[0][0]], polyn);\n    for (let i = 0; i < net.length; i++) {\n      const f0 = net[i][0];\n      if (!edges[f0]) {\n        throw new Error(\"Bad edge description; first edge not connected.\");\n      }\n      for (let j = 1; j < net[i].length; j++) {\n        const f1 = net[i][j];\n        if (f1 === \"\" || edges[f1]) {\n          continue;\n        }\n        edges[f1] = [edges[f0][j % polyn], edges[f0][(j + polyn - 1) % polyn]];\n        extendedges(edges[f1], polyn);\n      }\n    }\n    for (const f in edges) {\n      const es = edges[f];\n      for (let i = 0; i < es.length; i++) {\n        minx = Math.min(minx, es[i][0]);\n        maxx = Math.max(maxx, es[i][0]);\n        miny = Math.min(miny, es[i][1]);\n        maxy = Math.max(maxy, es[i][1]);\n      }\n    }\n    const sc = Math.min(w / (maxx - minx), h / (maxy - miny));\n    const xoff = 0.5 * (w - sc * (maxx + minx));\n    const yoff = 0.5 * (h - sc * (maxy + miny));\n    const geos: any = {};\n    const bg = this.getboundarygeometry();\n    const edges2: any = {};\n    const initv = [\n      [sc + xoff, yoff],\n      [xoff, yoff],\n    ];\n    edges2[net[0][0]] = initv;\n    extendedges(edges2[net[0][0]], polyn);\n    geos[this.facenames[0][1]] = this.project2d(0, 0, [\n      new Quat(0, initv[0][0], initv[0][1], 0),\n      new Quat(0, initv[1][0], initv[1][1], 0),\n    ]);\n    const connectat = [];\n    connectat[0] = 0;\n    for (let i = 0; i < net.length; i++) {\n      const f0 = net[i][0];\n      if (!edges2[f0]) {\n        throw new Error(\"Bad edge description; first edge not connected.\");\n      }\n      let gfi = -1;\n      for (let j = 0; j < bg.facenames.length; j++) {\n        if (f0 === bg.facenames[j][1]) {\n          gfi = j;\n          break;\n        }\n      }\n      if (gfi < 0) {\n        throw new Error(\"Could not find first face name \" + f0);\n      }\n      const thisface = bg.facenames[gfi][0];\n      for (let j = 1; j < net[i].length; j++) {\n        const f1 = net[i][j];\n        if (f1 === \"\" || edges2[f1]) {\n          continue;\n        }\n        edges2[f1] = [\n          edges2[f0][j % polyn],\n          edges2[f0][(j + polyn - 1) % polyn],\n        ];\n        extendedges(edges2[f1], polyn);\n        // what edge are we at?\n        const caf0 = connectat[gfi];\n        const mp = thisface[(caf0 + j) % polyn]\n          .sum(thisface[(caf0 + j + polyn - 1) % polyn])\n          .smul(0.5);\n        const epi = findelement(bg.edgenames, mp);\n        const edgename = bg.edgenames[epi][1];\n        const el = splitByFaceNames(edgename, this.facenames);\n        const gf1 = el[f0 === el[0] ? 1 : 0];\n        let gf1i = -1;\n        for (let k = 0; k < bg.facenames.length; k++) {\n          if (gf1 === bg.facenames[k][1]) {\n            gf1i = k;\n            break;\n          }\n        }\n        if (gf1i < 0) {\n          throw new Error(\"Could not find second face name\");\n        }\n        const otherface = bg.facenames[gf1i][0];\n        for (let k = 0; k < otherface.length; k++) {\n          const mp2 = otherface[k].sum(otherface[(k + 1) % polyn]).smul(0.5);\n          if (mp2.dist(mp) <= eps) {\n            const p1 = edges2[f0][(j + polyn - 1) % polyn];\n            const p2 = edges2[f0][j % polyn];\n            connectat[gf1i] = k;\n            geos[gf1] = this.project2d(gf1i, k, [\n              new Quat(0, p2[0], p2[1], 0),\n              new Quat(0, p1[0], p1[1], 0),\n            ]);\n            break;\n          }\n        }\n      }\n    }\n    // Let's build arrays for faster rendering.  We want to map from geo\n    // base face number to color, and we want to map from geo face number\n    // to 2D geometry.  These can be reused as long as the puzzle overall\n    // orientation and canvas size remains unchanged.\n    const pos = this.getsolved();\n    const colormap = [];\n    const facegeo = [];\n    for (let i = 0; i < this.basefacecount; i++) {\n      colormap[i] = this.colors[this.facenames[i][1]];\n    }\n    let hix = 0;\n    let hiy = 0;\n    const rot = this.getInitial3DRotation();\n    for (let i = 0; i < this.faces.length; i++) {\n      let face = this.faces[i];\n      face = rot.rotateface(face);\n      for (let j = 0; j < face.length; j++) {\n        hix = Math.max(hix, Math.abs(face[j].b));\n        hiy = Math.max(hiy, Math.abs(face[j].c));\n      }\n    }\n    const sc2 = Math.min(h / hiy / 2, (w - trim) / hix / 4);\n    const mappt2d = (fn: number, q: Quat): number[] => {\n      if (threed) {\n        const xoff2 = 0.5 * trim + 0.25 * w;\n        const xmul = this.baseplanes[fn].rotateplane(rot).d < 0 ? 1 : -1;\n        return [\n          trim + w * 0.5 + xmul * (xoff2 - q.b * sc2),\n          trim + h * 0.5 + q.c * sc2,\n        ];\n      } else {\n        const g = geos[this.facenames[fn][1]];\n        return [trim + q.dot(g[0]) + g[2].b, trim + h - q.dot(g[1]) - g[2].c];\n      }\n    };\n    for (let i = 0; i < this.faces.length; i++) {\n      let face = this.faces[i];\n      const facenum = Math.floor(i / this.stickersperface);\n      if (threed) {\n        face = rot.rotateface(face);\n      }\n      facegeo.push(face.map((_: Quat) => mappt2d(facenum, _)));\n    }\n    const svg = [];\n    // group each base face so we can add a hover element\n    for (let j = 0; j < this.basefacecount; j++) {\n      svg.push(\"<g>\");\n      svg.push(\"<title>\" + this.facenames[j][1] + \"</title>\\n\");\n      for (let ii = 0; ii < this.stickersperface; ii++) {\n        const i = j * this.stickersperface + ii;\n        const cubie = this.facetocubies[i][0];\n        const cubieori = this.facetocubies[i][1];\n        const cubiesetnum = this.cubiesetnums[cubie];\n        const cubieord = this.cubieordnums[cubie];\n        const color = this.graybyori(cubie) ? \"#808080\" : colormap[pos.p[i]];\n        let id =\n          this.cubiesetnames[cubiesetnum] + \"-l\" + cubieord + \"-o\" + cubieori;\n        svg.push(drawedges(id, facegeo[i], color));\n        if (this.duplicatedFaces[i]) {\n          for (let jj = 1; jj < this.duplicatedFaces[i]; jj++) {\n            id = this.cubiesetnames[cubiesetnum] + \"-l\" + cubieord + \"-o\" + jj;\n            svg.push(drawedges(id, facegeo[i], color));\n          }\n        }\n      }\n      svg.push(\"</g>\");\n    }\n    const svggrips: any[] = [];\n    function addgrip(\n      onface: number,\n      name: string,\n      pt: Quat,\n      order: number,\n    ): void {\n      const pt2 = mappt2d(onface, pt);\n      for (let i = 0; i < svggrips.length; i++) {\n        if (\n          Math.hypot(pt2[0] - svggrips[i][0], pt2[1] - svggrips[i][1]) < eps\n        ) {\n          return;\n        }\n      }\n      svggrips.push([pt2[0], pt2[1], name, order]);\n    }\n    for (let i = 0; i < this.faceplanes.length; i++) {\n      const baseface = this.facenames[i][0];\n      let facecoords = baseface;\n      if (threed) {\n        facecoords = rot.rotateface(facecoords);\n      }\n      if (needfacegrips) {\n        let pt = this.faceplanes[i][0];\n        if (threed) {\n          pt = pt.rotatepoint(rot);\n        }\n        addgrip(i, this.faceplanes[i][1], pt, polyn);\n      }\n      for (let j = 0; j < baseface.length; j++) {\n        if (neededgegrips) {\n          const mp = baseface[j]\n            .sum(baseface[(j + 1) % baseface.length])\n            .smul(0.5);\n          const ep = findelement(this.edgenames, mp);\n          const mpc = facecoords[j]\n            .sum(facecoords[(j + 1) % baseface.length])\n            .smul(0.5);\n          addgrip(i, this.edgenames[ep][1], mpc, 2);\n        }\n        if (needvertexgrips) {\n          const vp = findelement(this.vertexnames, baseface[j]);\n          addgrip(i, this.vertexnames[vp][1], facecoords[j], this.cornerfaces);\n        }\n      }\n    }\n    const html =\n      '<svg id=\"svg\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 800 500\">\\n' +\n      '<style type=\"text/css\"><![CDATA[' +\n      \".sticker { stroke: #000000; stroke-width: 1px; }\" +\n      \"]]></style>\\n\" +\n      svg.join(\"\") +\n      \"</svg>\";\n    this.svggrips = svggrips;\n    return html;\n  }\n\n  public dist(a: number[], b: number[]): number {\n    return Math.hypot(a[0] - b[0], a[1] - b[1], a[2] - b[2]);\n  }\n\n  public triarea(a: number[], b: number[], c: number[]): number {\n    const ab = this.dist(a, b);\n    const bc = this.dist(b, c);\n    const ac = this.dist(a, c);\n    const p = (ab + bc + ac) / 2;\n    return Math.sqrt(p * (p - ab) * (p - bc) * (p - ac));\n  }\n\n  public polyarea(coords: number[][]): number {\n    let sum = 0;\n    for (let i = 2; i < coords.length; i++) {\n      sum += this.triarea(coords[0], coords[1], coords[i]);\n    }\n    return sum;\n  }\n\n  // The colorfrac parameter says how much of the face should be\n  // colored (vs dividing lines); we default to 0.77 which seems\n  // to work pretty well.  It should be a number between probably\n  // 0.4 and 0.9.\n  public get3d(colorfrac: number = DEFAULT_COLOR_FRACTION): StickerDat {\n    const stickers: any = [];\n    const foundations: any = [];\n    const rot = this.getInitial3DRotation();\n    const faces: any = [];\n    const maxdist: number = 0.52 * this.basefaces[0][0].len();\n    let avgstickerarea = 0;\n    for (let i = 0; i < this.basefaces.length; i++) {\n      const coords = rot.rotateface(this.basefaces[i]);\n      const name = this.facenames[i][1];\n      faces.push({ coords: toFaceCoords(coords, maxdist), name });\n      avgstickerarea += this.polyarea(faces[i].coords);\n    }\n    avgstickerarea /= this.faces.length;\n    const trim = (Math.sqrt(avgstickerarea) * (1 - Math.sqrt(colorfrac))) / 2;\n    for (let i = 0; i < this.faces.length; i++) {\n      const facenum = Math.floor(i / this.stickersperface);\n      const cubie = this.facetocubies[i][0];\n      const cubieori = this.facetocubies[i][1];\n      const cubiesetnum = this.cubiesetnums[cubie];\n      const cubieord = this.cubieordnums[cubie];\n      const color = this.graybyori(cubie)\n        ? \"#808080\"\n        : this.colors[this.facenames[facenum][1]];\n      let coords = rot.rotateface(this.faces[i]);\n      foundations.push({\n        coords: toFaceCoords(coords, maxdist),\n        color,\n        orbit: this.cubiesetnames[cubiesetnum],\n        ord: cubieord,\n        ori: cubieori,\n      });\n      const fcoords = coords;\n      if (trim && trim > 0) {\n        coords = trimEdges(coords, trim);\n      }\n      stickers.push({\n        coords: toFaceCoords(coords, maxdist),\n        color,\n        orbit: this.cubiesetnames[cubiesetnum],\n        ord: cubieord,\n        ori: cubieori,\n      });\n      if (this.duplicatedFaces[i]) {\n        for (let jj = 1; jj < this.duplicatedFaces[i]; jj++) {\n          stickers.push({\n            coords: toFaceCoords(coords, maxdist),\n            color,\n            orbit: this.cubiesetnames[cubiesetnum],\n            ord: cubieord,\n            ori: jj,\n          });\n          foundations.push({\n            coords: toFaceCoords(fcoords, maxdist),\n            color,\n            orbit: this.cubiesetnames[cubiesetnum],\n            ord: cubieord,\n            ori: jj,\n          });\n        }\n      }\n    }\n    const grips: StickerDatAxis[] = [];\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const msg = this.movesetgeos[i];\n      const order = this.movesetorders[i];\n      for (let j = 0; j < this.geonormals.length; j++) {\n        const gn = this.geonormals[j];\n        if (msg[0] === gn[1] && msg[1] === gn[2]) {\n          grips.push([toCoords(gn[0].rotatepoint(rot), 1), msg[0], order]);\n          grips.push([\n            toCoords(gn[0].rotatepoint(rot).smul(-1), 1),\n            msg[2],\n            order,\n          ]);\n        }\n      }\n    }\n    const f = (function () {\n      return function (mv: BlockMove): string {\n        return this.unswizzle(mv);\n      };\n    })().bind(this);\n    return {\n      stickers,\n      foundations,\n      faces,\n      axis: grips,\n      unswizzle: f,\n      notationMapper: this.notationMapper,\n    };\n  }\n\n  //  From the name of a geometric element (face, vertex, edge), get a\n  //  normal vector respecting the default orientation.  This is useful\n  //  to define the initial position of the camera in a 3D scene.  The\n  //  return value is normalized, so multiply it by the camera distance.\n  //  Returns undefined if no such geometric element.\n  public getGeoNormal(geoname: string): number[] | undefined {\n    const rot = this.getInitial3DRotation();\n    const grip = this.swizzler.unswizzle(geoname);\n    for (let j = 0; j < this.geonormals.length; j++) {\n      const gn = this.geonormals[j];\n      if (grip === gn[1]) {\n        const r = toCoords(gn[0].rotatepoint(rot), 1);\n        //  This routine is intended to use for the camera location.\n        //  If the camera location is vertical, and we give some\n        //  near-zero values for x and z, then the rotation in the\n        //  X/Z plane will be somewhat arbitrary.  So we clean up the\n        //  returned vector here.  We give a very slight positive\n        //  z value.\n        if (Math.abs(r[0]) < eps && Math.abs(r[2]) < eps) {\n          r[0] = 0.0;\n          r[2] = 1e-6;\n        }\n        return r;\n      }\n    }\n    return undefined;\n  }\n\n  private getfaceindex(facenum: number): number {\n    const divid = this.stickersperface;\n    return Math.floor(facenum / divid);\n  }\n}\n\nclass PGNotation implements MoveNotation {\n  private cache: { [key: string]: KTransformation } = {};\n  constructor(public pg: PuzzleGeometry, public od: OrbitsDef) {}\n\n  public lookupMove(move: BlockMove): KTransformation | undefined {\n    const key = this.blockMoveToString(move);\n    if (key in this.cache) {\n      return this.cache[key];\n    }\n    const mv = this.pg.parseBlockMove(move);\n    let bits = (2 << mv[3]) - (1 << mv[2]);\n    if (!mv[4]) {\n      const slices = this.pg.moveplanesets[mv[1]].length;\n      bits = (2 << (slices - mv[2])) - (1 << (slices - mv[3]));\n    }\n    const pgmv = this.pg.getMoveFromBits(\n      bits,\n      mv[5],\n      !mv[4],\n      this.pg.cmovesbyslice[mv[1]],\n      undefined,\n      this.pg.movesetorders[mv[1]],\n    );\n    const r = this.od.transformToKPuzzle(pgmv);\n    this.cache[key] = r;\n    return r;\n  }\n\n  // This is only used to construct keys, so does not need to be beautiful.\n  private blockMoveToString(mv: BlockMove): string {\n    let r = \"\";\n    if (mv.outerLayer) {\n      r = r + mv.outerLayer + \",\";\n    }\n    if (mv.innerLayer) {\n      r = r + mv.innerLayer + \",\";\n    }\n    r = r + mv.family + \",\" + mv.amount;\n    return r;\n  }\n}\n", "/* tslint:disable no-bitwise */\n/* tslint:disable prefer-for-of */ // TODO\n/* tslint:disable only-arrow-functions */ // TODO\n/* tslint:disable typedef */ // TODO\n\nimport { iota, zeros, Perm } from \"./Perm\";\nimport {\n  Orbit,\n  OrbitDef,\n  OrbitsDef,\n  showcanon,\n  Transformation,\n  VisibleState,\n} from \"./PermOriSet\";\nimport {\n  closure,\n  cube,\n  dodecahedron,\n  getface,\n  icosahedron,\n  octahedron,\n  tetrahedron,\n  uniqueplanes,\n} from \"./PlatonicGenerator\";\nimport { PuzzleDescriptionString, Puzzles, PuzzleName } from \"./Puzzles\";\nimport { centermassface, expandfaces, Quat } from \"./Quat\";\nimport {\n  BlockMove,\n  KPuzzleDefinition,\n  MoveNotation,\n  Transformation as KTransformation,\n} from \"./interfaces\";\nimport {\n  FaceRenamingMapper,\n  MegaminxScramblingNotationMapper,\n  NotationMapper,\n  NullMapper,\n  NxNxNCubeMapper,\n} from \"./NotationMapper\";\nimport { FaceNameSwizzler } from \"./FaceNameSwizzler\";\n\nconst DEFAULT_COLOR_FRACTION = 0.77;\n\nexport interface StickerDatSticker {\n  coords: number[][];\n  color: string;\n  orbit: string;\n  ord: number;\n  ori: number;\n}\n\nexport interface StickerDatFace {\n  coords: number[][];\n  name: string;\n}\n\nexport type StickerDatAxis = [number[], string, number];\n\nexport interface StickerDat {\n  stickers: StickerDatSticker[];\n  foundations: StickerDatSticker[];\n  faces: StickerDatFace[];\n  axis: StickerDatAxis[];\n  unswizzle(mv: BlockMove): string;\n  notationMapper: NotationMapper;\n}\n\n// TODO: Remove this once we no longer have prefix restrictions.\nlet NEW_FACE_NAMES = true;\nexport function useNewFaceNames(use: boolean): void {\n  NEW_FACE_NAMES = use;\n}\n\n//  Now we have a geometry class that does the 3D goemetry to calculate\n//  individual sticker information from a Platonic solid and a set of\n//  cuts.  The cuts must have the same symmetry as the Platonic solid;\n//  we even restrict them further to be either vertex-normal,\n//  edge-normal, or face-parallel cuts.  Right now our constructor takes\n//  a character solid indicator (one of c(ube), o(ctahedron), i(cosahedron),\n//  t(etradron), or d(odecahedron), followed by an array of cuts.\n//  Each cut is a character normal indicator that is either f(ace),\n//  e(dge), or v(ertex), followed by a floating point value that gives\n//  the depth of the cut where 0 is the center and 1 is the outside\n//  border of the shape in that direction.\n\n//  This is a heavyweight class with lots of members and construction\n//  is slow.  Be gentle.\n\n//  Everything except a very few methods should be considered private.\n\nconst eps: number = 1e-9;\nconst copyright = \"PuzzleGeometry 0.1 Copyright 2018 Tomas Rokicki.\";\nconst permissivieMoveParsing = false;\n\n// This is a description of the nets and the external names we give each\n// face.  The names should be a set of prefix-free upper-case alphabetics\n// so\n// we can easily also name and distinguish vertices and edges, but we\n// may change this in the future.  The nets consist of a list of lists.\n// Each list gives the name of a face, and then the names of the\n// faces connected to that face (in the net) in clockwise order.\n// The length of each list should be one more than the number of\n// edges in the regular polygon for that face.  All polygons must\n// have the same number of edges.\n// The first two faces in the first list must describe a horizontal edge\n// that is at the bottom of a regular polygon.  The first two faces in\n// every subsequent list for a given polytope must describe a edge that\n// is directly connected in the net and has already been described (this\n// sets the location and orientation of the polygon for that face.\n// Any edge that is not directly connected in the net should be given\n// the empty string as the other face.  All faces do not need to have\n// a list starting with that face; just enough to describe the full\n// connectivity of the net.\n//\n// TODO: change this back to a const JSON definition.\nfunction defaultnets(): any {\n  return {\n    // four faces: tetrahedron\n    4: [[\"F\", \"D\", \"L\", \"R\"]],\n    // six faces: cube\n    6: [\n      [\"F\", \"D\", \"L\", \"U\", \"R\"],\n      [\"R\", \"F\", \"\", \"B\", \"\"],\n    ],\n    // eight faces: octahedron\n    8: [\n      [\"F\", \"D\", \"L\", \"R\"],\n      [\"D\", \"F\", \"BR\", \"\"],\n      [\"BR\", \"D\", \"\", \"BB\"],\n      [\"BB\", \"BR\", \"U\", \"BL\"],\n    ],\n    // twelve faces:  dodecahedron; U/F/R/F/BL/BR from megaminx\n    12: [\n      [\"U\", \"F\", \"\", \"\", \"\", \"\"],\n      [\"F\", \"U\", \"R\", \"C\", \"A\", \"L\"],\n      [\"R\", \"F\", \"\", \"\", \"E\", \"\"],\n      [\"E\", \"R\", \"\", \"BF\", \"\", \"\"],\n      [\"BF\", \"E\", \"BR\", \"BL\", \"I\", \"D\"],\n    ],\n    // twenty faces: icosahedron\n    20: [\n      [\"R\", \"C\", \"F\", \"E\"],\n      [\"F\", \"R\", \"L\", \"U\"],\n      [\"L\", \"F\", \"A\", \"\"],\n      [\"E\", \"R\", \"G\", \"I\"],\n      [\"I\", \"E\", \"S\", \"H\"],\n      [\"S\", \"I\", \"J\", \"B\"],\n      [\"B\", \"S\", \"K\", \"D\"],\n      [\"K\", \"B\", \"M\", \"O\"],\n      [\"O\", \"K\", \"P\", \"N\"],\n      [\"P\", \"O\", \"Q\", \"\"],\n    ],\n  };\n}\n\n// TODO: change this back to a const JSON definition.\nfunction defaultcolors(): any {\n  return {\n    // the colors should use the same naming convention as the nets, above.\n    4: { F: \"#00ff00\", D: \"#ffff00\", L: \"#ff0000\", R: \"#0000ff\" },\n    6: {\n      U: \"#ffffff\",\n      F: \"#00ff00\",\n      R: \"#ff0000\",\n      D: \"#ffff00\",\n      B: \"#0000ff\",\n      L: \"#ff8000\",\n    },\n    8: {\n      U: \"#ffffff\",\n      F: \"#ff0000\",\n      R: \"#00bb00\",\n      D: \"#ffff00\",\n      BB: \"#1122ff\",\n      L: \"#9524c5\",\n      BL: \"#ff8800\",\n      BR: \"#aaaaaa\",\n    },\n    12: {\n      U: \"#ffffff\",\n      F: \"#006633\",\n      R: \"#ff0000\",\n      C: \"#ffffd0\",\n      A: \"#3399ff\",\n      L: \"#660099\",\n      E: \"#ff66cc\",\n      BF: \"#99ff00\",\n      BR: \"#0000ff\",\n      BL: \"#ffff00\",\n      I: \"#ff6633\",\n      D: \"#999999\",\n    },\n    20: {\n      R: \"#db69f0\",\n      C: \"#178fde\",\n      F: \"#23238b\",\n      E: \"#9cc726\",\n      L: \"#2c212d\",\n      U: \"#177fa7\",\n      A: \"#e0de7f\",\n      G: \"#2b57c0\",\n      I: \"#41126b\",\n      S: \"#4b8c28\",\n      H: \"#7c098d\",\n      J: \"#7fe7b4\",\n      B: \"#85fb74\",\n      K: \"#3f4bc3\",\n      D: \"#0ff555\",\n      M: \"#f1c2c8\",\n      O: \"#58d340\",\n      P: \"#c514f2\",\n      N: \"#14494e\",\n      Q: \"#8b1be1\",\n    },\n  };\n}\n\n// the default precedence of the faces is given here.  This permits\n// the orientations to be reasonably predictable.  There are tradeoffs;\n// some face precedence orders do better things to the edge orientations\n// than the corner orientations and some are the opposite.\n// TODO: change this back to a const JSON definition.\nfunction defaultfaceorders(): any {\n  return {\n    4: [\"F\", \"D\", \"L\", \"R\"],\n    6: [\"U\", \"D\", \"F\", \"B\", \"L\", \"R\"],\n    8: [\"F\", \"BB\", \"D\", \"U\", \"BR\", \"L\", \"R\", \"BL\"],\n    12: [\"L\", \"E\", \"F\", \"BF\", \"R\", \"I\", \"U\", \"D\", \"BR\", \"A\", \"BL\", \"C\"],\n    20: [\n      \"L\",\n      \"S\",\n      \"E\",\n      \"O\",\n      \"F\",\n      \"B\",\n      \"I\",\n      \"P\",\n      \"R\",\n      \"K\",\n      \"U\",\n      \"D\",\n      \"J\",\n      \"A\",\n      \"Q\",\n      \"H\",\n      \"G\",\n      \"N\",\n      \"M\",\n      \"C\",\n    ],\n  };\n}\n\n/*\n *  Default orientations for the puzzles in 3D space.  Can be overridden\n *  by puzzleOrientation or puzzleOrientations options.\n *\n *  These are defined to have a strong intuitive vertical (y) direction\n *  since 3D orbital controls need this.  In comments, we list the\n *  preferred initial camera orientation for each puzzle for twizzle;\n *  this information is explicitly given in the twizzle app file.\n */\n// TODO: change this back to a const JSON definition.\nfunction defaultOrientations(): any {\n  return {\n    4: [\"FLR\", [0, 1, 0], \"F\", [0, 0, 1]], // FLR towards viewer\n    6: [\"U\", [0, 1, 0], \"F\", [0, 0, 1]], // URF towards viewer\n    8: [\"U\", [0, 1, 0], \"F\", [0, 0, 1]], // FLUR towards viewer\n    12: [\"U\", [0, 1, 0], \"F\", [0, 0, 1]], // F towards viewer\n    20: [\"GUQMJ\", [0, 1, 0], \"F\", [0, 0, 1]], // F towards viewer\n  };\n}\n\nfunction findelement(a: any[], p: Quat): number {\n  // find something in facenames, vertexnames, edgenames\n  for (let i = 0; i < a.length; i++) {\n    if (a[i][0].dist(p) < eps) {\n      return i;\n    }\n  }\n  throw new Error(\"Element not found\");\n}\n\nexport function getpuzzles(): { [s: string]: PuzzleDescriptionString } {\n  // get some simple definitions of basic puzzles\n  return Puzzles;\n}\n\nexport function getpuzzle(puzzleName: PuzzleName): PuzzleDescriptionString {\n  // get some simple definitions of basic puzzles\n  return Puzzles[puzzleName];\n}\n\nexport function parsedesc(s: string): any {\n  // parse a text description\n  const a = s.split(/ /).filter(Boolean);\n  if (a.length % 2 === 0) {\n    return false;\n  }\n  if (\n    a[0] !== \"o\" &&\n    a[0] !== \"c\" &&\n    a[0] !== \"i\" &&\n    a[0] !== \"d\" &&\n    a[0] !== \"t\"\n  ) {\n    return false;\n  }\n  const r = [];\n  for (let i = 1; i < a.length; i += 2) {\n    if (a[i] !== \"f\" && a[i] !== \"v\" && a[i] !== \"e\") {\n      return false;\n    }\n    r.push([a[i], a[i + 1]]);\n  }\n  return [a[0], r];\n}\n\nexport function getPuzzleGeometryByDesc(\n  desc: string,\n  options: string[] = [],\n): PuzzleGeometry {\n  const [shape, cuts] = parsedesc(desc);\n  const pg = new PuzzleGeometry(\n    shape,\n    cuts,\n    [\"allmoves\", \"true\"].concat(options),\n  );\n  pg.allstickers();\n  pg.genperms();\n  return pg;\n}\n\nexport function getPuzzleGeometryByName(\n  puzzleName: PuzzleName,\n  options: string[] = [],\n): PuzzleGeometry {\n  return getPuzzleGeometryByDesc(Puzzles[puzzleName], options);\n}\n\nfunction getmovename(geo: any, bits: number, slices: number): any {\n  // generate a move name based on bits, slice, and geo\n  // if the move name is from the opposite face, say so.\n  // find the face that's turned.\n  let nbits = 0;\n  let inverted = false;\n  for (let i = 0; i <= slices; i++) {\n    if ((bits >> i) & 1) {\n      nbits |= 1 << (slices - i);\n    }\n  }\n  if (nbits < bits) {\n    // flip if most of the move is on the other side\n    geo = [geo[2], geo[3], geo[0], geo[1]];\n    bits = nbits;\n    inverted = true;\n  }\n  let movenameFamily = geo[0];\n  let movenamePrefix = \"\";\n  let hibit = 0;\n  while (bits >> (1 + hibit)) {\n    hibit++;\n  }\n  if (bits === (2 << slices) - 1) {\n    movenameFamily = movenameFamily + \"v\";\n  } else if (bits === 1 << hibit) {\n    if (hibit > 0) {\n      movenamePrefix = String(hibit + 1);\n    }\n  } else if (bits === (2 << hibit) - 1) {\n    movenameFamily = movenameFamily.toLowerCase();\n    if (hibit > 1) {\n      movenamePrefix = String(hibit + 1);\n    }\n  } else {\n    movenamePrefix = \"_\" + bits + \"_\";\n    //       throw \"We only support slice and outer block moves right now. \" + bits ;\n  }\n  return [movenamePrefix + movenameFamily, inverted];\n}\n\n// split a geometrical element into face names.  Do greedy match.\n// Permit underscores between names.\nfunction splitByFaceNames(s: string, facenames: any[]): string[] {\n  const r: string[] = [];\n  let at = 0;\n  while (at < s.length) {\n    if (at > 0 && at < s.length && s[at] === \"_\") {\n      at++;\n    }\n    let currentMatch = \"\";\n    for (let i = 0; i < facenames.length; i++) {\n      if (\n        s.substr(at).startsWith(facenames[i][1]) &&\n        facenames[i][1].length > currentMatch.length\n      ) {\n        currentMatch = facenames[i][1];\n      }\n    }\n    if (currentMatch !== \"\") {\n      r.push(currentMatch);\n      at += currentMatch.length;\n    } else {\n      throw new Error(\"Could not split \" + s + \" into face names.\");\n    }\n  }\n  return r;\n}\n\nfunction toCoords(q: Quat, maxdist: number): number[] {\n  return [q.b / maxdist, -q.c / maxdist, q.d / maxdist];\n}\n\nfunction toFaceCoords(q: Quat[], maxdist: number): number[][] {\n  const r = [];\n  const n = q.length;\n  for (let i = 0; i < n; i++) {\n    r[n - i - 1] = toCoords(q[i], maxdist);\n  }\n  return r;\n}\n\nfunction trimEdges(face: Quat[], tr: number): Quat[] {\n  const r: Quat[] = [];\n  for (let iter = 1; iter < 10; iter++) {\n    for (let i = 0; i < face.length; i++) {\n      const pi = (i + face.length - 1) % face.length;\n      const ni = (i + 1) % face.length;\n      const A = face[pi].sub(face[i]).normalize();\n      const B = face[ni].sub(face[i]).normalize();\n      const d = A.dot(B);\n      const m = tr / Math.sqrt(1 - d * d);\n      r[i] = face[i].sum(A.sum(B).smul(m));\n    }\n    let good = true;\n    for (let i = 0; good && i < r.length; i++) {\n      const pi = (i + face.length - 1) % face.length;\n      const ni = (i + 1) % face.length;\n      if (r[pi].sub(r[i]).cross(r[ni].sub(r[i])).dot(r[i]) >= 0) {\n        good = false;\n      }\n    }\n    if (good) {\n      return r;\n    }\n    tr /= 2;\n  }\n  return face;\n}\n\nexport class PuzzleGeometry {\n  public args: string = \"\";\n  public rotations: Quat[]; // all members of the rotation group\n  public baseplanerot: Quat[]; // unique rotations of the baseplane\n  public baseplanes: Quat[]; // planes, corresponding to faces\n  public facenames: any[]; // face names\n  public faceplanes: any; // face planes\n  public edgenames: any[]; // edge names\n  public vertexnames: any[]; // vertexnames\n  public geonormals: any[]; // all geometric directions, with names and types\n  public moveplanes: Quat[]; // the planes that split moves\n  public moveplanes2: Quat[]; // the planes that split moves, filtered\n  public moveplanesets: any[]; // the move planes, in parallel sets\n  public moveplanenormals: Quat[]; // one move plane\n  public movesetorders: any[]; // the order of rotations for each move set\n  public movesetgeos: any[]; // geometric feature information for move sets\n  public basefaces: Quat[][]; // polytope faces before cuts\n  public faces: Quat[][]; // all the stickers\n  public basefacecount: number; // number of base faces\n  public stickersperface: number; // number of stickers per face\n  public cornerfaces: number; // number of faces that meet at a corner\n  public cubies: any[]; // the cubies\n  public shortedge: number; // shortest edge\n  public vertexdistance: number; // vertex distance\n  public edgedistance: number; // edge distance\n  public orbits: number; // count of cubie orbits\n  public facetocubies: any[]; // map a face to a cubie index and offset\n  public moverotations: Quat[][]; // move rotations\n  public cubiekey: any; // cubie locator\n  public cubiekeys: string[]; // cubie keys\n  public facelisthash: any; // face list by key\n  public cubiesetnames: any[]; // cubie set names\n  public cubieords: number[]; // the size of each orbit\n  public cubiesetnums: number[];\n  public cubieordnums: number[];\n  public orbitoris: number[]; // the orientation size of each orbit\n  public cubievaluemap: number[]; // the map for identical cubies\n  public cubiesetcubies: number[][]; // cubies in each cubie set\n  public cmovesbyslice: number[][][] = []; // cmoves as perms by slice\n  // options\n  public verbose: number = 0; // verbosity (console.log)\n  public allmoves: boolean = false; // generate all slice moves in ksolve\n  public outerblockmoves: boolean; // generate outer block moves\n  public vertexmoves: boolean; // generate vertex moves\n  public addrotations: boolean; // add symmetry information to ksolve output\n  public movelist: any; // move list to generate\n  public parsedmovelist: any; // parsed move list\n  public puzzleOrientation: any; // single puzzle orientation from options\n  public puzzleOrientations: any; // puzzle orientation override list from options\n  public cornersets: boolean = true; // include corner sets\n  public centersets: boolean = true; // include center sets\n  public edgesets: boolean = true; // include edge sets\n  public graycorners: boolean = false; // make corner sets gray\n  public graycenters: boolean = false; // make center sets gray\n  public grayedges: boolean = false; // make edge sets gray\n  public killorientation: boolean = false; // eliminate any orientations\n  public optimize: boolean = false; // optimize PermOri\n  public scramble: number = 0; // scramble?\n  public ksolvemovenames: string[]; // move names from ksolve\n  public fixPiece: string = \"\"; // fix a piece?\n  public orientCenters: boolean = false; // orient centers?\n  public duplicatedFaces: number[] = []; // which faces are duplicated\n  public duplicatedCubies: number[] = []; // which cubies are duplicated\n  public fixedCubie: number = -1; // fixed cubie, if any\n  public svggrips: any[]; // grips from svg generation by svg coordinate\n  public net: any = [];\n  public colors: any = [];\n  public faceorder: any = [];\n  public faceprecedence: number[] = [];\n  public swizzler: FaceNameSwizzler;\n  public notationMapper: NotationMapper = new NullMapper();\n  public addNotationMapper: string = \"\";\n  constructor(shape: string, cuts: string[][], optionlist: any[] | undefined) {\n    function asstructured(v: any): any {\n      if (typeof v === \"string\") {\n        return JSON.parse(v);\n      }\n      return v;\n    }\n    function asboolean(v: any): boolean {\n      if (typeof v === \"string\") {\n        if (v === \"false\") {\n          return false;\n        }\n        return true;\n      } else {\n        return v ? true : false;\n      }\n    }\n    if (optionlist !== undefined) {\n      if (optionlist.length % 2 !== 0) {\n        throw new Error(\"Odd length in option list?\");\n      }\n      for (let i = 0; i < optionlist.length; i += 2) {\n        if (optionlist[i] === \"verbose\") {\n          this.verbose++;\n        } else if (optionlist[i] === \"quiet\") {\n          this.verbose = 0;\n        } else if (optionlist[i] === \"allmoves\") {\n          this.allmoves = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"outerblockmoves\") {\n          this.outerblockmoves = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"vertexmoves\") {\n          this.vertexmoves = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"rotations\") {\n          this.addrotations = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"cornersets\") {\n          this.cornersets = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"centersets\") {\n          this.centersets = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"edgesets\") {\n          this.edgesets = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"graycorners\") {\n          this.graycorners = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"graycenters\") {\n          this.graycenters = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"grayedges\") {\n          this.grayedges = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"movelist\") {\n          this.movelist = asstructured(optionlist[i + 1]);\n        } else if (optionlist[i] === \"killorientation\") {\n          this.killorientation = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"optimize\") {\n          this.optimize = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"scramble\") {\n          this.scramble = optionlist[i + 1];\n        } else if (optionlist[i] === \"fix\") {\n          this.fixPiece = optionlist[i + 1];\n        } else if (optionlist[i] === \"orientcenters\") {\n          this.orientCenters = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"puzzleorientation\") {\n          this.puzzleOrientation = asstructured(optionlist[i + 1]);\n        } else if (optionlist[i] === \"puzzleorientations\") {\n          this.puzzleOrientations = asstructured(optionlist[i + 1]);\n        } else {\n          throw new Error(\n            \"Bad option while processing option list \" + optionlist[i],\n          );\n        }\n      }\n    }\n    this.args = shape + \" \" + cuts.map((_) => _.join(\" \")).join(\" \");\n    if (optionlist) {\n      this.args += \" \" + optionlist.join(\" \");\n    }\n    if (this.verbose > 0) {\n      console.log(this.header(\"# \"));\n    }\n    this.create(shape, cuts);\n  }\n\n  public create(shape: string, cuts: any[]): void {\n    // create the shape, doing all the essential geometry\n    // create only goes far enough to figure out how many stickers per\n    // face, and what the short edge is.  If the short edge is too short,\n    // we probably don't want to display or manipulate this one.  How\n    // short is too short is hard to say.\n    // var that = this ; // TODO\n    this.moveplanes = [];\n    this.moveplanes2 = [];\n    this.faces = [];\n    this.cubies = [];\n    let g = null;\n    switch (shape) {\n      case \"c\":\n        g = cube();\n        break;\n      case \"o\":\n        g = octahedron();\n        break;\n      case \"i\":\n        g = icosahedron();\n        break;\n      case \"t\":\n        g = tetrahedron();\n        break;\n      case \"d\":\n        g = dodecahedron();\n        break;\n      default:\n        throw new Error(\"Bad shape argument: \" + shape);\n    }\n    this.rotations = closure(g);\n    if (this.verbose) {\n      console.log(\"# Rotations: \" + this.rotations.length);\n    }\n    const baseplane = g[0];\n    this.baseplanerot = uniqueplanes(baseplane, this.rotations);\n    const baseplanes = this.baseplanerot.map((_) => baseplane.rotateplane(_));\n    this.baseplanes = baseplanes;\n    this.basefacecount = baseplanes.length;\n    const net = defaultnets()[baseplanes.length];\n    this.net = net;\n    this.colors = defaultcolors()[baseplanes.length];\n    this.faceorder = defaultfaceorders()[baseplanes.length];\n    if (this.verbose) {\n      console.log(\"# Base planes: \" + baseplanes.length);\n    }\n    const baseface = getface(baseplanes);\n    const zero = new Quat(0, 0, 0, 0);\n    if (this.verbose) {\n      console.log(\"# Face vertices: \" + baseface.length);\n    }\n    const facenormal = baseplanes[0].makenormal();\n    const edgenormal = baseface[0].sum(baseface[1]).makenormal();\n    const vertexnormal = baseface[0].makenormal();\n    const boundary = new Quat(1, facenormal.b, facenormal.c, facenormal.d);\n    if (this.verbose) {\n      console.log(\"# Boundary is \" + boundary);\n    }\n    const planerot = uniqueplanes(boundary, this.rotations);\n    const planes = planerot.map((_) => boundary.rotateplane(_));\n    let faces = [getface(planes)];\n    this.edgedistance = faces[0][0].sum(faces[0][1]).smul(0.5).dist(zero);\n    this.vertexdistance = faces[0][0].dist(zero);\n    const cutplanes = [];\n    const intersects = [];\n    let sawface = false; // what cuts did we see?\n    let sawedge = false;\n    let sawvertex = false;\n    for (let i = 0; i < cuts.length; i++) {\n      let normal = null;\n      let distance = 0;\n      switch (cuts[i][0]) {\n        case \"f\":\n          normal = facenormal;\n          distance = 1;\n          sawface = true;\n          break;\n        case \"v\":\n          normal = vertexnormal;\n          distance = this.vertexdistance;\n          sawvertex = true;\n          break;\n        case \"e\":\n          normal = edgenormal;\n          distance = this.edgedistance;\n          sawedge = true;\n          break;\n        default:\n          throw new Error(\"Bad cut argument: \" + cuts[i][0]);\n      }\n      cutplanes.push(normal.makecut(cuts[i][1]));\n      intersects.push(cuts[i][1] < distance);\n    }\n    if (this.addrotations) {\n      if (!sawface) {\n        cutplanes.push(facenormal.makecut(10));\n      }\n      if (!sawvertex) {\n        cutplanes.push(vertexnormal.makecut(10));\n      }\n      if (!sawedge) {\n        cutplanes.push(edgenormal.makecut(10));\n      }\n    }\n    this.basefaces = [];\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(faces[0]);\n      this.basefaces.push(face);\n    }\n    //\n    //   Determine names for edges, vertices, and planes.  Planes are defined\n    //   by the plane normal/distance; edges are defined by the midpoint;\n    //   vertices are defined by actual point.  In each case we define a name.\n    //   Note that edges have two potential names, and corners have n where\n    //   n planes meet at a vertex.  We arbitrarily choose the one that is\n    //   alphabetically first (and we will probably want to change this).\n    //\n    const facenames: any[] = [];\n    const faceplanes = [];\n    const vertexnames: any[] = [];\n    const edgenames: any[] = [];\n    const edgesperface = faces[0].length;\n    function searchaddelement(a: any[], p: Quat, name: any): void {\n      for (let i = 0; i < a.length; i++) {\n        if (a[i][0].dist(p) < eps) {\n          a[i].push(name);\n          return;\n        }\n      }\n      a.push([p, name]);\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(faces[0]);\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        searchaddelement(edgenames, midpoint, i);\n      }\n    }\n    const otherfaces = [];\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(faces[0]);\n      const facelist = [];\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        const el = edgenames[findelement(edgenames, midpoint)];\n        if (i === el[1]) {\n          facelist.push(el[2]);\n        } else if (i === el[2]) {\n          facelist.push(el[1]);\n        } else {\n          throw new Error(\"Could not find edge\");\n        }\n      }\n      otherfaces.push(facelist);\n    }\n    const facenametoindex: any = {};\n    const faceindextoname: any = [];\n    faceindextoname.push(net[0][0]);\n    facenametoindex[net[0][0]] = 0;\n    faceindextoname[otherfaces[0][0]] = net[0][1];\n    facenametoindex[net[0][1]] = otherfaces[0][0];\n    for (let i = 0; i < net.length; i++) {\n      const f0 = net[i][0];\n      const fi = facenametoindex[f0];\n      if (fi === undefined) {\n        throw new Error(\"Bad edge description; first edge not connected\");\n      }\n      let ii = -1;\n      for (let j = 0; j < otherfaces[fi].length; j++) {\n        const fn2 = faceindextoname[otherfaces[fi][j]];\n        if (fn2 !== undefined && fn2 === net[i][1]) {\n          ii = j;\n          break;\n        }\n      }\n      if (ii < 0) {\n        throw new Error(\"First element of a net not known\");\n      }\n      for (let j = 2; j < net[i].length; j++) {\n        if (net[i][j] === \"\") {\n          continue;\n        }\n        const of = otherfaces[fi][(j + ii - 1) % edgesperface];\n        const fn2 = faceindextoname[of];\n        if (fn2 !== undefined && fn2 !== net[i][j]) {\n          throw new Error(\"Face mismatch in net\");\n        }\n        faceindextoname[of] = net[i][j];\n        facenametoindex[net[i][j]] = of;\n      }\n    }\n    for (let i = 0; i < faceindextoname.length; i++) {\n      let found = false;\n      for (let j = 0; j < this.faceorder.length; j++) {\n        if (faceindextoname[i] === this.faceorder[j]) {\n          this.faceprecedence[i] = j;\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        throw new Error(\n          \"Could not find face \" +\n            faceindextoname[i] +\n            \" in face order list \" +\n            this.faceorder,\n        );\n      }\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(faces[0]);\n      const faceplane = boundary.rotateplane(this.baseplanerot[i]);\n      const facename = faceindextoname[i];\n      facenames.push([face, facename]);\n      faceplanes.push([faceplane, facename]);\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(faces[0]);\n      const facename = faceindextoname[i];\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        const jjj = (j + 2) % face.length;\n        const midpoint2 = face[jj].sum(face[jjj]).smul(0.5);\n        const e1 = findelement(edgenames, midpoint);\n        const e2 = findelement(edgenames, midpoint2);\n        searchaddelement(vertexnames, face[jj], [facename, e2, e1]);\n      }\n    }\n    this.swizzler = new FaceNameSwizzler(facenames.map((_: any) => _[1]));\n    const sep = this.swizzler.prefixFree ? \"\" : \"_\";\n    // fix the edge names; use face precedence order\n    for (let i = 0; i < edgenames.length; i++) {\n      if (edgenames[i].length !== 3) {\n        throw new Error(\"Bad length in edge names \" + edgenames[i]);\n      }\n      let c1 = faceindextoname[edgenames[i][1]];\n      const c2 = faceindextoname[edgenames[i][2]];\n      if (\n        this.faceprecedence[edgenames[i][1]] <\n        this.faceprecedence[edgenames[i][2]]\n      ) {\n        c1 = c1 + sep + c2;\n      } else {\n        c1 = c2 + sep + c1;\n      }\n      edgenames[i] = [edgenames[i][0], c1];\n    }\n    // fix the vertex names; clockwise rotations; low face first.\n    this.cornerfaces = vertexnames[0].length - 1;\n    for (let i = 0; i < vertexnames.length; i++) {\n      if (vertexnames[i].length < 4) {\n        throw new Error(\"Bad length in vertex names\");\n      }\n      let st = 1;\n      for (let j = 2; j < vertexnames[i].length; j++) {\n        if (\n          this.faceprecedence[facenametoindex[vertexnames[i][j][0]]] <\n          this.faceprecedence[facenametoindex[vertexnames[i][st][0]]]\n        ) {\n          st = j;\n        }\n      }\n      let r = \"\";\n      for (let j = 1; j < vertexnames[i].length; j++) {\n        if (j === 1) {\n          r = vertexnames[i][st][0];\n        } else {\n          r = r + sep + vertexnames[i][st][0];\n        }\n        for (let k = 1; k < vertexnames[i].length; k++) {\n          if (vertexnames[i][st][2] === vertexnames[i][k][1]) {\n            st = k;\n            break;\n          }\n        }\n      }\n      vertexnames[i] = [vertexnames[i][0], r];\n    }\n    if (this.verbose > 1) {\n      console.log(\"Face precedence list: \" + this.faceorder.join(\" \"));\n      console.log(\"Face names: \" + facenames.map((_: any) => _[1]).join(\" \"));\n      console.log(\"Edge names: \" + edgenames.map((_: any) => _[1]).join(\" \"));\n      console.log(\n        \"Vertex names: \" + vertexnames.map((_: any) => _[1]).join(\" \"),\n      );\n    }\n    const geonormals = [];\n    for (let i = 0; i < faceplanes.length; i++) {\n      geonormals.push([faceplanes[i][0].makenormal(), faceplanes[i][1], \"f\"]);\n    }\n    for (let i = 0; i < edgenames.length; i++) {\n      geonormals.push([edgenames[i][0].makenormal(), edgenames[i][1], \"e\"]);\n    }\n    for (let i = 0; i < vertexnames.length; i++) {\n      geonormals.push([vertexnames[i][0].makenormal(), vertexnames[i][1], \"v\"]);\n    }\n    this.facenames = facenames;\n    this.faceplanes = faceplanes;\n    this.edgenames = edgenames;\n    this.vertexnames = vertexnames;\n    this.geonormals = geonormals;\n    const geonormalnames = geonormals.map((_: any) => _[1]);\n    this.swizzler.setGripNames(geonormalnames);\n    if (this.verbose) {\n      console.log(\n        \"# Distances: face \" +\n          1 +\n          \" edge \" +\n          this.edgedistance +\n          \" vertex \" +\n          this.vertexdistance,\n      );\n    }\n    // expand cutplanes by rotations.  We only work with one face here.\n    for (let c = 0; c < cutplanes.length; c++) {\n      for (let i = 0; i < this.rotations.length; i++) {\n        const q = cutplanes[c].rotateplane(this.rotations[i]);\n        let wasseen = false;\n        for (let j = 0; j < this.moveplanes.length; j++) {\n          if (q.sameplane(this.moveplanes[j])) {\n            wasseen = true;\n            break;\n          }\n        }\n        if (!wasseen) {\n          this.moveplanes.push(q);\n          faces = q.cutfaces(faces);\n          if (intersects[c]) {\n            this.moveplanes2.push(q);\n          }\n        }\n      }\n    }\n    this.faces = faces;\n    if (this.verbose) {\n      console.log(\"# Faces is now \" + faces.length);\n    }\n    this.stickersperface = faces.length;\n    //  Find and report the shortest edge in any of the faces.  If this\n    //  is small the puzzle is probably not practical or displayable.\n    let shortedge = 1e99;\n    for (let i = 0; i < faces.length; i++) {\n      for (let j = 0; j < faces[i].length; j++) {\n        const k = (j + 1) % faces[i].length;\n        const t = faces[i][j].dist(faces[i][k]);\n        if (t < shortedge) {\n          shortedge = t;\n        }\n      }\n    }\n    this.shortedge = shortedge;\n    if (this.verbose) {\n      console.log(\"# Short edge is \" + shortedge);\n    }\n    // add nxnxn cube notation if it has cube face moves\n    if (shape === \"c\" && sawface) {\n      // In this case the mapper adding is deferred until we\n      // know the number of slices.\n      this.addNotationMapper = \"NxNxNCubeMapper\";\n    }\n    if (shape === \"o\" && sawface && NEW_FACE_NAMES) {\n      this.notationMapper = new FaceRenamingMapper(\n        this.swizzler,\n        new FaceNameSwizzler([\"F\", \"D\", \"L\", \"BL\", \"R\", \"U\", \"BR\", \"B\"]),\n      );\n    }\n    if (shape === \"d\" && sawface && NEW_FACE_NAMES) {\n      this.addNotationMapper = \"Megaminx\";\n      this.notationMapper = new FaceRenamingMapper(\n        this.swizzler,\n        new FaceNameSwizzler([\n          \"U\",\n          \"F\",\n          \"L\",\n          \"BL\",\n          \"BR\",\n          \"R\",\n          \"FR\",\n          \"FL\",\n          \"DL\",\n          \"B\",\n          \"DR\",\n          \"D\",\n        ]),\n      );\n    }\n  }\n\n  public keyface(face: Quat[]): string {\n    // take a face and figure out the sides of each move plane\n    let s = \"\";\n    for (let i = 0; i < this.moveplanesets.length; i++) {\n      let t = 0;\n      for (let j = 0; j < this.moveplanesets[i].length; j++) {\n        if (this.moveplanesets[i][j].faceside(face) > 0) {\n          t++;\n        }\n      }\n      s = s + \" \" + t;\n    }\n    return s;\n  }\n\n  public findcubie(face: Quat[]): number {\n    return this.facetocubies[this.findface(face)][0];\n  }\n\n  public findface(face: Quat[]): number {\n    const cm = centermassface(face);\n    const key = this.keyface(face);\n    for (let i = 0; i < this.facelisthash[key].length; i++) {\n      const face2 = this.facelisthash[key][i];\n      if (Math.abs(cm.dist(centermassface(this.faces[face2]))) < eps) {\n        return face2;\n      }\n    }\n    throw new Error(\"Could not find face.\");\n  }\n\n  public project2d(facen: number, edgen: number, targvec: Quat[]): any {\n    // calculate geometry to map a particular edge of a particular\n    //  face to a given 2D vector.  The face is given as an index into the\n    //  facenames/baseplane arrays, and the edge is given as an offset into\n    //  the vertices.\n    const face = this.facenames[facen][0];\n    const edgen2 = (edgen + 1) % face.length;\n    const plane = this.baseplanes[facen];\n    let x0 = face[edgen2].sub(face[edgen]);\n    const olen = x0.len();\n    x0 = x0.normalize();\n    const y0 = x0.cross(plane).normalize();\n    let delta = targvec[1].sub(targvec[0]);\n    const len = delta.len() / olen;\n    delta = delta.normalize();\n    const cosr = delta.b;\n    const sinr = delta.c;\n    const x1 = x0.smul(cosr).sub(y0.smul(sinr)).smul(len);\n    const y1 = y0.smul(cosr).sum(x0.smul(sinr)).smul(len);\n    const off = new Quat(\n      0,\n      targvec[0].b - x1.dot(face[edgen]),\n      targvec[0].c - y1.dot(face[edgen]),\n      0,\n    );\n    return [x1, y1, off];\n  }\n\n  public allstickers(): void {\n    // next step is to calculate all the stickers and orbits\n    // We do enough work here to display the cube on the screen.\n    // take our newly split base face and expand it by the rotation matrix.\n    // this generates our full set of \"stickers\".\n    this.faces = expandfaces(this.baseplanerot, this.faces);\n    if (this.verbose) {\n      console.log(\"# Total stickers is now \" + this.faces.length);\n    }\n    // Split moveplanes into a list of parallel planes.\n    const moveplanesets: Quat[][] = [];\n    const moveplanenormals: Quat[] = [];\n    // get the normals, first, from unfiltered moveplanes.\n    for (let i = 0; i < this.moveplanes.length; i++) {\n      const q = this.moveplanes[i];\n      const qnormal = q.makenormal();\n      let wasseen = false;\n      for (let j = 0; j < moveplanenormals.length; j++) {\n        if (qnormal.sameplane(moveplanenormals[j].makenormal())) {\n          wasseen = true;\n        }\n      }\n      if (!wasseen) {\n        moveplanenormals.push(qnormal);\n        moveplanesets.push([]);\n      }\n    }\n    for (let i = 0; i < this.moveplanes2.length; i++) {\n      const q = this.moveplanes2[i];\n      const qnormal = q.makenormal();\n      for (let j = 0; j < moveplanenormals.length; j++) {\n        if (qnormal.sameplane(moveplanenormals[j])) {\n          moveplanesets[j].push(q);\n          break;\n        }\n      }\n    }\n    // make the normals all face the same way in each set.\n    for (let i = 0; i < moveplanesets.length; i++) {\n      const q: Quat[] = moveplanesets[i].map((_) => _.normalizeplane());\n      const goodnormal = moveplanenormals[i];\n      for (let j = 0; j < q.length; j++) {\n        if (q[j].makenormal().dist(goodnormal) > eps) {\n          q[j] = q[j].smul(-1);\n        }\n      }\n      q.sort((a, b) => a.a - b.a);\n      moveplanesets[i] = q;\n    }\n    this.moveplanesets = moveplanesets;\n    this.moveplanenormals = moveplanenormals;\n    const sizes = moveplanesets.map((_) => _.length);\n    if (this.verbose) {\n      console.log(\"# Move plane sets: \" + sizes);\n    }\n    // for each of the move planes, find the rotations that are relevant\n    const moverotations: Quat[][] = [];\n    for (let i = 0; i < moveplanesets.length; i++) {\n      moverotations.push([]);\n    }\n    for (let i = 0; i < this.rotations.length; i++) {\n      const q: Quat = this.rotations[i];\n      if (Math.abs(Math.abs(q.a) - 1) < eps) {\n        continue;\n      }\n      const qnormal = q.makenormal();\n      for (let j = 0; j < moveplanesets.length; j++) {\n        if (qnormal.sameplane(moveplanenormals[j])) {\n          moverotations[j].push(q);\n          break;\n        }\n      }\n    }\n    this.moverotations = moverotations;\n    //  Sort the rotations by the angle of rotation.  A bit tricky because\n    //  while the norms should be the same, they need not be.  So we start\n    //  by making the norms the same, and then sorting.\n    for (let i = 0; i < moverotations.length; i++) {\n      const r = moverotations[i];\n      const goodnormal = r[0].makenormal();\n      for (let j = 0; j < r.length; j++) {\n        if (goodnormal.dist(r[j].makenormal()) > eps) {\n          r[j] = r[j].smul(-1);\n        }\n      }\n      r.sort((a, b) => a.angle() - b.angle());\n      if (moverotations[i][0].dot(moveplanenormals[i]) < 0) {\n        r.reverse();\n      }\n    }\n    const sizes2 = moverotations.map((_) => 1 + _.length);\n    this.movesetorders = sizes2;\n    const movesetgeos = [];\n    let gtype = \"?\";\n    for (let i = 0; i < moveplanesets.length; i++) {\n      const p0 = moveplanenormals[i];\n      let neg = null;\n      let pos = null;\n      for (let j = 0; j < this.geonormals.length; j++) {\n        const d = p0.dot(this.geonormals[j][0]);\n        if (Math.abs(d - 1) < eps) {\n          pos = [this.geonormals[j][1], this.geonormals[j][2]];\n          gtype = this.geonormals[j][2];\n        } else if (Math.abs(d + 1) < eps) {\n          neg = [this.geonormals[j][1], this.geonormals[j][2]];\n          gtype = this.geonormals[j][2];\n        }\n      }\n      if (pos === null || neg === null) {\n        throw new Error(\"Saw positive or negative sides as null\");\n      }\n      movesetgeos.push([\n        pos[0],\n        pos[1],\n        neg[0],\n        neg[1],\n        1 + moveplanesets[i].length,\n      ]);\n      if (this.addNotationMapper === \"NxNxNCubeMapper\" && gtype === \"f\") {\n        this.notationMapper = new NxNxNCubeMapper(1 + moveplanesets[i].length);\n        this.addNotationMapper = \"\";\n      }\n      if (this.addNotationMapper === \"Megaminx\" && gtype === \"f\") {\n        if (1 + moveplanesets[i].length === 3) {\n          this.notationMapper = new MegaminxScramblingNotationMapper(\n            this.notationMapper,\n          );\n        }\n        this.addNotationMapper = \"\";\n      }\n    }\n    this.movesetgeos = movesetgeos;\n    //  Cubies are split by move plane sets.  For each cubie we can\n    //  average its points to find a point on the interior of that\n    //  cubie.  We can then check that point against all the move\n    //  planes and from that derive a coordinate for the cubie.\n    //  This also works for faces; no face should ever lie on a move\n    //  plane.  This allows us to take a set of stickers and break\n    //  them up into cubie sets.\n    const cubiehash: any = {};\n    const facelisthash: any = {};\n    const cubiekey: any = {};\n    const cubiekeys = [];\n    const cubies: Quat[][][] = [];\n    const faces = this.faces;\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      const s = this.keyface(face);\n      if (!cubiehash[s]) {\n        cubiekey[s] = cubies.length;\n        cubiekeys.push(s);\n        cubiehash[s] = [];\n        facelisthash[s] = [];\n        cubies.push(cubiehash[s]);\n      }\n      facelisthash[s].push(i);\n      cubiehash[s].push(face);\n      //  If we find a core cubie, split it up into multiple cubies,\n      //  because ksolve doesn't handle orientations that are not\n      //  cyclic, and the rotation group of the core is not cyclic.\n      if (facelisthash[s].length === this.basefacecount) {\n        if (this.verbose) {\n          console.log(\"# Splitting core.\");\n        }\n        for (let suff = 0; suff < this.basefacecount; suff++) {\n          const s2 = s + \" \" + suff;\n          facelisthash[s2] = [facelisthash[s][suff]];\n          cubiehash[s2] = [cubiehash[s][suff]];\n          cubiekeys.push(s2);\n          cubiekey[s2] = cubies.length;\n          cubies.push(cubiehash[s2]);\n        }\n        cubiehash[s] = [];\n        cubies[cubiekey[s]] = [];\n      }\n    }\n    this.cubiekey = cubiekey;\n    this.facelisthash = facelisthash;\n    this.cubiekeys = cubiekeys;\n    if (this.verbose) {\n      console.log(\"# Cubies: \" + Object.keys(cubiehash).length);\n    }\n    //  Sort the faces around each corner so they are clockwise.  Only\n    //  relevant for cubies that actually are corners (three or more\n    //  faces).  In general cubies might have many faces; for icosohedrons\n    //  there are five faces on the corner cubies.\n    this.cubies = cubies;\n    for (let k = 0; k < cubies.length; k++) {\n      const cubie = cubies[k];\n      if (cubie.length < 2) {\n        continue;\n      }\n      if (cubie.length === this.basefacecount) {\n        // looks like core?  don't sort\n        continue;\n      }\n      if (cubie.length > 5) {\n        throw new Error(\n          \"Bad math; too many faces on this cubie \" + cubie.length,\n        );\n      }\n      const s = this.keyface(cubie[0]);\n      const facelist = facelisthash[s];\n      const cm = cubie.map((_) => centermassface(_));\n      const cmall = centermassface(cm);\n      for (let looplimit = 0; cubie.length > 2; looplimit++) {\n        let changed = false;\n        for (let i = 0; i < cubie.length; i++) {\n          const j = (i + 1) % cubie.length;\n          // var ttt = cmall.dot(cm[i].cross(cm[j])) ; // TODO\n          if (cmall.dot(cm[i].cross(cm[j])) < 0) {\n            const t = cubie[i];\n            cubie[i] = cubie[j];\n            cubie[j] = t;\n            const u = cm[i];\n            cm[i] = cm[j];\n            cm[j] = u;\n            const v = facelist[i];\n            facelist[i] = facelist[j];\n            facelist[j] = v;\n            changed = true;\n          }\n        }\n        if (!changed) {\n          break;\n        }\n        if (looplimit > 1000) {\n          throw new Error(\"Bad epsilon math; too close to border\");\n        }\n      }\n      let mini = 0;\n      let minf = this.findface(cubie[mini]);\n      for (let i = 1; i < cubie.length; i++) {\n        const temp = this.findface(cubie[i]);\n        if (\n          this.faceprecedence[this.getfaceindex(temp)] <\n          this.faceprecedence[this.getfaceindex(minf)]\n        ) {\n          mini = i;\n          minf = temp;\n        }\n      }\n      if (mini !== 0) {\n        const ocubie = cubie.slice();\n        const ofacelist = facelist.slice();\n        for (let i = 0; i < cubie.length; i++) {\n          cubie[i] = ocubie[(mini + i) % cubie.length];\n          facelist[i] = ofacelist[(mini + i) % cubie.length];\n        }\n      }\n    }\n    //  Build an array that takes each face to a cubie ordinal and a\n    //  face number.\n    const facetocubies = [];\n    for (let i = 0; i < cubies.length; i++) {\n      const facelist = facelisthash[cubiekeys[i]];\n      for (let j = 0; j < facelist.length; j++) {\n        facetocubies[facelist[j]] = [i, j];\n      }\n    }\n    this.facetocubies = facetocubies;\n    //  Calculate the orbits of each cubie.  Assumes we do all moves.\n    //  Also calculates which cubies are identical.\n    const typenames = [\"?\", \"CENTERS\", \"EDGES\", \"CORNERS\", \"C4RNER\", \"C5RNER\"];\n    const cubiesetnames = [];\n    const cubietypecounts = [0, 0, 0, 0, 0, 0];\n    const orbitoris = [];\n    const seen = [];\n    let cubiesetnum = 0;\n    const cubiesetnums = [];\n    const cubieordnums = [];\n    const cubieords = [];\n    // var cubiesetnumhash = {} ; // TODO\n    const cubievaluemap = [];\n    // Later we will make this smarter to use a get color for face function\n    // so we support puzzles with multiple faces the same color\n    const getcolorkey = (cubienum: number): string => {\n      return cubies[cubienum]\n        .map((_) => this.getfaceindex(this.findface(_)))\n        .join(\" \");\n    };\n    const cubiesetcubies: any = [];\n    for (let i = 0; i < cubies.length; i++) {\n      if (seen[i]) {\n        continue;\n      }\n      const cubie = cubies[i];\n      if (cubie.length === 0) {\n        continue;\n      }\n      const cubiekeymap: any = {};\n      let cubievalueid = 0;\n      cubieords.push(0);\n      cubiesetcubies.push([]);\n      const facecnt = cubie.length;\n      const typectr = cubietypecounts[facecnt]++;\n      let typename = typenames[facecnt];\n      if (typename === undefined || facecnt === this.basefacecount) {\n        typename = \"CORE\";\n      }\n      typename = typename + (typectr === 0 ? \"\" : typectr + 1);\n      cubiesetnames[cubiesetnum] = typename;\n      orbitoris[cubiesetnum] = facecnt;\n      const queue = [i];\n      let qg = 0;\n      seen[i] = true;\n      while (qg < queue.length) {\n        const cind = queue[qg++];\n        const cubiecolorkey = getcolorkey(cind);\n        if (cubie.length > 1 || cubiekeymap[cubiecolorkey] === undefined) {\n          cubiekeymap[cubiecolorkey] = cubievalueid++;\n        }\n        cubievaluemap[cind] = cubiekeymap[cubiecolorkey];\n        cubiesetnums[cind] = cubiesetnum;\n        cubiesetcubies[cubiesetnum].push(cind);\n        cubieordnums[cind] = cubieords[cubiesetnum]++;\n        for (let j = 0; j < moverotations.length; j++) {\n          const tq = this.findcubie(\n            moverotations[j][0].rotateface(cubies[cind][0]),\n          );\n          if (!seen[tq]) {\n            queue.push(tq);\n            seen[tq] = true;\n          }\n        }\n      }\n      cubiesetnum++;\n    }\n    this.orbits = cubieords.length;\n    this.cubiesetnums = cubiesetnums;\n    this.cubieordnums = cubieordnums;\n    this.cubiesetnames = cubiesetnames;\n    this.cubieords = cubieords;\n    this.orbitoris = orbitoris;\n    this.cubievaluemap = cubievaluemap;\n    this.cubiesetcubies = cubiesetcubies;\n    // if we fix a cubie, find a cubie to fix\n    if (this.fixPiece !== \"\") {\n      for (let i = 0; i < cubies.length; i++) {\n        if (\n          (this.fixPiece === \"v\" && cubies[i].length > 2) ||\n          (this.fixPiece === \"e\" && cubies[i].length === 2) ||\n          (this.fixPiece === \"f\" && cubies[i].length === 1)\n        ) {\n          this.fixedCubie = i;\n          break;\n        }\n      }\n      if (this.fixedCubie < 0) {\n        throw new Error(\n          \"Could not find a cubie of type \" + this.fixPiece + \" to fix.\",\n        );\n      }\n    }\n    // show the orbits\n    if (this.verbose) {\n      console.log(\"# Cubie orbit sizes \" + cubieords);\n    }\n  }\n\n  public unswizzle(mv: BlockMove): string {\n    const newmv = this.notationMapper.notationToInternal(mv);\n    return this.swizzler.unswizzle(newmv.family);\n  }\n\n  // We use an extremely permissive parse here; any character but\n  // digits are allowed in a family name.\n  public stringToBlockMove(mv: string): BlockMove {\n    // parse a move from the command line\n    const re = RegExp(\"^(([0-9]+)-)?([0-9]+)?([^0-9]+)([0-9]+'?)?$\");\n    const p = mv.match(re);\n    if (p === null) {\n      throw new Error(\"Bad move passed \" + mv);\n    }\n    const grip = p[4];\n    let loslice = undefined;\n    let hislice = undefined;\n    if (p[2] !== undefined) {\n      if (p[3] === undefined) {\n        throw new Error(\"Missing second number in range\");\n      }\n      loslice = parseInt(p[2], 10);\n    }\n    if (p[3] !== undefined) {\n      hislice = parseInt(p[3], 10);\n    }\n    let amountstr = \"1\";\n    let amount = 1;\n    if (p[5] !== undefined) {\n      amountstr = p[5];\n      if (amountstr[0] === \"'\") {\n        amountstr = \"-\" + amountstr.substring(1);\n      }\n      amount = parseInt(amountstr, 10);\n    }\n    return new BlockMove(loslice, hislice, grip, amount);\n  }\n\n  public parseBlockMove(blockmove: BlockMove): any {\n    blockmove = this.notationMapper.notationToInternal(blockmove); // pluggable notation\n    let grip = blockmove.family;\n    let fullrotation = false;\n    if (grip.endsWith(\"v\") && grip[0] <= \"Z\") {\n      if (\n        blockmove.innerLayer !== undefined ||\n        blockmove.outerLayer !== undefined\n      ) {\n        throw new Error(\"Cannot use a prefix with full cube rotations\");\n      }\n      grip = grip.slice(0, -1);\n      fullrotation = true;\n    }\n    if (grip.endsWith(\"w\") && grip[0] <= \"Z\") {\n      grip = grip.slice(0, -1).toLowerCase();\n    }\n    let geo;\n    let msi = -1;\n    const geoname = this.swizzler.unswizzle(grip);\n    let firstgrip = false;\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const g = this.movesetgeos[i];\n      if (geoname === g[0]) {\n        firstgrip = true;\n        geo = g;\n        msi = i;\n      }\n      if (geoname === g[2]) {\n        firstgrip = false;\n        geo = g;\n        msi = i;\n      }\n    }\n    let loslice = 1;\n    let hislice = 1;\n    if (grip.toUpperCase() !== grip) {\n      hislice = 2;\n    }\n    if (geo === undefined) {\n      throw new Error(\"Bad grip in move \" + blockmove.family);\n    }\n    if (blockmove.outerLayer !== undefined) {\n      loslice = blockmove.outerLayer;\n    }\n    if (blockmove.innerLayer !== undefined) {\n      if (blockmove.outerLayer === undefined) {\n        hislice = blockmove.innerLayer;\n        if (geoname === grip) {\n          loslice = hislice;\n        } else {\n          loslice = 1;\n        }\n      } else {\n        hislice = blockmove.innerLayer;\n      }\n    }\n    loslice--;\n    hislice--;\n    if (fullrotation) {\n      loslice = 0;\n      hislice = this.moveplanesets[msi].length;\n    }\n    if (\n      loslice < 0 ||\n      loslice > this.moveplanesets[msi].length ||\n      hislice < 0 ||\n      hislice > this.moveplanesets[msi].length\n    ) {\n      throw new Error(\"Bad slice spec \" + loslice + \" \" + hislice);\n    }\n    if (\n      !permissivieMoveParsing &&\n      loslice === 0 &&\n      hislice === this.moveplanesets[msi].length &&\n      !fullrotation\n    ) {\n      throw new Error(\n        \"! full puzzle rotations must be specified with v suffix.\",\n      );\n    }\n    const r = [undefined, msi, loslice, hislice, firstgrip, blockmove.amount];\n    return r;\n  }\n\n  public parsemove(mv: string): any {\n    const r = this.parseBlockMove(this.stringToBlockMove(mv));\n    r[0] = mv;\n    return r;\n  }\n\n  public genperms(): void {\n    // generate permutations for moves\n    if (this.cmovesbyslice.length > 0) {\n      // did this already?\n      return;\n    }\n    const cmovesbyslice = [];\n    // if orientCenters is set, we find all cubies that have only one\n    // sticker and that sticker is in the center of a face, and we\n    // introduce duplicate stickers so we can orient them properly.\n    if (this.orientCenters) {\n      for (let k = 0; k < this.cubies.length; k++) {\n        if (this.cubies[k].length === 1) {\n          const kk = this.findface(this.cubies[k][0]);\n          const i = this.getfaceindex(kk);\n          if (\n            centermassface(this.basefaces[i]).dist(\n              centermassface(this.faces[kk]),\n            ) < eps\n          ) {\n            const o = this.basefaces[i].length;\n            for (let m = 0; m < o; m++) {\n              this.cubies[k].push(this.cubies[k][0]);\n            }\n            this.duplicatedFaces[kk] = o;\n            this.duplicatedCubies[k] = o;\n            this.orbitoris[this.cubiesetnums[k]] = o;\n          }\n        }\n      }\n    }\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveplaneset = this.moveplanesets[k];\n      const slicenum = [];\n      const slicecnts = [];\n      for (let i = 0; i < this.faces.length; i++) {\n        const face = this.faces[i];\n        let t = 0;\n        for (let j = 0; j < moveplaneset.length; j++) {\n          if (moveplaneset[j].faceside(face) < 0) {\n            t++;\n          }\n        }\n        slicenum.push(t);\n        while (slicecnts.length <= t) {\n          slicecnts.push(0);\n        }\n        slicecnts[t]++;\n      }\n      const axiscmoves = [];\n      for (let sc = 0; sc < slicecnts.length; sc++) {\n        const slicecmoves = [];\n        const cubiedone = [];\n        for (let i = 0; i < this.faces.length; i++) {\n          if (slicenum[i] !== sc) {\n            continue;\n          }\n          const b = this.facetocubies[i].slice();\n          let face = this.faces[i];\n          let fi2 = i;\n          for (;;) {\n            slicenum[fi2] = -1;\n            const face2 = this.moverotations[k][0].rotateface(face);\n            fi2 = this.findface(face2);\n            if (slicenum[fi2] < 0) {\n              break;\n            }\n            if (slicenum[fi2] !== sc) {\n              throw new Error(\"Bad movement?\");\n            }\n            const c = this.facetocubies[fi2];\n            b.push(c[0], c[1]);\n            face = face2;\n          }\n          // If an oriented center is moving, we need to figure out\n          // the appropriate new orientation.  Normally we use the cubie\n          // sticker identity to locate, but this doesn't work here.\n          // Instead we need to redo the geometry of the sticker itself\n          // rotating and figure out how that maps to the destination\n          // sticker.\n          //\n          // We only need to do this for central center stickers: those\n          // where the face vertex goes through the center.  The others\n          // don't actually need orientation because they can only be\n          // in one orientation by physical constraints.  (You can't spin\n          // a point or cross sticker on the 5x5x5, for example.)\n          //\n          // This also simplifies things because it means the actual\n          // remapping has the same order as the moves themselves.\n          //\n          // The center may or may not have been duplicated at this point.\n          //\n          // The move moving the center might not be the same modulo as the\n          // center itself.\n          if (\n            b.length > 2 &&\n            this.orientCenters &&\n            (this.cubies[b[0]].length === 1 ||\n              this.cubies[b[0]][0] === this.cubies[b[0]][1])\n          ) {\n            // is this a real center cubie, around an axis?\n            if (\n              centermassface(this.faces[i]).dist(\n                centermassface(this.basefaces[this.getfaceindex(i)]),\n              ) < eps\n            ) {\n              // how does remapping of the face/point set map to the original?\n              let face1 = this.cubies[b[0]][0];\n              for (let ii = 0; ii < b.length; ii += 2) {\n                const face0 = this.cubies[b[ii]][0];\n                let o = -1;\n                for (let jj = 0; jj < face1.length; jj++) {\n                  if (face0[jj].dist(face1[0]) < eps) {\n                    o = jj;\n                    break;\n                  }\n                }\n                if (o < 0) {\n                  throw new Error(\n                    \"Couldn't find rotation of center faces; ignoring for now.\",\n                  );\n                } else {\n                  b[ii + 1] = o;\n                  face1 = this.moverotations[k][0].rotateface(face1);\n                }\n              }\n            }\n          }\n          // b.length == 2 means a sticker is spinning in place.\n          // in this case we add duplicate stickers\n          // so that we can make it animate properly in a 3D world.\n          if (b.length === 2 && this.orientCenters) {\n            for (let ii = 1; ii < this.movesetorders[k]; ii++) {\n              if (sc === 0) {\n                b.push(b[0], ii);\n              } else {\n                b.push(\n                  b[0],\n                  (this.movesetorders[k] - ii) % this.movesetorders[k],\n                );\n              }\n            }\n          }\n          if (b.length > 2 && !cubiedone[b[0]]) {\n            if (b.length !== 2 * this.movesetorders[k]) {\n              throw new Error(\"Bad length in perm gen\");\n            }\n            for (let j = 0; j < b.length; j++) {\n              slicecmoves.push(b[j]);\n            }\n          }\n          for (let j = 0; j < b.length; j += 2) {\n            cubiedone[b[j]] = true;\n          }\n        }\n        axiscmoves.push(slicecmoves);\n      }\n      cmovesbyslice.push(axiscmoves);\n    }\n    this.cmovesbyslice = cmovesbyslice;\n    if (this.movelist !== undefined) {\n      const parsedmovelist: any[] = [];\n      // make sure the movelist makes sense based on the geos.\n      for (let i = 0; i < this.movelist.length; i++) {\n        parsedmovelist.push(this.parsemove(this.movelist[i]));\n      }\n      this.parsedmovelist = parsedmovelist;\n    }\n  }\n\n  public getfaces(): number[][][] {\n    // get the faces for 3d.\n    return this.faces.map((_) => {\n      return _.map((__) => [__.b, __.c, __.d]);\n    });\n  }\n\n  public getboundarygeometry(): any {\n    // get the boundary geometry\n    return {\n      baseplanes: this.baseplanes,\n      facenames: this.facenames,\n      faceplanes: this.faceplanes,\n      vertexnames: this.vertexnames,\n      edgenames: this.edgenames,\n      geonormals: this.geonormals,\n    };\n  }\n\n  public getmovesets(k: number): any {\n    // get the move sets we support based on slices\n    // for even values we omit the middle \"slice\".  This isn't perfect\n    // but it is what we do for now.\n    // if there was a move list specified, pull values from that\n    const slices = this.moveplanesets[k].length;\n    if (slices > 30) {\n      throw new Error(\"Too many slices for getmovesets bitmasks\");\n    }\n    let r = [];\n    if (this.parsedmovelist !== undefined) {\n      for (let i = 0; i < this.parsedmovelist.length; i++) {\n        const parsedmove = this.parsedmovelist[i];\n        if (parsedmove[1] !== k) {\n          continue;\n        }\n        if (parsedmove[4]) {\n          r.push((2 << parsedmove[3]) - (1 << parsedmove[2]));\n        } else {\n          r.push(\n            (2 << (slices - parsedmove[2])) - (1 << (slices - parsedmove[3])),\n          );\n        }\n        r.push(parsedmove[5]);\n      }\n    } else if (this.vertexmoves && !this.allmoves) {\n      const msg = this.movesetgeos[k];\n      if (msg[1] !== msg[3]) {\n        for (let i = 0; i < slices; i++) {\n          if (msg[1] !== \"v\") {\n            if (this.outerblockmoves) {\n              r.push((2 << slices) - (2 << i));\n            } else {\n              r.push(2 << i);\n            }\n            r.push(1);\n          } else {\n            if (this.outerblockmoves) {\n              r.push((2 << i) - 1);\n            } else {\n              r.push(1 << i);\n            }\n            r.push(1);\n          }\n        }\n      }\n    } else {\n      for (let i = 0; i <= slices; i++) {\n        if (!this.allmoves && i + i === slices) {\n          continue;\n        }\n        if (this.outerblockmoves) {\n          if (i + i > slices) {\n            r.push((2 << slices) - (1 << i));\n          } else {\n            r.push((2 << i) - 1);\n          }\n        } else {\n          r.push(1 << i);\n        }\n        r.push(1);\n      }\n    }\n    if (this.fixedCubie >= 0) {\n      const dep = 1 << +this.cubiekeys[this.fixedCubie].trim().split(\" \")[k];\n      const newr = [];\n      for (let i = 0; i < r.length; i += 2) {\n        let o = r[i];\n        if (o & dep) {\n          o = (2 << slices) - 1 - o;\n        }\n        let found = false;\n        for (let j = 0; j < newr.length; j += 2) {\n          if (newr[j] === o && newr[j + 1] === r[i + 1]) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          newr.push(o);\n          newr.push(r[i + 1]);\n        }\n      }\n      r = newr;\n    }\n    return r;\n  }\n\n  public graybyori(cubie: number): boolean {\n    let ori = this.cubies[cubie].length;\n    if (this.duplicatedCubies[cubie]) {\n      ori = 1;\n    }\n    return (\n      (ori === 1 && (this.graycenters || !this.centersets)) ||\n      (ori === 2 && (this.grayedges || !this.edgesets)) ||\n      (ori > 2 && (this.graycorners || !this.cornersets))\n    );\n  }\n\n  public skipbyori(cubie: number): boolean {\n    let ori = this.cubies[cubie].length;\n    if (this.duplicatedCubies[cubie]) {\n      ori = 1;\n    }\n    return (\n      (ori === 1 && !this.centersets) ||\n      (ori === 2 && !this.edgesets) ||\n      (ori > 2 && !this.cornersets)\n    );\n  }\n\n  public skipcubie(fi: number): boolean {\n    return this.skipbyori(fi);\n  }\n\n  public skipset(set: number[]): boolean {\n    if (set.length === 0) {\n      return true;\n    }\n    const fi = set[0];\n    return this.skipbyori(this.facetocubies[fi][0]);\n  }\n\n  public header(comment: string): string {\n    return comment + copyright + \"\\n\" + comment + this.args + \"\\n\";\n  }\n\n  public writegap(): string {\n    // write out a gap set of generators\n    const os = this.getOrbitsDef(false);\n    const r = [];\n    const mvs = [];\n    for (let i = 0; i < os.moveops.length; i++) {\n      const movename = \"M_\" + os.movenames[i];\n      // gap doesn't like angle brackets in IDs\n      mvs.push(movename);\n      r.push(movename + \":=\" + os.moveops[i].toPerm().toGap() + \";\");\n    }\n    r.push(\"Gen:=[\");\n    r.push(mvs.join(\",\"));\n    r.push(\"];\");\n    const ip = os.solved.identicalPieces();\n    r.push(\n      \"ip:=[\" +\n        ip.map((_) => \"[\" + _.map((__) => __ + 1).join(\",\") + \"]\").join(\",\") +\n        \"];\",\n    );\n    r.push(\"\");\n    return this.header(\"# \") + r.join(\"\\n\");\n  }\n\n  public writeksolve(\n    name: string = \"PuzzleGeometryPuzzle\",\n    fortwisty: boolean = false,\n  ): string {\n    const od = this.getOrbitsDef(fortwisty);\n    if (fortwisty) {\n      return od.toKsolve(name, fortwisty).join(\"\\n\");\n    } else {\n      return this.header(\"# \") + od.toKsolve(name, fortwisty).join(\"\\n\");\n    }\n  }\n\n  public writekpuzzle(fortwisty: boolean = true): any {\n    const od = this.getOrbitsDef(fortwisty);\n    const r = od.toKpuzzle() as KPuzzleDefinition;\n    r.moveNotation = new PGNotation(this, od);\n    return r;\n  }\n\n  public getMoveFromBits(\n    movebits: number,\n    amount: number,\n    inverted: boolean,\n    axiscmoves: number[][],\n    setmoves: number[] | undefined,\n    movesetorder: number,\n  ): Transformation {\n    const moveorbits: Orbit[] = [];\n    const perms = [];\n    const oris = [];\n    for (let ii = 0; ii < this.cubiesetnames.length; ii++) {\n      perms.push(iota(this.cubieords[ii]));\n      oris.push(zeros(this.cubieords[ii]));\n    }\n    for (let m = 0; m < axiscmoves.length; m++) {\n      if (((movebits >> m) & 1) === 0) {\n        continue;\n      }\n      const slicecmoves = axiscmoves[m];\n      for (let j = 0; j < slicecmoves.length; j += 2 * movesetorder) {\n        const mperm = slicecmoves.slice(j, j + 2 * movesetorder);\n        const setnum = this.cubiesetnums[mperm[0]];\n        for (let ii = 0; ii < mperm.length; ii += 2) {\n          mperm[ii] = this.cubieordnums[mperm[ii]];\n        }\n        let inc = 2;\n        let oinc = 3;\n        if (inverted) {\n          inc = mperm.length - 2;\n          oinc = mperm.length - 1;\n        }\n        if (perms[setnum] === iota(this.cubieords[setnum])) {\n          perms[setnum] = perms[setnum].slice();\n          if (this.orbitoris[setnum] > 1 && !this.killorientation) {\n            oris[setnum] = oris[setnum].slice();\n          }\n        }\n        for (let ii = 0; ii < mperm.length; ii += 2) {\n          perms[setnum][mperm[(ii + inc) % mperm.length]] = mperm[ii];\n          if (this.orbitoris[setnum] > 1 && !this.killorientation) {\n            oris[setnum][mperm[ii]] =\n              (mperm[(ii + oinc) % mperm.length] -\n                mperm[(ii + 1) % mperm.length] +\n                2 * this.orbitoris[setnum]) %\n              this.orbitoris[setnum];\n          }\n        }\n      }\n    }\n    for (let ii = 0; ii < this.cubiesetnames.length; ii++) {\n      if (setmoves && !setmoves[ii]) {\n        continue;\n      }\n      if (this.orbitoris[ii] === 1 || this.killorientation) {\n        moveorbits.push(new Orbit(perms[ii], oris[ii], 1));\n      } else {\n        const no = new Array<number>(oris[ii].length);\n        // convert ksolve oris to our internal ori rep\n        for (let jj = 0; jj < perms[ii].length; jj++) {\n          no[jj] = oris[ii][perms[ii][jj]];\n        }\n        moveorbits.push(new Orbit(perms[ii], no, this.orbitoris[ii]));\n      }\n    }\n    let mv = new Transformation(moveorbits);\n    if (amount !== 1) {\n      mv = mv.mulScalar(amount);\n    }\n    return mv;\n  }\n\n  public getOrbitsDef(fortwisty: boolean): OrbitsDef {\n    // generate a representation of the puzzle\n    const setmoves = [];\n    const setnames: string[] = [];\n    const setdefs: OrbitDef[] = [];\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveset = this.getmovesets(k);\n      const movesetorder = this.movesetorders[k];\n      // check there's no redundancy in moveset.\n      for (let i = 0; i < moveset.length; i += 2) {\n        for (let j = 0; j < i; j += 2) {\n          if (moveset[i] === moveset[j] && moveset[i + 1] === moveset[j + 1]) {\n            throw new Error(\"Redundant moves in moveset.\");\n          }\n        }\n      }\n      let allbits = 0;\n      for (let i = 0; i < moveset.length; i += 2) {\n        allbits |= moveset[i];\n      }\n      const axiscmoves = this.cmovesbyslice[k];\n      for (let i = 0; i < axiscmoves.length; i++) {\n        if (((allbits >> i) & 1) === 0) {\n          continue;\n        }\n        const slicecmoves = axiscmoves[i];\n        for (let j = 0; j < slicecmoves.length; j += 2 * movesetorder) {\n          if (this.skipcubie(slicecmoves[j])) {\n            continue;\n          }\n          const ind = this.cubiesetnums[slicecmoves[j]];\n          setmoves[ind] = 1;\n        }\n      }\n    }\n    for (let i = 0; i < this.cubiesetnames.length; i++) {\n      if (!setmoves[i]) {\n        continue;\n      }\n      setnames.push(this.cubiesetnames[i]);\n      setdefs.push(\n        new OrbitDef(\n          this.cubieords[i],\n          this.killorientation ? 1 : this.orbitoris[i],\n        ),\n      );\n    }\n    const solved: Orbit[] = [];\n    for (let i = 0; i < this.cubiesetnames.length; i++) {\n      if (!setmoves[i]) {\n        continue;\n      }\n      const p = [];\n      const o = [];\n      for (let j = 0; j < this.cubieords[i]; j++) {\n        if (fortwisty) {\n          p.push(j);\n        } else {\n          const cubie = this.cubiesetcubies[i][j];\n          p.push(this.cubievaluemap[cubie]);\n        }\n        o.push(0);\n      }\n      solved.push(\n        new Orbit(p, o, this.killorientation ? 1 : this.orbitoris[i]),\n      );\n    }\n    const movenames: string[] = [];\n    const moves: Transformation[] = [];\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveplaneset = this.moveplanesets[k];\n      const slices = moveplaneset.length;\n      const moveset = this.getmovesets(k);\n      const movesetgeo = this.movesetgeos[k];\n      for (let i = 0; i < moveset.length; i += 2) {\n        const movebits = moveset[i];\n        const mna = getmovename(movesetgeo, movebits, slices);\n        const movename = mna[0];\n        const inverted = mna[1];\n        if (moveset[i + 1] === 1) {\n          movenames.push(movename);\n        } else {\n          movenames.push(movename + moveset[i + 1]);\n        }\n        const mv = this.getMoveFromBits(\n          movebits,\n          moveset[i + 1],\n          inverted,\n          this.cmovesbyslice[k],\n          setmoves,\n          this.movesetorders[k],\n        );\n        moves.push(mv);\n      }\n    }\n    this.ksolvemovenames = movenames; // hack!\n    let r = new OrbitsDef(\n      setnames,\n      setdefs,\n      new VisibleState(solved),\n      movenames,\n      moves,\n    );\n    if (this.optimize) {\n      r = r.optimize();\n    }\n    if (this.scramble !== 0) {\n      r.scramble(this.scramble);\n    }\n    return r;\n  }\n\n  public getMovesAsPerms(): Perm[] {\n    return this.getOrbitsDef(false).moveops.map((_: Transformation) =>\n      _.toPerm(),\n    );\n  }\n\n  public showcanon(disp: (s: string) => void): void {\n    // show information for canonical move derivation\n    showcanon(this.getOrbitsDef(false), disp);\n  }\n\n  public getsolved(): Perm {\n    // get a solved position\n    const r = [];\n    for (let i = 0; i < this.basefacecount; i++) {\n      for (let j = 0; j < this.stickersperface; j++) {\n        r.push(i);\n      }\n    }\n    return new Perm(r);\n  }\n\n  // Given a rotation description that says to align feature1\n  // with a given vector, and then as much as possible feature2\n  // with another given vector, return a Quaternion that\n  // performs this rotation.\n  public getOrientationRotation(desiredRotation: any[]): Quat {\n    const feature1name = desiredRotation[0];\n    const direction1 = new Quat(\n      0,\n      desiredRotation[1][0],\n      -desiredRotation[1][1],\n      desiredRotation[1][2],\n    );\n    const feature2name = desiredRotation[2];\n    const direction2 = new Quat(\n      0,\n      desiredRotation[3][0],\n      -desiredRotation[3][1],\n      desiredRotation[3][2],\n    );\n    let feature1: Quat | null = null;\n    let feature2: Quat | null = null;\n    const feature1geoname = this.swizzler.unswizzle(feature1name);\n    const feature2geoname = this.swizzler.unswizzle(feature2name);\n    for (const gn of this.geonormals) {\n      if (feature1geoname === gn[1]) {\n        feature1 = gn[0];\n      }\n      if (feature2geoname === gn[1]) {\n        feature2 = gn[0];\n      }\n    }\n    if (!feature1) {\n      throw new Error(\"Could not find feature \" + feature1name);\n    }\n    if (!feature2) {\n      throw new Error(\"Could not find feature \" + feature2name);\n    }\n    const r1 = feature1.pointrotation(direction1);\n    const feature2rot = feature2.rotatepoint(r1);\n    const r2 = feature2rot\n      .unproject(direction1)\n      .pointrotation(direction2.unproject(direction1));\n    return r2.mul(r1);\n  }\n\n  public getInitial3DRotation(): Quat {\n    const basefacecount = this.basefacecount;\n    let rotDesc: any = null;\n    if (this.puzzleOrientation) {\n      rotDesc = this.puzzleOrientation;\n    } else if (this.puzzleOrientations) {\n      rotDesc = this.puzzleOrientations[basefacecount];\n    }\n    // either no option specified or no matching key in\n    // puzzleOrientations.\n    if (!rotDesc) {\n      rotDesc = defaultOrientations()[basefacecount];\n    }\n    if (!rotDesc) {\n      throw new Error(\"No default orientation?\");\n    }\n    return this.getOrientationRotation(rotDesc);\n  }\n\n  public generatesvg(\n    w: number = 800,\n    h: number = 500,\n    trim: number = 10,\n    threed: boolean = false,\n  ): string {\n    // generate svg to interoperate with Lucas twistysim\n    w -= 2 * trim;\n    h -= 2 * trim;\n    function extendedges(a: number[][], n: number): void {\n      let dx = a[1][0] - a[0][0];\n      let dy = a[1][1] - a[0][1];\n      const ang = (2 * Math.PI) / n;\n      const cosa = Math.cos(ang);\n      const sina = Math.sin(ang);\n      for (let i = 2; i < n; i++) {\n        const ndx = dx * cosa + dy * sina;\n        dy = dy * cosa - dx * sina;\n        dx = ndx;\n        a.push([a[i - 1][0] + dx, a[i - 1][1] + dy]);\n      }\n    }\n    // if we don't add this noise to coordinate values, then Safari\n    // doesn't render our polygons correctly.  What a hack.\n    function noise(c: number): number {\n      return c + 0 * (Math.random() - 0.5);\n    }\n    function drawedges(id: string, pts: number[][], color: string): string {\n      return (\n        '<polygon id=\"' +\n        id +\n        '\" class=\"sticker\" style=\"fill: ' +\n        color +\n        '\" points=\"' +\n        pts.map((p) => noise(p[0]) + \" \" + noise(p[1])).join(\" \") +\n        '\"/>\\n'\n      );\n    }\n    // What grips do we need?  if rotations, add all grips.\n    let needvertexgrips = this.addrotations;\n    let neededgegrips = this.addrotations;\n    let needfacegrips = this.addrotations;\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const msg = this.movesetgeos[i];\n      for (let j = 1; j <= 3; j += 2) {\n        if (msg[j] === \"v\") {\n          needvertexgrips = true;\n        }\n        if (msg[j] === \"f\") {\n          needfacegrips = true;\n        }\n        if (msg[j] === \"e\") {\n          neededgegrips = true;\n        }\n      }\n    }\n    // Find a net from a given face count.  Walk it, assuming we locate\n    // the first edge from (0,0) to (1,1) and compute the minimum and\n    // maximum vertex locations from this.  Then do a second walk, and\n    // assign the actual geometry.\n    this.genperms();\n    const boundarygeo = this.getboundarygeometry();\n    const face0 = boundarygeo.facenames[0][0];\n    const polyn = face0.length; // number of vertices; 3, 4, or 5\n    const net = this.net;\n    if (net === null) {\n      throw new Error(\"No net?\");\n    }\n    const edges: any = {};\n    let minx = 0;\n    let miny = 0;\n    let maxx = 1;\n    let maxy = 0;\n    edges[net[0][0]] = [\n      [1, 0],\n      [0, 0],\n    ];\n    extendedges(edges[net[0][0]], polyn);\n    for (let i = 0; i < net.length; i++) {\n      const f0 = net[i][0];\n      if (!edges[f0]) {\n        throw new Error(\"Bad edge description; first edge not connected.\");\n      }\n      for (let j = 1; j < net[i].length; j++) {\n        const f1 = net[i][j];\n        if (f1 === \"\" || edges[f1]) {\n          continue;\n        }\n        edges[f1] = [edges[f0][j % polyn], edges[f0][(j + polyn - 1) % polyn]];\n        extendedges(edges[f1], polyn);\n      }\n    }\n    for (const f in edges) {\n      const es = edges[f];\n      for (let i = 0; i < es.length; i++) {\n        minx = Math.min(minx, es[i][0]);\n        maxx = Math.max(maxx, es[i][0]);\n        miny = Math.min(miny, es[i][1]);\n        maxy = Math.max(maxy, es[i][1]);\n      }\n    }\n    const sc = Math.min(w / (maxx - minx), h / (maxy - miny));\n    const xoff = 0.5 * (w - sc * (maxx + minx));\n    const yoff = 0.5 * (h - sc * (maxy + miny));\n    const geos: any = {};\n    const bg = this.getboundarygeometry();\n    const edges2: any = {};\n    const initv = [\n      [sc + xoff, yoff],\n      [xoff, yoff],\n    ];\n    edges2[net[0][0]] = initv;\n    extendedges(edges2[net[0][0]], polyn);\n    geos[this.facenames[0][1]] = this.project2d(0, 0, [\n      new Quat(0, initv[0][0], initv[0][1], 0),\n      new Quat(0, initv[1][0], initv[1][1], 0),\n    ]);\n    const connectat = [];\n    connectat[0] = 0;\n    for (let i = 0; i < net.length; i++) {\n      const f0 = net[i][0];\n      if (!edges2[f0]) {\n        throw new Error(\"Bad edge description; first edge not connected.\");\n      }\n      let gfi = -1;\n      for (let j = 0; j < bg.facenames.length; j++) {\n        if (f0 === bg.facenames[j][1]) {\n          gfi = j;\n          break;\n        }\n      }\n      if (gfi < 0) {\n        throw new Error(\"Could not find first face name \" + f0);\n      }\n      const thisface = bg.facenames[gfi][0];\n      for (let j = 1; j < net[i].length; j++) {\n        const f1 = net[i][j];\n        if (f1 === \"\" || edges2[f1]) {\n          continue;\n        }\n        edges2[f1] = [\n          edges2[f0][j % polyn],\n          edges2[f0][(j + polyn - 1) % polyn],\n        ];\n        extendedges(edges2[f1], polyn);\n        // what edge are we at?\n        const caf0 = connectat[gfi];\n        const mp = thisface[(caf0 + j) % polyn]\n          .sum(thisface[(caf0 + j + polyn - 1) % polyn])\n          .smul(0.5);\n        const epi = findelement(bg.edgenames, mp);\n        const edgename = bg.edgenames[epi][1];\n        const el = splitByFaceNames(edgename, this.facenames);\n        const gf1 = el[f0 === el[0] ? 1 : 0];\n        let gf1i = -1;\n        for (let k = 0; k < bg.facenames.length; k++) {\n          if (gf1 === bg.facenames[k][1]) {\n            gf1i = k;\n            break;\n          }\n        }\n        if (gf1i < 0) {\n          throw new Error(\"Could not find second face name\");\n        }\n        const otherface = bg.facenames[gf1i][0];\n        for (let k = 0; k < otherface.length; k++) {\n          const mp2 = otherface[k].sum(otherface[(k + 1) % polyn]).smul(0.5);\n          if (mp2.dist(mp) <= eps) {\n            const p1 = edges2[f0][(j + polyn - 1) % polyn];\n            const p2 = edges2[f0][j % polyn];\n            connectat[gf1i] = k;\n            geos[gf1] = this.project2d(gf1i, k, [\n              new Quat(0, p2[0], p2[1], 0),\n              new Quat(0, p1[0], p1[1], 0),\n            ]);\n            break;\n          }\n        }\n      }\n    }\n    // Let's build arrays for faster rendering.  We want to map from geo\n    // base face number to color, and we want to map from geo face number\n    // to 2D geometry.  These can be reused as long as the puzzle overall\n    // orientation and canvas size remains unchanged.\n    const pos = this.getsolved();\n    const colormap = [];\n    const facegeo = [];\n    for (let i = 0; i < this.basefacecount; i++) {\n      colormap[i] = this.colors[this.facenames[i][1]];\n    }\n    let hix = 0;\n    let hiy = 0;\n    const rot = this.getInitial3DRotation();\n    for (let i = 0; i < this.faces.length; i++) {\n      let face = this.faces[i];\n      face = rot.rotateface(face);\n      for (let j = 0; j < face.length; j++) {\n        hix = Math.max(hix, Math.abs(face[j].b));\n        hiy = Math.max(hiy, Math.abs(face[j].c));\n      }\n    }\n    const sc2 = Math.min(h / hiy / 2, (w - trim) / hix / 4);\n    const mappt2d = (fn: number, q: Quat): number[] => {\n      if (threed) {\n        const xoff2 = 0.5 * trim + 0.25 * w;\n        const xmul = this.baseplanes[fn].rotateplane(rot).d < 0 ? 1 : -1;\n        return [\n          trim + w * 0.5 + xmul * (xoff2 - q.b * sc2),\n          trim + h * 0.5 + q.c * sc2,\n        ];\n      } else {\n        const g = geos[this.facenames[fn][1]];\n        return [trim + q.dot(g[0]) + g[2].b, trim + h - q.dot(g[1]) - g[2].c];\n      }\n    };\n    for (let i = 0; i < this.faces.length; i++) {\n      let face = this.faces[i];\n      const facenum = Math.floor(i / this.stickersperface);\n      if (threed) {\n        face = rot.rotateface(face);\n      }\n      facegeo.push(face.map((_: Quat) => mappt2d(facenum, _)));\n    }\n    const svg = [];\n    // group each base face so we can add a hover element\n    for (let j = 0; j < this.basefacecount; j++) {\n      svg.push(\"<g>\");\n      svg.push(\"<title>\" + this.facenames[j][1] + \"</title>\\n\");\n      for (let ii = 0; ii < this.stickersperface; ii++) {\n        const i = j * this.stickersperface + ii;\n        const cubie = this.facetocubies[i][0];\n        const cubieori = this.facetocubies[i][1];\n        const cubiesetnum = this.cubiesetnums[cubie];\n        const cubieord = this.cubieordnums[cubie];\n        const color = this.graybyori(cubie) ? \"#808080\" : colormap[pos.p[i]];\n        let id =\n          this.cubiesetnames[cubiesetnum] + \"-l\" + cubieord + \"-o\" + cubieori;\n        svg.push(drawedges(id, facegeo[i], color));\n        if (this.duplicatedFaces[i]) {\n          for (let jj = 1; jj < this.duplicatedFaces[i]; jj++) {\n            id = this.cubiesetnames[cubiesetnum] + \"-l\" + cubieord + \"-o\" + jj;\n            svg.push(drawedges(id, facegeo[i], color));\n          }\n        }\n      }\n      svg.push(\"</g>\");\n    }\n    const svggrips: any[] = [];\n    function addgrip(\n      onface: number,\n      name: string,\n      pt: Quat,\n      order: number,\n    ): void {\n      const pt2 = mappt2d(onface, pt);\n      for (let i = 0; i < svggrips.length; i++) {\n        if (\n          Math.hypot(pt2[0] - svggrips[i][0], pt2[1] - svggrips[i][1]) < eps\n        ) {\n          return;\n        }\n      }\n      svggrips.push([pt2[0], pt2[1], name, order]);\n    }\n    for (let i = 0; i < this.faceplanes.length; i++) {\n      const baseface = this.facenames[i][0];\n      let facecoords = baseface;\n      if (threed) {\n        facecoords = rot.rotateface(facecoords);\n      }\n      if (needfacegrips) {\n        let pt = this.faceplanes[i][0];\n        if (threed) {\n          pt = pt.rotatepoint(rot);\n        }\n        addgrip(i, this.faceplanes[i][1], pt, polyn);\n      }\n      for (let j = 0; j < baseface.length; j++) {\n        if (neededgegrips) {\n          const mp = baseface[j]\n            .sum(baseface[(j + 1) % baseface.length])\n            .smul(0.5);\n          const ep = findelement(this.edgenames, mp);\n          const mpc = facecoords[j]\n            .sum(facecoords[(j + 1) % baseface.length])\n            .smul(0.5);\n          addgrip(i, this.edgenames[ep][1], mpc, 2);\n        }\n        if (needvertexgrips) {\n          const vp = findelement(this.vertexnames, baseface[j]);\n          addgrip(i, this.vertexnames[vp][1], facecoords[j], this.cornerfaces);\n        }\n      }\n    }\n    const html =\n      '<svg id=\"svg\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 800 500\">\\n' +\n      '<style type=\"text/css\"><![CDATA[' +\n      \".sticker { stroke: #000000; stroke-width: 1px; }\" +\n      \"]]></style>\\n\" +\n      svg.join(\"\") +\n      \"</svg>\";\n    this.svggrips = svggrips;\n    return html;\n  }\n\n  public dist(a: number[], b: number[]): number {\n    return Math.hypot(a[0] - b[0], a[1] - b[1], a[2] - b[2]);\n  }\n\n  public triarea(a: number[], b: number[], c: number[]): number {\n    const ab = this.dist(a, b);\n    const bc = this.dist(b, c);\n    const ac = this.dist(a, c);\n    const p = (ab + bc + ac) / 2;\n    return Math.sqrt(p * (p - ab) * (p - bc) * (p - ac));\n  }\n\n  public polyarea(coords: number[][]): number {\n    let sum = 0;\n    for (let i = 2; i < coords.length; i++) {\n      sum += this.triarea(coords[0], coords[1], coords[i]);\n    }\n    return sum;\n  }\n\n  // The colorfrac parameter says how much of the face should be\n  // colored (vs dividing lines); we default to 0.77 which seems\n  // to work pretty well.  It should be a number between probably\n  // 0.4 and 0.9.\n  public get3d(colorfrac: number = DEFAULT_COLOR_FRACTION): StickerDat {\n    const stickers: any = [];\n    const foundations: any = [];\n    const rot = this.getInitial3DRotation();\n    const faces: any = [];\n    const maxdist: number = 0.52 * this.basefaces[0][0].len();\n    let avgstickerarea = 0;\n    for (let i = 0; i < this.basefaces.length; i++) {\n      const coords = rot.rotateface(this.basefaces[i]);\n      const name = this.facenames[i][1];\n      faces.push({ coords: toFaceCoords(coords, maxdist), name });\n      avgstickerarea += this.polyarea(faces[i].coords);\n    }\n    avgstickerarea /= this.faces.length;\n    const trim = (Math.sqrt(avgstickerarea) * (1 - Math.sqrt(colorfrac))) / 2;\n    for (let i = 0; i < this.faces.length; i++) {\n      const facenum = Math.floor(i / this.stickersperface);\n      const cubie = this.facetocubies[i][0];\n      const cubieori = this.facetocubies[i][1];\n      const cubiesetnum = this.cubiesetnums[cubie];\n      const cubieord = this.cubieordnums[cubie];\n      const color = this.graybyori(cubie)\n        ? \"#808080\"\n        : this.colors[this.facenames[facenum][1]];\n      let coords = rot.rotateface(this.faces[i]);\n      foundations.push({\n        coords: toFaceCoords(coords, maxdist),\n        color,\n        orbit: this.cubiesetnames[cubiesetnum],\n        ord: cubieord,\n        ori: cubieori,\n      });\n      const fcoords = coords;\n      if (trim && trim > 0) {\n        coords = trimEdges(coords, trim);\n      }\n      stickers.push({\n        coords: toFaceCoords(coords, maxdist),\n        color,\n        orbit: this.cubiesetnames[cubiesetnum],\n        ord: cubieord,\n        ori: cubieori,\n      });\n      if (this.duplicatedFaces[i]) {\n        for (let jj = 1; jj < this.duplicatedFaces[i]; jj++) {\n          stickers.push({\n            coords: toFaceCoords(coords, maxdist),\n            color,\n            orbit: this.cubiesetnames[cubiesetnum],\n            ord: cubieord,\n            ori: jj,\n          });\n          foundations.push({\n            coords: toFaceCoords(fcoords, maxdist),\n            color,\n            orbit: this.cubiesetnames[cubiesetnum],\n            ord: cubieord,\n            ori: jj,\n          });\n        }\n      }\n    }\n    const grips: StickerDatAxis[] = [];\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const msg = this.movesetgeos[i];\n      const order = this.movesetorders[i];\n      for (let j = 0; j < this.geonormals.length; j++) {\n        const gn = this.geonormals[j];\n        if (msg[0] === gn[1] && msg[1] === gn[2]) {\n          grips.push([toCoords(gn[0].rotatepoint(rot), 1), msg[0], order]);\n          grips.push([\n            toCoords(gn[0].rotatepoint(rot).smul(-1), 1),\n            msg[2],\n            order,\n          ]);\n        }\n      }\n    }\n    const f = (function () {\n      return function (mv: BlockMove): string {\n        return this.unswizzle(mv);\n      };\n    })().bind(this);\n    return {\n      stickers,\n      foundations,\n      faces,\n      axis: grips,\n      unswizzle: f,\n      notationMapper: this.notationMapper,\n    };\n  }\n\n  //  From the name of a geometric element (face, vertex, edge), get a\n  //  normal vector respecting the default orientation.  This is useful\n  //  to define the initial position of the camera in a 3D scene.  The\n  //  return value is normalized, so multiply it by the camera distance.\n  //  Returns undefined if no such geometric element.\n  public getGeoNormal(geoname: string): number[] | undefined {\n    const rot = this.getInitial3DRotation();\n    const grip = this.swizzler.unswizzle(geoname);\n    for (let j = 0; j < this.geonormals.length; j++) {\n      const gn = this.geonormals[j];\n      if (grip === gn[1]) {\n        const r = toCoords(gn[0].rotatepoint(rot), 1);\n        //  This routine is intended to use for the camera location.\n        //  If the camera location is vertical, and we give some\n        //  near-zero values for x and z, then the rotation in the\n        //  X/Z plane will be somewhat arbitrary.  So we clean up the\n        //  returned vector here.  We give a very slight positive\n        //  z value.\n        if (Math.abs(r[0]) < eps && Math.abs(r[2]) < eps) {\n          r[0] = 0.0;\n          r[2] = 1e-6;\n        }\n        return r;\n      }\n    }\n    return undefined;\n  }\n\n  private getfaceindex(facenum: number): number {\n    const divid = this.stickersperface;\n    return Math.floor(facenum / divid);\n  }\n}\n\nclass PGNotation implements MoveNotation {\n  private cache: { [key: string]: KTransformation } = {};\n  constructor(public pg: PuzzleGeometry, public od: OrbitsDef) {}\n\n  public lookupMove(move: BlockMove): KTransformation | undefined {\n    const key = this.blockMoveToString(move);\n    if (key in this.cache) {\n      return this.cache[key];\n    }\n    const mv = this.pg.parseBlockMove(move);\n    let bits = (2 << mv[3]) - (1 << mv[2]);\n    if (!mv[4]) {\n      const slices = this.pg.moveplanesets[mv[1]].length;\n      bits = (2 << (slices - mv[2])) - (1 << (slices - mv[3]));\n    }\n    const pgmv = this.pg.getMoveFromBits(\n      bits,\n      mv[5],\n      !mv[4],\n      this.pg.cmovesbyslice[mv[1]],\n      undefined,\n      this.pg.movesetorders[mv[1]],\n    );\n    const r = this.od.transformToKPuzzle(pgmv);\n    this.cache[key] = r;\n    return r;\n  }\n\n  // This is only used to construct keys, so does not need to be beautiful.\n  private blockMoveToString(mv: BlockMove): string {\n    let r = \"\";\n    if (mv.outerLayer) {\n      r = r + mv.outerLayer + \",\";\n    }\n    if (mv.innerLayer) {\n      r = r + mv.innerLayer + \",\";\n    }\n    r = r + mv.family + \",\" + mv.amount;\n    return r;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
