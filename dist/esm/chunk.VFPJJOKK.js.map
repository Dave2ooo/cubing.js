{
  "version": 3,
  "sources": ["../../src/alg/json.ts", "../../src/alg/parser/index.ts"],
  "sourcesContent": ["import {\n  BlockMove,\n  Comment,\n  Commutator,\n  Conjugate,\n  Group,\n  NewLine,\n  Pause,\n  Sequence,\n  Unit,\n} from \"./algorithm\";\n\n// TODO: Turn this into a union.\nexport interface AlgJSON {\n  type: string;\n  nestedSequence?: AlgJSON;\n  nestedUnits?: AlgJSON[];\n  innerLayer?: number;\n  outerLayer?: number;\n  family?: string;\n  amount?: number;\n  A?: AlgJSON;\n  B?: AlgJSON;\n  comment?: string;\n}\n\nexport function fromJSON(json: AlgJSON): Sequence {\n  if (json.type !== \"sequence\") {\n    throw new Error(`Expected Sequence while parsing, got: ${json.type}`);\n  }\n  if (!json.nestedUnits) {\n    throw new Error(\"Missing nestedUnits\");\n  }\n  return new Sequence(json.nestedUnits.map((j) => unitFromJSON(j)));\n}\n\nfunction unitFromJSON(json: AlgJSON): Unit {\n  switch (json.type) {\n    case \"sequence\":\n      throw new Error(`Expected AlgPart while parsing, got \\`Sequence\\`.`);\n    case \"group\":\n      if (!json.nestedSequence) {\n        throw new Error(\"Missing nestedSequence\");\n      }\n      if (!json.amount) {\n        throw new Error(\"Missing amount\");\n      }\n      return new Group(fromJSON(json.nestedSequence), json.amount);\n    case \"blockMove\":\n      // TODO: Double-check that there is no outer layer without an inner layer?\n      if (!json.family) {\n        throw new Error(\"Missing family\");\n      }\n      if (!json.amount) {\n        throw new Error(\"Missing amount\");\n      }\n      return new BlockMove(\n        json.outerLayer,\n        json.innerLayer,\n        json.family,\n        json.amount,\n      );\n    case \"commutator\":\n      if (!json.A) {\n        throw new Error(\"Missing A\");\n      }\n      if (!json.B) {\n        throw new Error(\"Missing B\");\n      }\n      if (!json.amount) {\n        throw new Error(\"Missing amount\");\n      }\n      return new Commutator(fromJSON(json.A), fromJSON(json.B), json.amount);\n    case \"conjugate\":\n      if (!json.A) {\n        throw new Error(\"Missing A\");\n      }\n      if (!json.B) {\n        throw new Error(\"Missing B\");\n      }\n      if (!json.amount) {\n        throw new Error(\"Missing amount\");\n      }\n      return new Conjugate(fromJSON(json.A), fromJSON(json.B), json.amount);\n    case \"pause\":\n      return new Pause();\n    case \"newLine\":\n      return new NewLine();\n    case \"comment\":\n      // The empty string is nullish, so we check for it separately.\n      if (!json.comment && json.comment !== \"\") {\n        throw new Error(\"Missing comment\");\n      }\n      return new Comment(json.comment);\n    default:\n      throw new Error(`Unknown alg type: ${json.type}`);\n  }\n}\n", "import { Sequence } from \"../algorithm\";\nimport { fromJSON } from \"../json\";\nimport { validateSiGNAlg, Validator } from \"../validation\";\nimport { parse as pegParse } from \"./parser\";\n\nexport interface ParseOptions {\n  validators?: Validator[];\n}\n\n// TODO: Include token location info.\n// TODO: Take validators in a way that allows optimizing parsing.\nexport function parse(\n  s: string,\n  options: ParseOptions = { validators: [] },\n): Sequence {\n  options.validators = options.validators || [];\n\n  const algo = fromJSON(pegParse(s));\n  for (const validate of options.validators) {\n    validate(algo);\n  }\n  return algo;\n}\n\nexport function parseSiGN(s: string): Sequence {\n  return parse(s, { validators: [validateSiGNAlg] });\n}\n"],
  "mappings": ";;;;;;;;;;;;;AA0BO,kBAAkB;AACvB,MAAI,KAAK,SAAS;AAChB,UAAM,IAAI,MAAM,yCAAyC,KAAK;AAAA;AAEhE,MAAI,CAAC,KAAK;AACR,UAAM,IAAI,MAAM;AAAA;AAElB,SAAO,IAAI,SAAS,KAAK,YAAY,IAAI,OAAO,aAAa;AAAA;AAG/D;AACE,UAAQ,KAAK;AAAA,SACN;AACH,YAAM,IAAI,MAAM;AAAA,SACb;AACH,UAAI,CAAC,KAAK;AACR,cAAM,IAAI,MAAM;AAAA;AAElB,UAAI,CAAC,KAAK;AACR,cAAM,IAAI,MAAM;AAAA;AAElB,aAAO,IAAI,MAAM,SAAS,KAAK,iBAAiB,KAAK;AAAA,SAClD;AAEH,UAAI,CAAC,KAAK;AACR,cAAM,IAAI,MAAM;AAAA;AAElB,UAAI,CAAC,KAAK;AACR,cAAM,IAAI,MAAM;AAAA;AAElB,aAAO,IAAI,UACT,KAAK,YACL,KAAK,YACL,KAAK,QACL,KAAK;AAAA,SAEJ;AACH,UAAI,CAAC,KAAK;AACR,cAAM,IAAI,MAAM;AAAA;AAElB,UAAI,CAAC,KAAK;AACR,cAAM,IAAI,MAAM;AAAA;AAElB,UAAI,CAAC,KAAK;AACR,cAAM,IAAI,MAAM;AAAA;AAElB,aAAO,IAAI,WAAW,SAAS,KAAK,IAAI,SAAS,KAAK,IAAI,KAAK;AAAA,SAC5D;AACH,UAAI,CAAC,KAAK;AACR,cAAM,IAAI,MAAM;AAAA;AAElB,UAAI,CAAC,KAAK;AACR,cAAM,IAAI,MAAM;AAAA;AAElB,UAAI,CAAC,KAAK;AACR,cAAM,IAAI,MAAM;AAAA;AAElB,aAAO,IAAI,UAAU,SAAS,KAAK,IAAI,SAAS,KAAK,IAAI,KAAK;AAAA,SAC3D;AACH,aAAO,IAAI;AAAA,SACR;AACH,aAAO,IAAI;AAAA,SACR;AAEH,UAAI,CAAC,KAAK,WAAW,KAAK,YAAY;AACpC,cAAM,IAAI,MAAM;AAAA;AAElB,aAAO,IAAI,QAAQ,KAAK;AAAA;AAExB,YAAM,IAAI,MAAM,qBAAqB,KAAK;AAAA;AAAA;;;ACpFzC,eACL,aACwB,CAAE,YAAY;AAEtC,UAAQ,aAAa,QAAQ,cAAc;AAE3C,eAAa,SAAS,mBAAS;AAC/B,yBAAuB,QAAQ;AAC7B,aAAS;AAAA;AAEX,SAAO;AAAA;",
  "names": []
}
